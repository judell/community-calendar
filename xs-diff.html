<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>XMLUI Inspector</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/jsondiffpatch@0.7.3/lib/formatters/styles/html.css"
    />
    <style>
      /* =============================================================================
         CSS VARIABLES - Edit these to change the look
         ============================================================================= */
      :root {
        /* Colors */
        --color-text: #111;
        --color-text-muted: #4b5563;
        --color-text-faint: #6b7280;
        --color-text-subtle: #9ca3af;
        --color-error: #dc2626;
        --color-success: #059669;
        --color-warning: #d97706;
        --color-info: #4f46e5;
        --color-border: #e5e7eb;
        --color-bg: #fff;
        --color-bg-subtle: #f9fafb;
        --color-bg-muted: #fafafa;
        --color-bg-hover: #f3f4f6;
        --color-interaction-border: #a5b4fc;
        --color-interaction-bg: #eef2ff;

        /* Font sizes */
        --font-xs: 8px;
        --font-sm: 10px;
        --font-md: 11px;
        --font-base: 12px;
        --font-lg: 13px;

        /* Spacing */
        --space-1: 4px;
        --space-2: 6px;
        --space-3: 8px;
        --space-4: 12px;
        --space-5: 16px;

        /* Border radius */
        --radius-sm: 4px;
        --radius-md: 6px;
        --radius-lg: 8px;
      }

      /* =============================================================================
         BASE STYLES
         ============================================================================= */
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: var(--color-bg);
        color: var(--color-text);
        font-size: var(--font-base);
      }

      pre, code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }

      /* =============================================================================
         TOOLBAR
         ============================================================================= */
      .toolbar {
        display: flex;
        gap: var(--space-3);
        align-items: center;
        padding: var(--space-3) var(--space-4);
        border-bottom: 1px solid var(--color-border);
        background: var(--color-bg-subtle);
        position: sticky;
        top: 0;
        z-index: 1;
        flex-wrap: wrap;
      }

      .spacer { flex: 1 1 auto; }

      label { font-size: var(--font-base); color: var(--color-text); }

      input[type="text"], select {
        border: 1px solid #d1d5db;
        border-radius: var(--radius-md);
        padding: var(--space-1) var(--space-3);
        font-size: var(--font-base);
      }

      button {
        border: 1px solid var(--color-text-faint);
        background: var(--color-bg);
        padding: var(--space-1) var(--space-3);
        border-radius: var(--radius-md);
        cursor: pointer;
        font-size: var(--font-base);
      }
      button:hover { background: var(--color-bg-subtle); }

      /* =============================================================================
         SEARCH
         ============================================================================= */
      span.search-highlight {
        background-color: #fef3c7 !important;
        color: #92400e !important;
        border-radius: 2px;
        padding: 1px 3px;
        box-shadow: 0 0 0 1px #f59e0b;
        display: inline;
        position: relative;
        z-index: 1;
      }
      span.search-highlight-current {
        background-color: #f59e0b !important;
        color: white !important;
        box-shadow: 0 0 0 2px #d97706;
      }
      /* Ensure highlights show in pre/code blocks */
      pre span.search-highlight,
      code span.search-highlight {
        background-color: #fef3c7 !important;
        color: #92400e !important;
      }
      pre span.search-highlight-current,
      code span.search-highlight-current {
        background-color: #f59e0b !important;
        color: white !important;
      }

      /* =============================================================================
         CONTENT AREA
         ============================================================================= */
      #diff { padding: var(--space-4); }

      /* =============================================================================
         TRACE GROUPS (main cards)
         ============================================================================= */
      .trace-group {
        border: 1px solid var(--color-border);
        border-radius: var(--radius-lg);
        margin: var(--space-4) 0;
        overflow: hidden;
      }
      .trace-group--interaction {
        border-color: var(--color-interaction-border);
      }

      .trace-header {
        background: var(--color-bg-subtle);
        padding: var(--space-3) var(--space-4);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: var(--space-3);
        font-size: var(--font-lg);
      }
      .trace-header:hover { background: var(--color-bg-hover); }
      .trace-header--interaction { background: var(--color-interaction-bg); }

      .trace-header .arrow {
        transition: transform 0.2s;
        color: var(--color-text-muted);
      }
      .trace-header.expanded .arrow { transform: rotate(90deg); }

      .trace-summary { flex: 1; }
      .trace-summary .component { font-weight: 500; color: var(--color-text); }

      .trace-body {
        display: none;
        padding: var(--space-4);
        border-top: 1px solid var(--color-border);
      }
      .trace-group.expanded .trace-body { display: block; }

      /* =============================================================================
         TRACE EVENTS (items within a trace)
         ============================================================================= */
      .trace-event {
        margin: var(--space-3) 0;
        padding: var(--space-3);
        background: var(--color-bg-muted);
        border-radius: var(--radius-sm);
        font-size: var(--font-base);
      }

      .trace-event-header {
        color: var(--color-text-muted);
        margin-bottom: var(--space-1);
      }
      .trace-event-header strong { font-weight: 500; }

      /* =============================================================================
         STATUS INDICATORS
         ============================================================================= */
      .badge-success { color: var(--color-success); font-size: var(--font-base); }
      .badge-error { color: var(--color-error); font-size: var(--font-base); }
      .badge-warning { color: var(--color-warning); font-size: var(--font-base); }
      .badge-info { color: var(--color-info); font-weight: 500; }
      .badge-muted { color: var(--color-text-muted); font-size: var(--font-base); }
      .badge-bootstrap { color: var(--color-text-faint); background: var(--color-bg-hover); padding: 1px 6px; border-radius: 3px; font-size: var(--font-sm); }

      .text-error { color: var(--color-error); }
      .text-success { color: var(--color-success); }
      .text-warning { color: var(--color-warning); }
      .text-muted { color: var(--color-text-muted); }
      .text-faint { color: var(--color-text-faint); }

      /* =============================================================================
         METADATA (timestamps, trace IDs, etc)
         ============================================================================= */
      .trace-age {
        font-size: var(--font-sm);
        color: var(--color-text-faint);
      }

      .trace-meta {
        font-size: var(--font-sm);
        color: var(--color-text-subtle);
      }

      .timeline-table {
        font-size: var(--font-sm);
        color: var(--color-text);
        border-collapse: collapse;
        margin-bottom: var(--space-4);
      }
      .timeline-table th, .timeline-table td {
        padding: var(--space-1) var(--space-3);
        text-align: left;
      }
      .timeline-table th {
        font-weight: 500;
        border-bottom: 1px solid var(--color-border);
      }
      .timeline-table .text-right {
        text-align: right;
      }
      .timeline-table .timeline-total {
        border-top: 1px solid var(--color-border);
      }

      .meta-inline {
        font-size: var(--font-sm);
        color: var(--color-text-subtle);
        margin-left: var(--space-3);
      }

      /* =============================================================================
         DIFF DISPLAY
         ============================================================================= */
      .diff-added { color: var(--color-success); font-weight: 500; }
      .diff-removed { color: var(--color-error); font-weight: 500; }
      .diff-modified { color: var(--color-warning); font-weight: 500; }
      .diff-item { margin-left: var(--space-5); }
      .diff-count { color: var(--color-text-muted); margin-bottom: var(--space-1); }

      /* =============================================================================
         DETAILS/EXPANDERS
         ============================================================================= */
      details { margin: var(--space-3) 0; }
      details > summary {
        cursor: pointer;
        font-size: var(--font-md);
        color: var(--color-text-faint);
      }
      details > summary:hover { color: var(--color-text-muted); }

      details pre {
        margin: var(--space-2) 0 0;
        padding: var(--space-3);
        background: var(--color-bg-subtle);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
        white-space: pre-wrap;
        font-size: var(--font-sm);
        color: var(--color-text-muted);
        overflow-x: auto;
      }

      .stack-trace {
        font-size: var(--font-sm);
        color: var(--color-text-muted);
        overflow-x: auto;
      }

      /* =============================================================================
         SOURCE CODE DISPLAY
         ============================================================================= */
      .source-code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: var(--font-sm);
        background: var(--color-bg-subtle);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-sm);
        padding: var(--space-3);
        margin: var(--space-2) 0;
        overflow-x: auto;
        white-space: pre-wrap;
        color: var(--color-text);
      }

      .api-body {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: var(--font-sm);
        background: var(--color-bg-subtle);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-sm);
        padding: var(--space-3);
        margin: var(--space-2) 0;
        overflow-x: auto;
        white-space: pre-wrap;
        color: var(--color-text);
      }

      .body-expression {
        font-size: var(--font-sm);
        color: var(--color-text-muted);
        margin: var(--space-1) 0;
        padding-left: var(--space-4);
      }

      .body-expression code {
        background: var(--color-bg-subtle);
        padding: 2px 6px;
        border-radius: var(--radius-sm);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      }

      .api-pair-link {
        font-size: var(--font-sm);
        color: var(--color-link);
        text-decoration: none;
        margin-left: var(--space-2);
        opacity: 0.8;
      }
      .api-pair-link:hover {
        opacity: 1;
        text-decoration: underline;
      }

      /* Anchor elements for API event linking */
      .api-anchor {
        display: block;
        position: relative;
        top: -60px; /* offset for sticky toolbar */
        visibility: hidden;
      }

      /* Highlight target when jumping via link */
      .trace-event.jump-target {
        animation: highlight-flash 1.5s ease-out;
      }
      @keyframes highlight-flash {
        0% { background-color: rgba(59, 130, 246, 0.3); }
        100% { background-color: transparent; }
      }

      .highlight-line {
        display: block;
        background: rgba(255, 200, 0, 0.2);
        border-left: 3px solid #f0a000;
        margin-left: -8px;
        padding-left: 5px;
        font-weight: 500;
      }

      .event-metadata {
        margin: var(--space-2) 0;
      }
      .event-metadata details {
        margin: var(--space-1) 0;
      }
      .event-metadata summary {
        font-size: var(--font-sm);
        color: var(--color-text-muted);
        cursor: pointer;
      }
      .event-metadata summary:hover {
        color: var(--color-text);
      }
      .metadata-grid {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: var(--space-1) var(--space-3);
        font-size: var(--font-sm);
        padding: var(--space-2);
        background: var(--color-bg-subtle);
        border-radius: var(--radius-sm);
        margin-top: var(--space-1);
      }
      .metadata-grid dt {
        color: var(--color-text-muted);
        font-weight: 500;
      }
      .metadata-grid dd {
        margin: 0;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        color: var(--color-text);
      }

      /* =============================================================================
         COLLAPSIBLE SECTIONS (Notes, Files)
         ============================================================================= */
      .collapsible-section {
        margin-top: var(--space-4);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
        background: var(--color-bg-subtle);
      }
      .collapsible-section summary {
        padding: var(--space-2) var(--space-3);
        font-size: var(--font-lg);
        font-weight: 500;
        color: var(--color-text-muted);
        cursor: pointer;
        user-select: none;
      }
      .collapsible-section summary:hover {
        background: var(--color-bg-hover);
      }
      .collapsible-section[open] summary {
        border-bottom: 1px solid var(--color-border);
      }
      .collapsible-content {
        padding: var(--space-3);
        font-size: var(--font-md);
        color: var(--color-text-muted);
      }

      /* Notes section specifics */
      .notes-list {
        margin: 0;
        padding-left: 18px;
      }
      .notes-list li { margin: var(--space-2) 0; }
      .note-title { font-weight: 500; margin-bottom: var(--space-1); }
      .note-description { font-size: var(--font-md); margin-bottom: var(--space-2); }
    .note-items { font-size: var(--font-md); }
      .note-item { margin: 2px 0; }
      .note-key { font-weight: 500; margin: var(--space-1) 0; }

      /* Source files specifics */
      .source-file {
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        margin: var(--space-1) 0;
      }

      /* =============================================================================
         SECTION HEADERS
         ============================================================================= */
      .section-header {
        margin: var(--space-5) 0 var(--space-3);
        font-size: var(--font-base);
        color: var(--color-text-muted);
        font-weight: 500;
      }

      /* =============================================================================
         FILE PREVIEW MODAL
         ============================================================================= */
      .file-link {
        color: var(--color-info);
        cursor: pointer;
        text-decoration: underline;
        text-decoration-style: dotted;
      }
      .file-link:hover {
        text-decoration-style: solid;
        color: #3730a3;
      }
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      .modal-overlay.open {
        display: flex;
      }
      .modal-content {
        background: var(--color-bg);
        border-radius: var(--radius-lg);
        max-width: 90vw;
        max-height: 90vh;
        width: 900px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      }
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--space-3) var(--space-4);
        border-bottom: 1px solid var(--color-border);
        font-weight: 500;
      }
      .modal-header .file-path {
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: var(--font-sm);
        color: var(--color-text-muted);
      }
      .modal-close {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        padding: 4px 8px;
        color: var(--color-text-muted);
      }
      .modal-close:hover {
        color: var(--color-text);
      }
      .modal-body {
        flex: 1;
        overflow: auto;
        padding: 0;
      }
      .modal-body pre {
        margin: 0;
        padding: var(--space-4);
        font-size: var(--font-sm);
        line-height: 1.5;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      /* =============================================================================
         TEST RESULTS STYLES
         ============================================================================= */
      .test-results {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: var(--font-sm);
        padding: var(--space-4);
      }
      .test-results h2 {
        font-size: var(--font-lg);
        margin: 0 0 var(--space-4) 0;
        padding-bottom: var(--space-2);
        border-bottom: 1px solid var(--color-border);
      }
      .test-suite {
        margin: var(--space-4) 0;
        border: 1px solid var(--color-border);
        border-radius: var(--radius-md);
        overflow: hidden;
      }
      .test-suite-header {
        background: var(--color-bg-subtle);
        padding: var(--space-2) var(--space-3);
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: var(--space-2);
      }
      .test-suite-header:hover { background: var(--color-bg-hover); }
      .test-suite-body {
        display: none;
        padding: var(--space-2);
        border-top: 1px solid var(--color-border);
      }
      .test-suite.expanded .test-suite-body { display: block; }
      .test-case {
        padding: var(--space-1) var(--space-2);
        margin: var(--space-1) 0;
        border-radius: var(--radius-sm);
        display: flex;
        align-items: flex-start;
        gap: var(--space-2);
      }
      .test-case.pass { background: rgba(5, 150, 105, 0.1); }
      .test-case.fail { background: rgba(220, 38, 38, 0.1); }
      .test-icon { flex-shrink: 0; }
      .test-icon.pass { color: var(--color-success); }
      .test-icon.fail { color: var(--color-error); }
      .test-name { flex: 1; }
      .test-error {
        margin-top: var(--space-1);
        padding: var(--space-2);
        background: rgba(220, 38, 38, 0.05);
        border-radius: var(--radius-sm);
        color: var(--color-error);
        font-size: var(--font-xs);
        white-space: pre-wrap;
      }
      .test-summary {
        margin-top: var(--space-4);
        padding: var(--space-3);
        border-radius: var(--radius-md);
        font-weight: 500;
      }
      .test-summary.all-pass {
        background: rgba(5, 150, 105, 0.15);
        color: var(--color-success);
      }
      .test-summary.has-failures {
        background: rgba(220, 38, 38, 0.15);
        color: var(--color-error);
      }
      .test-details {
        margin-top: var(--space-2);
        padding: var(--space-2);
        background: var(--color-bg-subtle);
        border-radius: var(--radius-sm);
        font-size: var(--font-xs);
        max-height: 200px;
        overflow: auto;
      }

      /* =============================================================================
         HELP ICON AND MODAL
         ============================================================================= */
      .help-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 14px;
        height: 14px;
        font-size: 10px;
        font-weight: 600;
        color: var(--color-text-subtle);
        background: var(--color-bg-hover);
        border: 1px solid var(--color-border);
        border-radius: 50%;
        cursor: pointer;
        margin-left: 4px;
        vertical-align: middle;
        line-height: 1;
      }
      .help-icon:hover {
        color: var(--color-info);
        border-color: var(--color-info);
        background: #eef2ff;
      }

      .help-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      .help-modal.visible { display: flex; }

      .help-modal-content {
        background: var(--color-bg);
        border-radius: var(--radius-lg);
        padding: var(--space-5);
        max-width: 450px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        position: relative;
      }

      .help-modal-close {
        position: absolute;
        top: 8px;
        right: 12px;
        font-size: 18px;
        color: var(--color-text-muted);
        cursor: pointer;
        background: none;
        border: none;
        padding: 0;
      }
      .help-modal-close:hover { color: var(--color-text); }

      .help-modal h3 {
        margin: 0 0 var(--space-3) 0;
        font-size: var(--font-lg);
      }

      .help-modal p {
        margin: 0 0 var(--space-3) 0;
        font-size: var(--font-base);
        color: var(--color-text-muted);
      }

      .help-modal dl {
        margin: 0;
        font-size: var(--font-base);
      }

      .help-modal dt {
        font-weight: 600;
        color: var(--color-text);
        margin-top: var(--space-2);
      }
      .help-modal dt:first-child { margin-top: 0; }

      .help-modal dd {
        margin: 2px 0 0 0;
        color: var(--color-text-muted);
      }

      .help-modal code {
        background: var(--color-bg-subtle);
        padding: 1px 4px;
        border-radius: 3px;
        font-size: var(--font-sm);
      }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <label>View:</label>
      <label><input type="radio" name="viewMode" id="viewPretty" checked /> pretty</label>
      <label><input type="radio" name="viewMode" id="viewRaw" /> raw</label>
      <span class="spacer"></span>
      <input type="text" id="searchInput" placeholder="Search..." style="width: 200px;" />
      <button id="searchPrev" title="Previous match">▲</button>
      <button id="searchNext" title="Next match">▼</button>
      <span id="searchCount" style="font-size: var(--font-sm); color: var(--color-text-muted); min-width: 60px;"></span>
      <span class="spacer"></span>
      <button id="clear">Clear</button>
      <button id="test">Test</button>
      <span class="spacer"></span>
      <select id="exportFormat">
        <option value="">Export...</option>
        <option value="html">Download HTML</option>
        <option value="md">Download Markdown</option>
        <option value="json">Download JSON (for Playwright)</option>
      </select>
    </div>
    <div id="diff"></div>

    <!-- File Preview Modal -->
    <div id="fileModal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <span class="file-path" id="modalFilePath"></span>
          <button class="modal-close" id="modalClose">&times;</button>
        </div>
        <div class="modal-body">
          <pre id="modalFileContent">Loading...</pre>
        </div>
      </div>
    </div>

    <script type="module">
      import * as jsondiffpatch from "https://unpkg.com/jsondiffpatch@0.7.3/lib/index.js";
      import * as htmlFormatter from "https://unpkg.com/jsondiffpatch@0.7.3/lib/formatters/html.js";
      import { XmluiSource } from "./xmlui-parser.es.js";

      // =============================================================================
      // LOCALSTORAGE PERSISTENCE - Survive server restarts
      // =============================================================================

      const STORAGE_KEY = "xmlui-inspector-history";
      const MAX_STORED_ENTRIES = 5000; // Limit to prevent localStorage overflow

      function getStoredEntries() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          return stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load inspector history from localStorage:", e);
          return [];
        }
      }

      function saveEntriesToStorage(entries) {
        try {
          // Keep only the most recent entries and strip large fields for localStorage.
          // Preserve all fields on interaction and API events — they're critical for
          // Playwright test generation and semantic trace comparison.
          const criticalKinds = new Set(["interaction", "navigate", "api:start", "api:complete", "api:error"]);
          const toStore = entries.slice(-500).map(e => {
            if (criticalKinds.has(e.kind)) return e;
            const { text, diffPretty, diffJson, eventArgs, ...rest } = e;
            return rest;
          });
          localStorage.setItem(STORAGE_KEY, JSON.stringify(toStore));
        } catch (e) {
          // Silently fail - localStorage is optional, export to JSON still works
        }
      }

      function clearStoredEntries() {
        try {
          localStorage.removeItem(STORAGE_KEY);
        } catch (e) {
          console.warn("Failed to clear inspector history from localStorage:", e);
        }
      }

      // Track entries we've already stored to avoid duplicates
      let lastStoredCount = 0;

      // =============================================================================
      // THEME SYNC - Bridge XMLUI theme to inspector
      // =============================================================================

      /**
       * Syncs XMLUI theme variables from the parent window to this iframe.
       * Tries multiple naming patterns since XMLUI may use prefixes like "xmlui-" and "const-".
       */
      function syncThemeFromParent() {
        try {
          if (!window.parent || window.parent === window) return;

          const parentStyles = window.parent.getComputedStyle(window.parent.document.documentElement);
          const root = document.documentElement;

          // XMLUI uses variable names like:
          //   --const-color-surface-50  or  --xmlui-const-color-surface-50
          // We need to try multiple prefixes to find the actual variables.
          const prefixes = ['', 'xmlui-'];

          // Helper to get a variable trying all prefix combinations
          function getVar(baseName) {
            for (const prefix of prefixes) {
              // Try with "const-" prefix (XMLUI's internal naming)
              let value = parentStyles.getPropertyValue(`--${prefix}const-${baseName}`).trim();
              if (value) return value;
              // Try without "const-" prefix
              value = parentStyles.getPropertyValue(`--${prefix}${baseName}`).trim();
              if (value) return value;
            }
            return '';
          }

          // Map inspector variables to XMLUI base names (without prefix)
          const themeMap = {
            // Text colors - use surface colors since XMLUI uses surface for text contrast
            '--color-text': ['color-surface-950'],
            '--color-text-muted': ['color-surface-600'],
            '--color-text-faint': ['color-surface-500'],
            '--color-text-subtle': ['color-surface-400'],

            // Background colors
            '--color-bg': ['color-surface-50'],
            '--color-bg-subtle': ['color-surface-100'],
            '--color-bg-muted': ['color-surface-100'],
            '--color-bg-hover': ['color-surface-200'],

            // Border
            '--color-border': ['color-surface-300'],

            // Semantic colors
            '--color-error': ['color-danger-500', 'color-danger'],
            '--color-success': ['color-success-500', 'color-success'],
            '--color-warning': ['color-warn-500', 'color-warn'],
            '--color-info': ['color-info-500', 'color-info', 'color-primary-500'],

            // Interaction colors (for trace highlighting)
            '--color-interaction-border': ['color-primary-300'],
            '--color-interaction-bg': ['color-primary-50', 'color-primary-100'],
          };

          let appliedCount = 0;

          for (const [localVar, baseNames] of Object.entries(themeMap)) {
            for (const baseName of baseNames) {
              const value = getVar(baseName);
              if (value) {
                root.style.setProperty(localVar, value);
                appliedCount++;
                break; // Use first matching variable
              }
            }
          }

          if (appliedCount > 0 && !window._inspectorThemeSynced) {
            console.debug(`[Inspector] Synced ${appliedCount} theme variables from parent`);
            window._inspectorThemeSynced = true;
          } else if (appliedCount === 0) {
            // Debug: log what variables ARE available
            console.log('[Inspector] No theme variables found. Looking for debug info...');
            // Try to find any CSS variable with "color" in the name
            const sampleVars = ['--const-color-surface-50', '--xmlui-const-color-surface-50', '--color-surface-50'];
            sampleVars.forEach(v => {
              const val = parentStyles.getPropertyValue(v);
              if (val) console.log(`  Found: ${v} = ${val}`);
            });
          }
        } catch (e) {
          // Cross-origin or no parent - use defaults
          console.log('[Inspector] Using default theme (parent not accessible)', e.message);
        }
      }

      // Sync theme on load and watch for changes
      syncThemeFromParent();

      // Re-sync periodically in case theme changes (e.g., dark mode toggle)
      setInterval(syncThemeFromParent, 2000);

      // =============================================================================
      // UTILITY FUNCTIONS
      // =============================================================================

      function isIndexSegment(seg) {
        return String(seg).match(/^\d+$/);
      }

      function setByPath(root, path, value) {
        const parts = String(path || "").split(".");
        let cur = root;
        let parent = null;
        let parentKey = null;
        for (let i = 0; i < parts.length; i++) {
          const key = parts[i];
          const isLast = i === parts.length - 1;
          const idx = isIndexSegment(key) ? Number(key) : null;
          if (isLast) {
            if (idx !== null) {
              if (!Array.isArray(cur)) {
                const newArr = [];
                if (parent) parent[parentKey] = newArr;
                cur = newArr;
              }
              cur[idx] = value;
            } else {
              cur[key] = value;
            }
          } else {
            if (idx !== null) {
              if (!Array.isArray(cur)) {
                const newArr = [];
                if (parent) parent[parentKey] = newArr;
                cur = newArr;
              }
              if (!cur[idx]) cur[idx] = {};
              parent = cur;
              parentKey = idx;
              cur = cur[idx];
            } else {
              if (!cur[key]) cur[key] = {};
              parent = cur;
              parentKey = key;
              cur = cur[key];
            }
          }
        }
      }

      // Clean up eventArgs to extract useful data and remove DOM/React noise
      function cleanEventArgs(args) {
        if (!args || !Array.isArray(args)) return args;
        return args.map(arg => {
          if (!arg || typeof arg !== "object") return arg;
          // React SyntheticEvent - extract useful parts
          if (arg.nativeEvent || arg._reactName || arg.type === "click" || arg.type === "contextmenu") {
            const cleaned = { _event: arg.type || "event" };
            if (arg.target?.id) cleaned.targetId = arg.target.id;
            if (arg.target?.textContent) cleaned.targetText = arg.target.textContent.substring(0, 50);
            if (arg.clientX !== undefined) cleaned.position = { x: arg.clientX, y: arg.clientY };
            return cleaned;
          }
          // Skip React internal objects
          if (arg.$$typeof) return "[React element]";
          // Return as-is for regular objects (message payloads, tree nodes, etc.)
          return arg;
        });
      }

      // Safe JSON stringify that handles circular references and DOM objects
      function safeStringify(obj, indent = null, maxLength = 10000, maxArrayLength = 100) {
        try {
          const seen = new WeakSet();
          let length = 0;
          const result = JSON.stringify(obj, (key, value) => {
            // Bail out if getting too large
            if (maxLength !== Infinity && length > maxLength) return "[truncated]";
            length += key.length + 10;
            // Skip DOM nodes and Window
            if (value instanceof Node || value instanceof Window) {
              return `[${value.constructor.name}]`;
            }
            // Handle circular references
            if (typeof value === "object" && value !== null) {
              if (seen.has(value)) return "[circular]";
              seen.add(value);
              // Limit array length (skip if maxArrayLength is Infinity)
              if (maxArrayLength !== Infinity && Array.isArray(value) && value.length > maxArrayLength) {
                return [...value.slice(0, maxArrayLength), `[...${value.length - maxArrayLength} more items]`];
              }
            }
            // Handle functions
            if (typeof value === "function") {
              return `[function ${value.name || "anonymous"}]`;
            }
            // Truncate long strings (skip if maxLength is very large)
            if (maxLength < 100000 && typeof value === "string" && value.length > 500) {
              return value.substring(0, 500) + "...";
            }
            return value;
          }, indent);
          return maxLength !== Infinity && result && result.length > maxLength ? result.substring(0, maxLength) + "..." : result;
        } catch (err) {
          return `[stringify error: ${err.message}]`;
        }
      }

      // Convert functions to their source code for display (jsondiffpatch can't handle function objects)
      // Multi-line functions are wrapped with markers for later conversion to <details> dropdowns
      function stripFunctions(obj, seen = new WeakSet()) {
        if (obj === null || typeof obj !== "object") return obj;
        if (typeof obj === "function") {
          const src = obj.toString();
          // Wrap multi-line functions with markers for dropdown display
          return src.includes("\n") ? `__FN__${src}__/FN__` : src;
        }
        if (seen.has(obj)) return "[circular]";
        seen.add(obj);
        if (Array.isArray(obj)) {
          return obj.map(item => stripFunctions(item, seen));
        }
        const result = {};
        for (const key of Object.keys(obj)) {
          const val = obj[key];
          if (typeof val === "function") {
            const src = val.toString();
            // Wrap multi-line functions with markers for dropdown display
            result[key] = src.includes("\n") ? `__FN__${src}__/FN__` : src;
          } else {
            result[key] = stripFunctions(val, seen);
          }
        }
        return result;
      }

      function buildSnapshotsFromDiff(diffArray) {
        const left = {};
        const right = {};
        diffArray.forEach((d) => {
          if (!d || !d.path) return;
          const beforeVal = d.before === undefined ? null : stripFunctions(d.before);
          const afterVal = d.after === undefined ? null : stripFunctions(d.after);
          setByPath(left, d.path, beforeVal);
          setByPath(right, d.path, afterVal);
        });
        return { left, right };
      }

      function getItemKey(item) {
        if (!item || typeof item !== "object") return null;
        return item.id || item.path || item.name || null;
      }

      function getItemLabel(item) {
        if (!item || typeof item !== "object") return String(item);
        const name = item.name || item.title || item.label || item.id || item.path;
        if (!name) return JSON.stringify(item).slice(0, 60);
        if (item.size !== undefined) {
          const sizeStr = formatFileSize(item.size);
          return `${name} (${sizeStr})`;
        }
        return name;
      }

      function formatFileSize(bytes) {
        if (bytes === 0) return "0 B";
        const k = 1024;
        const sizes = ["B", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
      }

      function isKeyedArray(arr) {
        if (!Array.isArray(arr) || arr.length === 0) return false;
        const keyedCount = arr.filter((item) => getItemKey(item) !== null).length;
        return keyedCount / arr.length > 0.5;
      }

      function analyzeArrayDiff(before, after) {
        const beforeArr = Array.isArray(before) ? before : [];
        const afterArr = Array.isArray(after) ? after : [];
        const beforeMap = new Map();
        const afterMap = new Map();

        beforeArr.forEach((item, idx) => {
          const key = getItemKey(item) || `#${idx}`;
          beforeMap.set(key, item);
        });
        afterArr.forEach((item, idx) => {
          const key = getItemKey(item) || `#${idx}`;
          afterMap.set(key, item);
        });

        const added = [];
        const removed = [];
        const changed = [];

        for (const [key, beforeItem] of beforeMap.entries()) {
          if (!afterMap.has(key)) {
            removed.push({ key, item: beforeItem, label: getItemLabel(beforeItem) });
          } else {
            const afterItem = afterMap.get(key);
            try {
              const b = JSON.stringify(beforeItem);
              const a = JSON.stringify(afterItem);
              if (b !== a) {
                changed.push({ key, before: beforeItem, after: afterItem, label: getItemLabel(afterItem) });
              }
            } catch {
              changed.push({ key, before: beforeItem, after: afterItem, label: getItemLabel(afterItem) });
            }
          }
        }
        for (const [key, afterItem] of afterMap.entries()) {
          if (!beforeMap.has(key)) {
            added.push({ key, item: afterItem, label: getItemLabel(afterItem) });
          }
        }

        return {
          added, removed, changed,
          beforeCount: beforeArr.length,
          afterCount: afterArr.length,
          isSignificant: added.length > 0 || removed.length > 0 || changed.length > 0,
        };
      }

      function renderArrayDiffSummary(analysis) {
        const { added, removed, changed, beforeCount, afterCount } = analysis;
        const lines = [];

        if (beforeCount !== afterCount) {
          lines.push(`<div class="diff-count">${beforeCount} → ${afterCount} items</div>`);
        }

        const renderItems = (items, icon, cssClass) => {
          if (items.length === 0) return "";
          const limit = 5;
          const shown = items.slice(0, limit);
          const remaining = items.length - limit;
          let html = shown.map((i) => `<div class="diff-item ${cssClass}">${icon} ${i.label}</div>`).join("");
          if (remaining > 0) {
            html += `<div class="diff-item text-faint">… and ${remaining} more</div>`;
          }
          return html;
        };

        // Render field-level changes for modified items
        const renderChangedItems = (items) => {
          if (items.length === 0) return "";
          const limit = 3; // Show details for up to 3 modified items
          const shown = items.slice(0, limit);
          const remaining = items.length - limit;

          let html = shown.map((i) => {
            let itemHtml = `<div class="diff-item text-warning">~ ${i.label}</div>`;
            // Show what fields changed
            if (i.before && i.after) {
              const fieldChanges = [];
              const allKeys = new Set([...Object.keys(i.before), ...Object.keys(i.after)]);
              for (const key of allKeys) {
                const bVal = i.before[key];
                const aVal = i.after[key];
                // Skip unchanged fields and complex nested objects
                if (JSON.stringify(bVal) === JSON.stringify(aVal)) continue;
                if (typeof bVal === 'object' && bVal !== null && !Array.isArray(bVal)) continue;
                if (typeof aVal === 'object' && aVal !== null && !Array.isArray(aVal)) continue;

                // Format the change
                const formatVal = (v) => {
                  if (v === undefined) return 'undefined';
                  if (v === null) return 'null';
                  if (typeof v === 'boolean') return v ? 'true' : 'false';
                  if (typeof v === 'string' && v.length > 20) return `"${v.substring(0, 20)}..."`;
                  if (typeof v === 'string') return `"${v}"`;
                  return String(v);
                };
                fieldChanges.push(`<span class="field-change">${key}: <span class="text-error">${formatVal(bVal)}</span> → <span class="text-success">${formatVal(aVal)}</span></span>`);
              }
              if (fieldChanges.length > 0 && fieldChanges.length <= 5) {
                itemHtml += `<div class="diff-field-changes" style="margin-left: 16px; font-size: var(--font-sm);">${fieldChanges.join('<br>')}</div>`;
              }
            }
            return itemHtml;
          }).join("");

          if (remaining > 0) {
            html += `<div class="diff-item text-faint">… and ${remaining} more</div>`;
          }
          return html;
        };

        if (added.length > 0) {
          lines.push(`<div class="diff-added">+${added.length} added</div>`);
          lines.push(renderItems(added, "+", "text-success"));
        }
        if (removed.length > 0) {
          lines.push(`<div class="diff-removed">−${removed.length} removed</div>`);
          lines.push(renderItems(removed, "−", "text-error"));
        }
        if (changed.length > 0) {
          lines.push(`<div class="diff-modified">~${changed.length} modified</div>`);
          lines.push(renderChangedItems(changed));
        }

        return lines.join("");
      }

      function summarizeArrayDiff(before, after) {
        const analysis = analyzeArrayDiff(before, after);
        const lines = [];
        if (analysis.beforeCount !== analysis.afterCount) {
          lines.push(`${analysis.beforeCount} → ${analysis.afterCount} items`);
        }
        if (analysis.added.length > 0) {
          lines.push(`+${analysis.added.length} added: ${analysis.added.map((i) => i.label).join(", ")}`);
        }
        if (analysis.removed.length > 0) {
          lines.push(`−${analysis.removed.length} removed: ${analysis.removed.map((i) => i.label).join(", ")}`);
        }
        if (analysis.changed.length > 0) {
          lines.push(`~${analysis.changed.length} modified: ${analysis.changed.map((i) => i.label).join(", ")}`);
          // Show field-level changes for modified items (up to 3)
          const formatVal = (v) => {
            if (v === undefined) return 'undefined';
            if (v === null) return 'null';
            if (typeof v === 'boolean') return v ? 'true' : 'false';
            if (typeof v === 'string' && v.length > 20) return `"${v.substring(0, 20)}..."`;
            if (typeof v === 'string') return `"${v}"`;
            return String(v);
          };
          analysis.changed.slice(0, 3).forEach(item => {
            if (item.before && item.after) {
              const allKeys = new Set([...Object.keys(item.before), ...Object.keys(item.after)]);
              for (const key of allKeys) {
                const bVal = item.before[key];
                const aVal = item.after[key];
                if (JSON.stringify(bVal) === JSON.stringify(aVal)) continue;
                if (typeof bVal === 'object' && bVal !== null && !Array.isArray(bVal)) continue;
                if (typeof aVal === 'object' && aVal !== null && !Array.isArray(aVal)) continue;
                lines.push(`    ${item.label}.${key}: ${formatVal(bVal)} → ${formatVal(aVal)}`);
              }
            }
          });
        }
        return lines.join("\n");
      }

      function formatAge(ts) {
        if (!ts) return "";
        const deltaMs = Date.now() - ts;
        if (deltaMs < 10000) return `${deltaMs}ms ago`;
        const sec = Math.max(0, Math.floor(deltaMs / 1000));
        if (sec < 60) return `${sec}s ago`;
        const min = Math.floor(sec / 60);
        const remSec = sec % 60;
        return `${min}m ${remSec}s ago`;
      }

      // Fetch and cache source file contents
      const sourceCache = new Map();
      async function fetchSourceRange(filePath, startChar, endChar) {
        if (!filePath) return null;
        try {
          let content = sourceCache.get(filePath);
          if (!content) {
            const resp = await fetch(filePath);
            if (!resp.ok) return null;
            content = await resp.text();
            // Validate content isn't HTML (SPA fallback returns index.html for missing files)
            const trimmed = content.trimStart().toLowerCase();
            if (trimmed.startsWith('<!doctype') || trimmed.startsWith('<html')) {
              return null;
            }
            sourceCache.set(filePath, content);
          }
          return content.slice(startChar, endChar);
        } catch (e) {
          console.warn("Failed to fetch source:", filePath, e);
          return null;
        }
      }

      // Load source into a details element when expanded
      function setupSourceLoader(detailsEl, filePath, startChar, endChar) {
        let loaded = false;
        detailsEl.addEventListener("toggle", async () => {
          if (detailsEl.open && !loaded) {
            loaded = true;
            const codeEl = detailsEl.querySelector(".source-code");
            if (codeEl) {
              codeEl.textContent = "Loading...";
              const source = await fetchSourceRange(filePath, startChar, endChar);
              codeEl.textContent = source || "Could not load source";
            }
          }
        });
      }

      // Load file and search for handler attribute in .xmlui, and function in .xs
      function setupHandlerSourceLoader(detailsEl, filePath, handlerName, componentLabel) {
        let loaded = false;
        detailsEl.addEventListener("toggle", async () => {
          if (detailsEl.open && !loaded) {
            loaded = true;
            const codeEl = detailsEl.querySelector(".source-code");
            if (codeEl) {
              codeEl.textContent = "Loading...";
              try {
                const outputSections = [];
                let handlerValue = null; // The function name from the handler attribute

                // Helper to find specific handler attribute in .xmlui (uses XMLUI parser)
                function findHandlerInXmlui(source, eventName, compLabel) {
                  const lines = source.split("\n");
                  const matches = [];

                  try {
                    const xmlui = new XmluiSource(source, filePath);

                    if (compLabel) {
                      // Find specific handler on specific element
                      const handler = xmlui.findHandler(compLabel, eventName);
                      if (handler) {
                        matches.push({ lineNum: handler.line - 1, pattern: "handler-attr" }); // 0-indexed for formatMatches
                        if (!handlerValue) handlerValue = handler.value;
                      }
                    } else {
                      // Find all handlers matching eventName
                      const handlers = xmlui.findHandlers(eventName);
                      for (const h of handlers) {
                        matches.push({ lineNum: h.line - 1, pattern: "handler-attr" }); // 0-indexed
                        if (!handlerValue) handlerValue = h.value;
                      }
                    }
                  } catch (e) {
                    console.warn("Parser error in findHandlerInXmlui:", e);
                    // Fallback: return empty matches
                  }

                  return { lines, matches };
                }

                // Helper to format matches with context
                function formatMatches(lines, matches) {
                  const contextLines = 2;
                  const outputLines = [];
                  const shownRanges = new Set();

                  for (const match of matches) {
                    const start = Math.max(0, match.lineNum - contextLines);
                    const end = Math.min(lines.length - 1, match.lineNum + contextLines);

                    const rangeKey = `${start}-${end}`;
                    if (shownRanges.has(rangeKey)) continue;
                    shownRanges.add(rangeKey);

                    if (outputLines.length > 0) outputLines.push("");

                    for (let i = start; i <= end; i++) {
                      const prefix = i === match.lineNum ? "→ " : "  ";
                      const lineNum = String(i + 1).padStart(4);
                      outputLines.push(`${prefix}${lineNum}: ${lines[i]}`);
                    }
                  }
                  return outputLines;
                }

                // 1. Search .xmlui file for the specific handler
                const xmluiSource = await fetchSourceRange(filePath, 0, 999999);
                if (xmluiSource) {
                  const result = findHandlerInXmlui(xmluiSource, handlerName, componentLabel);
                  if (result.matches.length > 0) {
                    outputSections.push(`// ${filePath.split("/").pop()} - handler attribute`);
                    outputSections.push(...formatMatches(result.lines, result.matches));
                  }
                }

                // 2. Search for handler in .xs files
                // First try the direct .xs file, then search sibling .xs files in same directory
                const xsFilePath = filePath + ".xs";
                let foundXsFile = null;
                let foundXsSource = null;
                let handlerFunctionMatch = null;

                // Helper to check if source is valid JS (not HTML error page)
                const isValidJs = (src) => src && !src.trim().startsWith("<!") && !src.trim().startsWith("<html");

                // Helper to find specific handler function in .xs source
                const findHandlerFunction = (src, funcName) => {
                  const lines = src.split("\n");
                  const matches = [];
                  // If we have a specific function name, look for it
                  if (funcName) {
                    // Extract just the function name (strip parens, etc)
                    const cleanName = funcName.replace(/\(.*$/, "").trim();
                    const funcPattern = new RegExp(`\\bfunction\\s+${cleanName}\\b`);
                    for (let i = 0; i < lines.length; i++) {
                      if (funcPattern.test(lines[i])) {
                        matches.push({ lineNum: i, type: "function" });
                      }
                    }
                  }
                  return matches;
                };

                // Try direct .xs file first
                const directXsSource = await fetchSourceRange(xsFilePath, 0, 999999);
                if (isValidJs(directXsSource)) {
                  foundXsFile = xsFilePath;
                  foundXsSource = directXsSource;
                } else {
                  // Try to find sibling .xs files by checking common parent files
                  // Extract directory and try FileCatalog.xmlui.xs, Main.xmlui.xs, etc.
                  const pathParts = filePath.split("/");
                  const fileName = pathParts.pop();
                  const dirPath = pathParts.join("/");

                  // Common parent component names to try
                  const siblingNames = ["FileCatalog.xmlui.xs", "Main.xmlui.xs", "App.xmlui.xs"];
                  // Also try the component name without "Header", "Footer", etc.
                  const baseName = fileName.replace(/Header|Footer|Item|Row|Cell/g, "");
                  if (baseName !== fileName) {
                    siblingNames.unshift(baseName + ".xs");
                  }

                  for (const sibling of siblingNames) {
                    const siblingPath = dirPath + "/" + sibling;
                    const siblingSource = await fetchSourceRange(siblingPath, 0, 999999);
                    if (isValidJs(siblingSource)) {
                      foundXsFile = siblingPath;
                      foundXsSource = siblingSource;
                      break;
                    }
                  }
                }

                // Only show .xs section if we found a specific function to display
                if (foundXsSource && handlerValue) {
                  const lines = foundXsSource.split("\n");
                  // Use the handler value (function name) from the xmlui attribute
                  const funcMatches = findHandlerFunction(foundXsSource, handlerValue);

                  if (funcMatches.length > 0) {
                    if (outputSections.length > 0) outputSections.push("");
                    outputSections.push(`// ${foundXsFile.split("/").pop()} - code-behind`);

                    // Show just the matched function with context
                    for (const match of funcMatches) {
                      const start = Math.max(0, match.lineNum - 1);
                      // Find end of function (simple heuristic: next function or 30 lines)
                      let end = match.lineNum + 30;
                      for (let i = match.lineNum + 1; i < lines.length && i < match.lineNum + 50; i++) {
                        if (/^\s*function\s+\w+/.test(lines[i]) || /^}$/.test(lines[i].trim())) {
                          end = i;
                          break;
                        }
                      }
                      end = Math.min(end, lines.length - 1);

                      for (let i = start; i <= end; i++) {
                        const prefix = i === match.lineNum ? "→ " : "  ";
                        const lineNum = String(i + 1).padStart(4);
                        outputSections.push(`${prefix}${lineNum}: ${lines[i]}`);
                      }
                    }
                  }
                  // If no function match found, don't show the .xs section at all
                }

                if (outputSections.length === 0) {
                  // No useful content found
                  codeEl.textContent = "// Source not found";
                } else {
                  codeEl.innerHTML = outputSections.join("\n")
                    .replace(/</g, "&lt;")
                    .replace(/^→ (.*)$/gm, '<span class="highlight-line">→ $1</span>');
                }
              } catch (err) {
                codeEl.textContent = "Error loading source: " + err.message;
              }
            }
          }
        });
      }

      // Load file and search for variable declaration, showing context with highlighting
      function setupVarSourceLoader(detailsEl, filePath, varName) {
        let loaded = false;
        detailsEl.addEventListener("toggle", async () => {
          if (detailsEl.open && !loaded) {
            loaded = true;
            const codeEl = detailsEl.querySelector(".source-code");
            if (codeEl) {
              codeEl.textContent = "Loading...";
              try {
                const varNames = varName.split(",").map(v => v.trim());

                // Helper to search for var declarations in source
                function findVarMatches(source, sourceFile) {
                  const lines = source.split("\n");
                  const matches = [];
                  for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    for (const vn of varNames) {
                      // Check for inline var declaration (in .xmlui files)
                      if (line.includes(`var.${vn}=`) || line.includes(`var.${vn} =`)) {
                        matches.push({ lineNum: i, pattern: "inline", file: sourceFile });
                      }
                      // Check for script var declaration
                      const scriptPatterns = [
                        new RegExp(`\\bvar\\s+${vn}\\b`),
                        new RegExp(`\\blet\\s+${vn}\\b`),
                        new RegExp(`\\bconst\\s+${vn}\\b`),
                      ];
                      for (const pat of scriptPatterns) {
                        if (pat.test(line)) {
                          matches.push({ lineNum: i, pattern: "script", file: sourceFile });
                          break;
                        }
                      }
                    }
                  }
                  return { lines, matches };
                }

                // Helper to format matches with context
                function formatMatches(lines, matches, fileLabel) {
                  const contextLines = 2;
                  const outputLines = [];
                  const shownRanges = new Set();

                  if (fileLabel) {
                    outputLines.push(`// ${fileLabel}`);
                  }

                  for (const match of matches) {
                    const start = Math.max(0, match.lineNum - contextLines);
                    const end = Math.min(lines.length - 1, match.lineNum + contextLines);

                    const rangeKey = `${start}-${end}`;
                    if (shownRanges.has(rangeKey)) continue;
                    shownRanges.add(rangeKey);

                    if (outputLines.length > (fileLabel ? 1 : 0)) outputLines.push("");

                    for (let i = start; i <= end; i++) {
                      const prefix = i === match.lineNum ? "→ " : "  ";
                      const lineNum = String(i + 1).padStart(4);
                      outputLines.push(`${prefix}${lineNum}: ${lines[i]}`);
                    }
                  }
                  return outputLines;
                }

                // First try the .xmlui file
                const xmluiSource = await fetchSourceRange(filePath, 0, 999999);
                let result = xmluiSource ? findVarMatches(xmluiSource, filePath) : { lines: [], matches: [] };

                // If no matches in .xmlui, try the .xs code-behind file
                if (result.matches.length === 0) {
                  const xsFilePath = filePath + ".xs";
                  const xsSource = await fetchSourceRange(xsFilePath, 0, 999999);
                  if (xsSource) {
                    result = findVarMatches(xsSource, xsFilePath);
                    if (result.matches.length > 0) {
                      const outputLines = formatMatches(result.lines, result.matches, xsFilePath.split("/").pop());
                      codeEl.innerHTML = outputLines.join("\n")
                        .replace(/</g, "&lt;")
                        .replace(/^→ (.*)$/gm, '<span class="highlight-line">→ $1</span>');
                      return;
                    }
                  }
                }

                if (result.matches.length === 0) {
                  // No match found in either file - show first 20 lines of xmlui as fallback
                  const lines = xmluiSource ? xmluiSource.split("\n") : [];
                  codeEl.textContent = lines.slice(0, 20).join("\n") + (lines.length > 20 ? "\n..." : "");
                  return;
                }

                // Format matches from .xmlui file
                const outputLines = formatMatches(result.lines, result.matches, null);
                codeEl.innerHTML = outputLines.join("\n")
                  .replace(/</g, "&lt;")
                  .replace(/^→ (.*)$/gm, '<span class="highlight-line">→ $1</span>');
              } catch (err) {
                codeEl.textContent = "Error loading source: " + err.message;
              }
            }
          }
        });
      }

      // Load file and search for Action component definition
      function setupActionSourceLoader(detailsEl, filePath, actionId) {
        let loaded = false;
        detailsEl.addEventListener("toggle", async () => {
          if (detailsEl.open && !loaded) {
            loaded = true;
            const codeEl = detailsEl.querySelector(".source-code");
            if (codeEl) {
              codeEl.textContent = "Loading...";
              try {
                // First try the .xmlui file
                const xmluiSource = await fetchSourceRange(filePath, 0, 999999);
                if (xmluiSource) {
                  const result = findActionInSource(xmluiSource, actionId, filePath.split("/").pop());
                  if (result) {
                    const lines = result.source.split("\n");
                    const formatted = lines.map((line, i) => {
                      const lineNum = String(result.startLine + i).padStart(4, " ");
                      return `${lineNum}: ${line}`;
                    }).join("\n");
                    const typeLabel = result.componentType || "component";
                    codeEl.textContent = `// ${typeLabel} "${actionId}" (from ${result.location})\n${formatted}`;
                    return;
                  }

                  // Only try .xs code-behind file if the .xmlui has codeBehind= attribute
                  if (xmluiSource.includes('codeBehind=')) {
                    const xsFilePath = filePath + ".xs";
                    const xsSource = await fetchSourceRange(xsFilePath, 0, 999999);
                    if (xsSource) {
                      const result = findActionInSource(xsSource, actionId, xsFilePath.split("/").pop());
                      if (result) {
                        const lines = result.source.split("\n");
                        const formatted = lines.map((line, i) => {
                          const lineNum = String(result.startLine + i).padStart(4, " ");
                          return `${lineNum}: ${line}`;
                        }).join("\n");
                        const typeLabel = result.componentType || "component";
                        codeEl.textContent = `// ${typeLabel} "${actionId}" (from ${result.location})\n${formatted}`;
                        return;
                      }
                    }
                  }
                }

                // Not found
                codeEl.textContent = `// Component "${actionId}" not found in:\n` +
                  `//   - ${filePath || "(no source file)"}`;
              } catch (err) {
                codeEl.textContent = "Error loading source: " + err.message;
              }
            }
          }
        });
      }

      // Convert __FN__...__/FN__ markers to collapsible <details> for multi-line function sources
      function wrapFunctionSources(html) {
        // Match the markers in the HTML - they may be HTML-escaped or plain text
        return html.replace(/__FN__([\s\S]*?)__\/FN__/g, (match, source) => {
          // Extract function name for summary (handle regular and arrow functions)
          let funcName = "function";
          const namedMatch = source.match(/^function\s+(\w+)/);
          const arrowMatch = source.match(/^(?:const|let|var)\s+(\w+)\s*=/);
          if (namedMatch) funcName = namedMatch[1];
          else if (arrowMatch) funcName = arrowMatch[1];

          // Escape HTML entities in the source
          const escapedSource = source.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          return `<details class="function-source"><summary><code>${funcName}()</code></summary><pre class="source-code">${escapedSource}</pre></details>`;
        });
      }

      // Wrap diff HTML in expander - open if small, closed if large (or force closed)
      function wrapDiffInExpander(diffHtml, summaryText = "Diff", forceCollapsed = false) {
        // First, convert function source markers to dropdowns
        const processedHtml = wrapFunctionSources(diffHtml);

        if (forceCollapsed) {
          return `<details><summary>${summaryText}</summary><div>${processedHtml}</div></details>`;
        }
        const lineCount = (processedHtml.match(/\n/g) || []).length + 1;
        const isLarge = lineCount > 20;
        const openAttr = isLarge ? "" : " open";
        return `<details${openAttr}><summary>${summaryText}</summary><div>${processedHtml}</div></details>`;
      }

      function sortKey(entry) {
        if (!entry) return 0;
        if (entry.perfTs !== undefined) return entry.perfTs;
        return entry.ts || 0;
      }

      function resolveFileLabel(fileId) {
        if (fileId === undefined || fileId === null) return undefined;
        const root = window.parent && window.parent !== window ? window.parent : window;
        const sources = root._xsSourceFiles || root._xsSources;
        if (!sources) return String(fileId);
        if (Array.isArray(sources)) {
          const idx = typeof fileId === "number" ? fileId : Number(fileId);
          if (Number.isFinite(idx) && sources[idx]) return sources[idx];
        }
        if (sources[fileId]) return String(fileId);
        const asNumber = typeof fileId === "number" ? fileId : Number(fileId);
        if (Number.isFinite(asNumber)) {
          const keys = Object.keys(sources);
          if (keys[asNumber]) return keys[asNumber];
        }
        return String(fileId);
      }

      function getSourceFileList() {
        const root = window.parent && window.parent !== window ? window.parent : window;
        const sources = root._xsSourceFiles || root._xsSources;
        if (!sources) return [];
        if (Array.isArray(sources)) return sources;
        return Object.keys(sources);
      }

      // =============================================================================
      // ENTRY NORMALIZATION & FILTERING
      // =============================================================================

      function normalizeEntry(entry) {
        if (!entry) return null;
        if (typeof entry === "string") {
          return { ts: Date.now(), kind: "log", text: entry };
        }
        if (typeof entry === "object") {
          const findInstanceId = (value, depth = 2) => {
            if (!value || typeof value !== "object" || depth < 0) return undefined;
            if (value.instanceId !== undefined) return value.instanceId;
            if (value.dataSourceInstanceId !== undefined) return value.dataSourceInstanceId;
            const values = Object.values(value);
            for (const v of values) {
              if (v && typeof v === "object") {
                const found = findInstanceId(v, depth - 1);
                if (found !== undefined) return found;
              }
            }
            return undefined;
          };

          const instanceId =
            entry.instanceId ?? findInstanceId(entry.detail) ?? findInstanceId(entry.data) ?? findInstanceId(entry.meta);
          if (instanceId !== undefined) {
            return { ...entry, instanceId };
          }
          return entry;
        }
        return null;
      }

      function getAllEntries() {
        const liveLogs = (window.parent && window.parent._xsLogs) || [];
        const storedEntries = getStoredEntries();

        // Merge stored entries with live logs
        // Use a Map keyed by a unique identifier to dedupe
        const entryMap = new Map();

        // Add stored entries first (older)
        storedEntries.forEach(entry => {
          const key = `${entry.ts || 0}-${entry.kind || ''}-${entry.traceId || ''}`;
          entryMap.set(key, entry);
        });

        // Add live entries (may overwrite stored ones, which is fine)
        const normalizedLive = liveLogs.map(normalizeEntry).filter(e => e && (e.kind || e.text));
        normalizedLive.forEach(entry => {
          const key = `${entry.ts || 0}-${entry.kind || ''}-${entry.traceId || ''}`;
          entryMap.set(key, entry);
        });

        // Save any new entries to localStorage
        const allEntries = Array.from(entryMap.values());
        if (allEntries.length > lastStoredCount) {
          saveEntriesToStorage(allEntries);
          lastStoredCount = allEntries.length;
        }

        return allEntries;
      }

      /**
       * Extract function names from handler code.
       * Looks for:
       *   1. Standalone function calls like: functionName(args)
       *   2. Simple function references like: functionName (when code is just a name)
       * Excludes: method calls (obj.method), built-ins, keywords
       */
      function extractFunctionCalls(code) {
        if (!code) return [];
        const builtIns = new Set([
          'if', 'for', 'while', 'switch', 'catch', 'function', 'return', 'new', 'typeof',
          'console', 'JSON', 'Object', 'Array', 'String', 'Number', 'Boolean',
          'Math', 'Date', 'Promise', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
          'fetch', 'alert', 'confirm', 'prompt', 'parseInt', 'parseFloat', 'isNaN', 'isFinite',
          'encodeURI', 'decodeURI', 'encodeURIComponent', 'decodeURIComponent',
          'eval', 'Function', 'Symbol', 'BigInt', 'Map', 'Set', 'WeakMap', 'WeakSet',
          'Error', 'TypeError', 'ReferenceError', 'SyntaxError', 'RangeError',
          'Proxy', 'Reflect', 'Intl', 'ArrayBuffer', 'DataView',
          'require', 'import', 'export', 'async', 'await',
        ]);
        const funcs = [];

        // Check if the entire code is just a function name reference (e.g., "onTreeSelectionDidChange")
        const trimmed = code.trim();
        if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(trimmed) && !builtIns.has(trimmed)) {
          funcs.push(trimmed);
        }

        // Match standalone function calls: identifier followed by ( but NOT preceded by .
        // Use negative lookbehind to exclude method calls like obj.method()
        const funcCallPattern = /(?<![.\w])([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g;
        let match;
        while ((match = funcCallPattern.exec(code)) !== null) {
          const name = match[1];
          if (!builtIns.has(name) && !funcs.includes(name)) {
            funcs.push(name);
          }
        }
        return funcs;
      }

      /**
       * Extract Action references from code.
       * Looks for patterns like: actionId.execute() or actionId.execute(args)
       * Returns array of action IDs
       */
      function extractActionReferences(code) {
        if (!code) return [];
        const actions = [];
        // Match identifier.execute( pattern - captures the identifier before .execute
        const actionPattern = /([a-zA-Z_$][a-zA-Z0-9_$]*)\.execute\s*\(/g;
        let match;
        while ((match = actionPattern.exec(code)) !== null) {
          const actionId = match[1];
          // Exclude common non-action patterns
          if (!actions.includes(actionId) && actionId !== 'this' && actionId !== 'self') {
            actions.push(actionId);
          }
        }
        return actions;
      }

      /**
       * Try to look up a function source.
       * Checks: 1) _xsFunctions registry, 2) window global, 3) source files
       * Returns { source: string, location: string } or null
       */
      function lookupFunctionSource(funcName) {
        const parentWindow = window.parent || window;

        // 1. Check XMLUI's _xsFunctions registry (if exposed)
        if (parentWindow._xsFunctions && parentWindow._xsFunctions[funcName]) {
          const func = parentWindow._xsFunctions[funcName];
          if (typeof func === 'function') {
            return { source: func.toString(), location: '_xsFunctions' };
          }
          if (typeof func === 'object' && func.source) {
            return { source: func.source, location: func.file || '_xsFunctions' };
          }
        }

        // 2. Check window global
        if (typeof parentWindow[funcName] === 'function') {
          return { source: parentWindow[funcName].toString(), location: `window.${funcName}` };
        }

        return null;
      }

      /**
       * Find a function definition in source code.
       * Searches for common JS function patterns and extracts the full function body.
       * @param {string} source - The source code to search
       * @param {string} funcName - The function name to find
       * @param {string} fileName - The file name for location reporting
       * @returns {{ source: string, location: string, startLine: number } | null}
       */
      function findFunctionInSource(source, funcName, fileName) {
        if (!source || !funcName) return null;
        const lines = source.split("\n");

        // Patterns to match function definitions
        const patterns = [
          new RegExp(`^\\s*function\\s+${funcName}\\s*\\(`),           // function funcName(
          new RegExp(`^\\s*const\\s+${funcName}\\s*=\\s*\\(`),          // const funcName = (
          new RegExp(`^\\s*const\\s+${funcName}\\s*=\\s*function`),     // const funcName = function
          new RegExp(`^\\s*const\\s+${funcName}\\s*=\\s*async`),        // const funcName = async
          new RegExp(`^\\s*let\\s+${funcName}\\s*=\\s*\\(`),            // let funcName = (
          new RegExp(`^\\s*let\\s+${funcName}\\s*=\\s*function`),       // let funcName = function
          new RegExp(`^\\s*var\\s+${funcName}\\s*=\\s*\\(`),            // var funcName = (
          new RegExp(`^\\s*var\\s+${funcName}\\s*=\\s*function`),       // var funcName = function
          new RegExp(`^\\s*async\\s+function\\s+${funcName}\\s*\\(`),   // async function funcName(
          new RegExp(`^\\s*export\\s+function\\s+${funcName}\\s*\\(`),  // export function funcName(
          new RegExp(`^\\s*export\\s+const\\s+${funcName}\\s*=`),       // export const funcName =
        ];

        for (let i = 0; i < lines.length; i++) {
          for (const pattern of patterns) {
            if (pattern.test(lines[i])) {
              // Found it! Extract the function (find closing brace by counting)
              let braceCount = 0;
              let startLine = i;
              let endLine = i;
              let started = false;

              for (let j = i; j < lines.length && j < i + 200; j++) {
                const line = lines[j];
                for (const char of line) {
                  if (char === '{') { braceCount++; started = true; }
                  if (char === '}') braceCount--;
                }
                endLine = j;
                if (started && braceCount === 0) break;
              }

              const funcLines = lines.slice(startLine, endLine + 1);
              return {
                source: funcLines.join("\n"),
                location: `${fileName}:${startLine + 1}`,
                startLine: startLine + 1
              };
            }
          }
        }
        return null;
      }

      /**
       * Find a component definition by id in XMLUI source.
       * Uses the XMLUI parser for robust AST-based lookup.
       * Returns { source: string, location: string, startLine: number, componentType: string } or null
       */
      function findActionInSource(source, actionId, fileName) {
        if (!source || !actionId) return null;

        try {
          const xmlui = new XmluiSource(source, fileName);
          const element = xmlui.findById(actionId);

          if (element) {
            return {
              source: element.source,
              location: `${fileName}:${element.startLine}`,
              startLine: element.startLine,
              componentType: element.tagName
            };
          }
        } catch (e) {
          console.warn("Parser error in findActionInSource:", e);
        }

        return null;
      }

      function entryMatches(entry, textFilter) {
        if (entry.componentLabel === "Inspector" || entry.uid === "Inspector") return false;
        if (entry.detail?.text === "Inspector" || entry.detail?.componentId === "Inspector") return false;
        if (entry.componentType === "vite-error-overlay" || entry.uid === "vite-error-overlay") return false;
        if (entry.componentLabel?.startsWith("vite-") || entry.uid?.startsWith("vite-")) return false;
        // Hide XMLUI Inspector interactions (inspector UI itself)
        if (entry.componentLabel === "XMLUI Inspector" || (entry.componentLabel && entry.componentLabel.includes("Inspector"))) return false;
        // Hide inspector activation events
        const code = entry.code || entry.arrow || entry.handlerCode || "";
        if (code.includes("inspectorDialog.open")) return false;
        if (!textFilter) return true;
        const haystack = `${entry.kind || ""} ${entry.eventName || ""} ${entry.uid || ""} ${entry.text || ""}`.toLowerCase();
        return haystack.includes(textFilter.toLowerCase());
      }

      // =============================================================================
      // DEDUPLICATION HELPERS
      // =============================================================================

      function fingerprintDiff(entry) {
        if (!entry || !Array.isArray(entry.diffJson)) return "";
        const d = entry.diffJson;
        if (d.length === 1) {
          const only = d[0];
          try {
            return JSON.stringify({ path: only.path, before: only.before, after: only.after });
          } catch {
            return `${only.path}`;
          }
        }
        try {
          return JSON.stringify(d);
        } catch {
          return String(d.length);
        }
      }

      function fingerprintStateChange(entry) {
        if (!entry) return "";
        if (entry.diffPretty) return entry.diffPretty;
        if (entry.diffText) return entry.diffText;
        const fp = fingerprintDiff(entry);
        if (fp) return entry.instanceId ? `${entry.instanceId}|${fp}` : fp;
        if (entry.text) return entry.text;
        try {
          const base = JSON.stringify(entry);
          return entry.instanceId ? `${entry.instanceId}|${base}` : base;
        } catch {
          return String(entry.kind || "state:changes");
        }
      }

      /**
       * Normalize HTTP method for display.
       * Handles XMLUI binding expressions like "{$queryParams.new == 'true' ? 'post' : 'put'}"
       * by extracting the actual HTTP methods from the expression.
       */
      function normalizeMethod(method) {
        if (!method) return "GET";
        // If it's a binding expression (starts with {), try to extract HTTP methods
        if (method.startsWith("{") && method.endsWith("}")) {
          // Look for HTTP method names in the expression
          const httpMethods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"];
          const found = [];
          const lowerMethod = method.toLowerCase();
          for (const m of httpMethods) {
            if (lowerMethod.includes(`'${m.toLowerCase()}'`) || lowerMethod.includes(`"${m.toLowerCase()}"`)) {
              found.push(m);
            }
          }
          if (found.length === 1) {
            return found[0];
          } else if (found.length > 1) {
            return found.join("/"); // e.g., "POST/PUT"
          }
          return "request"; // Fallback for unrecognized binding
        }
        return method.toUpperCase();
      }

      /**
       * Normalize URL for display.
       * Handles XMLUI binding expressions by extracting any quoted path segments.
       * E.g., "{(x ? '/foo/' : '/bar/') + id}" becomes "/foo/|/bar/"
       */
      function normalizeUrl(url) {
        if (!url) return "";
        // If it's a binding expression (starts with {), try to extract paths
        if (url.startsWith("{") && url.endsWith("}")) {
          // Look for any quoted path pattern like '/something/' or '/path/to/resource'
          const pathPattern = /['"](\/([\w-]+\/?)+)['"]/g;
          const paths = [];
          let match;
          while ((match = pathPattern.exec(url)) !== null) {
            const path = match[1];
            // Dedupe and skip very short paths
            if (path.length > 1 && !paths.includes(path)) {
              paths.push(path);
            }
          }
          if (paths.length === 1) {
            return paths[0];
          } else if (paths.length > 1) {
            // Show alternatives, e.g., "/users/|/groups/"
            return paths.join("|");
          }
          // Fallback: show truncated expression
          const inner = url.slice(1, -1).trim();
          return inner.length > 30 ? inner.substring(0, 30) + "..." : inner;
        }
        return url;
      }

      function fingerprintApiCall(entry) {
        if (!entry) return "";
        const method = normalizeMethod(entry.method);
        const url = entry.url || "";
        // For api:complete, include response in fingerprint
        if (entry.kind === "api:complete" && entry.response !== undefined) {
          try {
            return `${method}|${url}|${JSON.stringify(entry.response)}`;
          } catch {
            return `${method}|${url}`;
          }
        }
        // For api:start, just method+url
        return `${method}|${url}`;
      }

      function isNoopStateChange(entry) {
        if (!entry || !Array.isArray(entry.diffJson) || entry.diffJson.length !== 1) return false;
        const only = entry.diffJson[0];
        try {
          return JSON.stringify(only.before) === JSON.stringify(only.after);
        } catch {
          return false;
        }
      }

      // Strip HTML tags from a string (for raw text export)
      function stripHtml(str) {
        return str.replace(/<[^>]*>/g, "");
      }

      // =============================================================================
      // COMMON DATA PROCESSING
      // =============================================================================

      function buildEntryMeta(e) {
        const resolvedFile = resolveFileLabel(e.ownerFileId);
        const parts = [];
        if (e.perfTs !== undefined) parts.push(`perfTs ${e.perfTs.toFixed(1)}`);
        if (e.kind === "handler:complete" && e.startPerfTs !== undefined) {
          parts.push(`started ${e.startPerfTs.toFixed(1)}`);
        }
        if (e.instanceId) parts.push(`instance ${e.instanceId}`);
        if (e.dataSourceUrl) parts.push(`url ${e.dataSourceUrl}`);
        if (e.ownerUid) parts.push(`uid ${e.ownerUid}`);
        if (resolvedFile) {
          // Include handler code for highlighting in modal if available
          // Escape both quotes and > to prevent breaking HTML parsing and stripHtml regex
          const highlight = e.handlerCode ? ` data-highlight="${e.handlerCode.replace(/"/g, '&quot;').replace(/>/g, '&gt;')}"` : "";
          parts.push(`file <span class="file-link" data-file="${resolvedFile}"${highlight}>${resolvedFile}</span>`);
        }
        return {
          resolvedFile, parts,
          hasSource: e.ownerSource?.start !== undefined && e.ownerSource?.end !== undefined,
          sourceRange: e.ownerSource ? `${e.ownerSource.start}-${e.ownerSource.end}` : null,
        };
      }

      function buildTraceSummary(traceEntries) {
        const starts = traceEntries.filter((e) => e.kind === "handler:start");
        const error = traceEntries.find((e) => e.kind === "handler:error");
        const stateChanges = traceEntries.filter((e) => e.kind === "state:changes");
        const traceId = traceEntries[0]?.traceId || "";

        // Check if this is a startup trace
        const isStartup = traceId.startsWith("startup-");

        let componentText = "";

        // For startup traces, use "Startup" as the title
        if (isStartup) {
          componentText = "Startup";
        } else if (starts.length > 0) {
          // Prefer handlers that aren't ChangeListener (those are less informative)
          const preferredStart = starts.find((s) => s.componentType !== "ChangeListener") || starts[0];
          const type = preferredStart.componentType || "";
          const label = preferredStart.componentLabel || "";
          const uid = preferredStart.uid || "";
          const event = preferredStart.eventName || "";
          const parts = [];
          if (type) parts.push(type);
          if (label) parts.push(`"${label}"`);
          else if (uid && uid !== event) parts.push(uid);
          if (event) parts.push(event);
          componentText = parts.join(" ");
        } else {
          const interaction = traceEntries.find((e) => e.kind === "interaction");
          if (interaction) {
            const label = interaction.componentLabel || interaction.uid || "Unknown";
            const action = interaction.interaction || interaction.eventName || "";
            const detailTextContent = interaction.detail?.text;
            const hasOnlyTag = /^[a-z]+$/.test(label);
            const contextText = hasOnlyTag && detailTextContent && detailTextContent.length < 40 ? ` "${detailTextContent}"` : "";
            componentText = action ? `${label}${contextText} ${action}` : label + contextText;
          }
        }

        // If still no componentText, try to derive from state changes (e.g. DataSource updates)
        if (!componentText && stateChanges.length > 0) {
          const dsChange = stateChanges.find((e) => e.componentType === "DataSource" || (e.eventName && e.eventName.startsWith("DataSource:")));
          if (dsChange) {
            const dsName = dsChange.eventName || `DataSource:${dsChange.uid || "unknown"}`;
            componentText = dsName;
          } else {
            // Use first state change's eventName if available
            const first = stateChanges[0];
            componentText = first.eventName || first.componentType || "";
          }
        }

        // Check for navigate events
        if (!componentText) {
          const nav = traceEntries.find((e) => e.kind === "navigate");
          if (nav) componentText = "Navigation";
        }

        const changeCount = stateChanges.reduce((acc, e) => acc + (e.diffJson ? e.diffJson.length : 0), 0);
        const handlerNames = starts.map((s) => s.eventName || "unknown");

        // Calculate trace duration from perfTs
        const entriesWithPerfTs = traceEntries.filter((e) => typeof e.perfTs === "number");
        let totalDuration = null;
        if (entriesWithPerfTs.length >= 2) {
          const sorted = entriesWithPerfTs.slice().sort((a, b) => a.perfTs - b.perfTs);
          totalDuration = sorted[sorted.length - 1].perfTs - sorted[0].perfTs;
        }

        // Collect all handler:complete with durations for header display
        const handlerDurations = [];
        traceEntries.forEach((e) => {
          if (e.kind === "handler:complete") {
            const name = e.eventName || "handler";
            const label = e.componentLabel || null;
            const duration = typeof e.duration === "number" ? e.duration : null;
            handlerDurations.push({ name, label, duration });
          }
        });

        // Find expensive parts (handlers and API calls with duration > 10ms) for body breakdown
        const expensiveParts = [];
        traceEntries.forEach((e) => {
          if (e.kind === "handler:complete" && typeof e.duration === "number" && e.duration > 10) {
            const label = e.componentLabel || e.uid || e.eventName || "handler";
            expensiveParts.push({ name: `${label}.${e.eventName || "handler"}`, duration: e.duration, kind: "handler" });
          }
          if (e.kind === "api:complete" && typeof e.duration === "number" && e.duration > 10) {
            const method = normalizeMethod(e.method);
            const urlPath = e.url ? new URL(e.url, "http://x").pathname : "";
            expensiveParts.push({ name: `${method} ${urlPath}`, duration: e.duration, kind: "api" });
          }
          if (e.kind === "app:timing" && typeof e.duration === "number" && e.duration > 0) {
            expensiveParts.push({ name: `app:${e.label || "timing"}`, duration: e.duration, kind: "app" });
          }
        });
        // Sort by duration descending, take top 3
        expensiveParts.sort((a, b) => b.duration - a.duration);
        const topExpensive = expensiveParts.slice(0, 3);

        // Timeline breakdown: analyze where time is spent
        const timelineBreakdown = [];
        let timelineOrder = 0;
        if (entriesWithPerfTs.length >= 2) {
          const sorted = entriesWithPerfTs.slice().sort((a, b) => a.perfTs - b.perfTs);
          const traceStart = sorted[0].perfTs;
          const traceEnd = sorted[sorted.length - 1].perfTs;

          // Build queue of api:start events to calculate duration for api:complete (FIFO for same URLs)
          const apiStartQueues = new Map(); // key -> array of perfTs values
          sorted.forEach(e => {
            if (e.kind === "api:start" && e.url) {
              const key = `${e.method || "GET"}:${e.url}`;
              if (!apiStartQueues.has(key)) apiStartQueues.set(key, []);
              apiStartQueues.get(key).push(e.perfTs);
            }
          });

          // Find first handler:start
          const firstHandlerStart = sorted.find(e => e.kind === "handler:start");
          const firstHandlerTs = firstHandlerStart ? firstHandlerStart.perfTs : traceEnd;

          // Track DataSource completions before first handler (these explain "before handlers" time)
          let lastEventTs = traceStart;
          sorted.forEach(e => {
            // DataSource state:changes before first handler - show where time is going
            if (e.kind === "state:changes" && e.componentType === "DataSource" && e.perfTs < firstHandlerTs) {
              const dsName = e.uid || e.dataSourceId || "DataSource";
              const duration = e.perfTs - lastEventTs;
              if (duration > 100) { // Only show gaps > 100ms
                timelineBreakdown.push({ phase: `DataSource:${dsName}`, duration, perfTs: e.perfTs, order: timelineOrder++ });
              }
              lastEventTs = e.perfTs;
            }
          });

          // Collect all timed activities and detect gaps between handlers
          let lastHandlerEndTime = null;
          let lastHandlerLabel = null;
          let idleCount = 0; // Track number of idle periods for Startup
          sorted.forEach(e => {
            // Detect gaps: time between last handler:complete and this handler:start
            if (e.kind === "handler:start" && lastHandlerEndTime !== null) {
              const gap = e.perfTs - lastHandlerEndTime;
              if (gap > 100) { // Only report gaps > 100ms
                idleCount++;
                timelineBreakdown.push({
                  phase: "idle",
                  duration: gap,
                  order: timelineOrder++
                });
              }
            }

            if (e.kind === "handler:complete") {
              lastHandlerEndTime = e.perfTs;
              lastHandlerLabel = e.componentLabel || e.eventName || "handler";
              if (typeof e.duration === "number" && e.duration > 10) {
                timelineBreakdown.push({ phase: `handler:${lastHandlerLabel}`, duration: e.duration, perfTs: e.perfTs, order: timelineOrder++ });
              }
            }
            if (e.kind === "api:complete") {
              const method = normalizeMethod(e.method);
              const key = `${method}:${e.url}`;
              // Calculate duration from api:start if not already present (FIFO matching)
              let duration = e.duration;
              if (typeof duration !== "number") {
                const queue = apiStartQueues.get(key);
                if (queue && queue.length > 0) {
                  const startTs = queue.shift(); // FIFO - take earliest unmatched start
                  duration = e.perfTs - startTs;
                }
              }
              if (typeof duration === "number" && duration > 10) {
                const urlPath = e.url ? new URL(e.url, "http://x").pathname.split("/").pop() : "";
                timelineBreakdown.push({ phase: `api:${method} ${urlPath}`, duration, perfTs: e.perfTs, order: timelineOrder++ });
              }
            }
            if (e.kind === "app:timing" && typeof e.duration === "number" && e.duration > 0) {
              timelineBreakdown.push({ phase: `app:${e.label || "timing"}`, duration: e.duration, perfTs: e.perfTs, order: timelineOrder++ });
            }
          });

          // Time after last handler:complete
          const lastHandlerComplete = [...sorted].reverse().find(e => e.kind === "handler:complete");
          if (lastHandlerComplete && traceEnd - lastHandlerComplete.perfTs > 10) {
            timelineBreakdown.push({ phase: "after handlers", duration: traceEnd - lastHandlerComplete.perfTs, order: timelineOrder++ });
          }

          // Calculate unaccounted time (framework overhead, rendering, etc.)
          const accountedTime = timelineBreakdown.reduce((sum, item) => sum + item.duration, 0);
          const totalTime = traceEnd - traceStart;
          const unaccounted = totalTime - accountedTime;
          if (unaccounted > 10) {
            timelineBreakdown.push({ phase: "overhead", duration: unaccounted, order: timelineOrder++ });
          }

          // Collapse consecutive idle periods into a summary for cleaner display
          if (idleCount > 3) {
            const idleItems = timelineBreakdown.filter(t => t.phase === "idle");
            const totalIdle = idleItems.reduce((sum, t) => sum + t.duration, 0);
            // Remove individual idle entries
            for (let i = timelineBreakdown.length - 1; i >= 0; i--) {
              if (timelineBreakdown[i].phase === "idle") {
                timelineBreakdown.splice(i, 1);
              }
            }
            // Add single summary entry
            timelineBreakdown.push({ phase: `idle (${idleCount}×)`, duration: totalIdle, order: timelineOrder++ });
          }
        }

        // Get file info from first handler:start
        const firstStart = starts[0];
        const sourceFile = firstStart ? resolveFileLabel(firstStart.ownerFileId) : null;
        const handlerCode = firstStart?.handlerCode || null;

        return {
          componentText: componentText || "Unknown trace",
          changeCount,
          hasError: !!error,
          multipleStarts: handlerNames.length > 1,
          handlerNames,
          handlerDurations,
          startCount: starts.length,
          timestamp: firstStart?.ts || traceEntries[0]?.ts,
          traceId,
          totalDuration,
          expensiveParts: topExpensive,
          timelineBreakdown,
          sourceFile,
          handlerCode,
        };
      }

      function processTraceEvents(traceEntries) {
        const events = [];
        let dedupedCount = 0;
        const lastFingerprintByEvent = new Map();
        const orderedEntries = traceEntries.slice().sort((a, b) => sortKey(a) - sortKey(b));

        // Build queue of api:start events to calculate duration for api:complete (FIFO for same URLs)
        const apiStartQueues = new Map(); // key -> array of perfTs values
        orderedEntries.forEach(e => {
          if (e.kind === "api:start" && e.url && typeof e.perfTs === "number") {
            const key = `${e.method || "GET"}:${e.url}`;
            if (!apiStartQueues.has(key)) apiStartQueues.set(key, []);
            apiStartQueues.get(key).push(e.perfTs);
          }
        });

        // Track component:vars deduplication separately with counts
        const componentVarsCounts = new Map(); // key -> { entry, count, meta }

        // Track API call deduplication (for polling detection)
        const apiCompleteCounts = new Map(); // fingerprint -> { entry, count, meta }
        const apiStartCounts = new Map(); // method:url -> { entry, count, meta }

        // Track handler deduplication (for repeated handlers from polling)
        const handlerCounts = new Map(); // fingerprint -> { entry, count, meta }

        // Track polling state changes - group by eventName, track value ranges
        const pollingStateChanges = new Map(); // eventName -> { entries: [], firstValues: {}, lastValues: {}, paths: Set }

        orderedEntries.forEach((e) => {
          // Calculate API duration for api:complete (match with earliest unmatched api:start)
          if (e.kind === "api:complete" && e.url && typeof e.perfTs === "number") {
            const key = `${e.method || "GET"}:${e.url}`;
            const queue = apiStartQueues.get(key);
            if (queue && queue.length > 0) {
              const startTs = queue.shift(); // FIFO - take earliest
              const duration = e.perfTs - startTs;
              // Only set duration if positive (negative means mismatched events from localStorage)
              if (duration >= 0) {
                e._apiDuration = duration;
              }
            }
          }

          // Deduplicate api:start events with same method+url
          if (e.kind === "api:start" && e.url) {
            const fp = fingerprintApiCall(e);
            if (apiStartCounts.has(fp)) {
              apiStartCounts.get(fp).count += 1;
              return; // Skip duplicate
            }
            apiStartCounts.set(fp, { entry: e, count: 1, meta: buildEntryMeta(e) });
            return; // Will add after loop
          }

          // Deduplicate api:complete events with same method+url+response
          if (e.kind === "api:complete" && e.url) {
            const fp = fingerprintApiCall(e);
            if (apiCompleteCounts.has(fp)) {
              apiCompleteCounts.get(fp).count += 1;
              return; // Skip duplicate
            }
            apiCompleteCounts.set(fp, { entry: e, count: 1, meta: buildEntryMeta(e) });
            return; // Will add after loop
          }

          if (e.kind === "state:changes") {
            if (isNoopStateChange(e)) { dedupedCount += 1; return; }

            // Check for polling pattern - same eventName with same diff structure
            const eventName = e.eventName || e.uid || "state:changes";
            const diffPaths = (e.diffJson || []).map(d => d.path).sort().join(",");
            const pollingKey = `${eventName}|${diffPaths}`;

            if (pollingStateChanges.has(pollingKey)) {
              // Same structure - this is likely polling, track the range
              const tracking = pollingStateChanges.get(pollingKey);
              tracking.count += 1;
              // Update last values
              (e.diffJson || []).forEach(d => {
                tracking.lastValues[d.path] = d.after;
              });
              tracking.lastEntry = e;
              return; // Skip - will show as collapsed summary
            }

            // First occurrence - start tracking
            const firstValues = {};
            const lastValues = {};
            (e.diffJson || []).forEach(d => {
              firstValues[d.path] = d.before;
              lastValues[d.path] = d.after;
            });
            pollingStateChanges.set(pollingKey, {
              firstEntry: e,
              lastEntry: e,
              count: 1,
              firstValues,
              lastValues,
              paths: diffPaths,
              eventName,
              meta: buildEntryMeta(e)
            });
            return; // Will add after loop
          }

          // Deduplicate handler:start and handler:complete events (e.g., repeated "loaded" handlers from polling)
          if (e.kind === "handler:start" || e.kind === "handler:complete") {
            const handlerName = e.eventName || "unknown";
            const code = e.code || e.arrow || "";
            const componentId = e.uid || e.instanceId || "";
            const fileId = e.ownerFileId ?? "";
            // Fingerprint by kind + handler name + code + component + file (to distinguish same handler on different components/files)
            const fp = `${e.kind}|${handlerName}|${code}|${componentId}|${fileId}`;
            if (handlerCounts.has(fp)) {
              handlerCounts.get(fp).count += 1;
              return; // Skip duplicate
            }
            handlerCounts.set(fp, { entry: e, count: 1, meta: buildEntryMeta(e) });
            return; // Will add after loop
          }

          // Deduplicate component:vars events with identical values
          if (e.kind === "component:vars:init" || e.kind === "component:vars:change") {
            const varName = e.eventName || "unknown";
            // Fingerprint based on var name and the diff content
            const fp = e.diffPretty || JSON.stringify(e.changes);
            const key = `${e.kind}|${varName}|${fp}`;

            if (componentVarsCounts.has(key)) {
              componentVarsCounts.get(key).count += 1;
              return; // Skip adding duplicate
            }
            componentVarsCounts.set(key, { entry: e, count: 1, meta: buildEntryMeta(e) });
            return; // Will add after loop
          }

          const meta = buildEntryMeta(e);
          // Add duration to handler:complete eventTitle
          let eventTitle = e.kind + (e.eventName ? ` ${e.eventName}` : "");
          if (e.kind === "handler:complete" && e.duration !== undefined) {
            eventTitle += ` (${e.duration.toFixed(1)}ms)`;
          }
          events.push({
            entry: e, meta,
            eventTitle,
            label: e.componentLabel ? `"${e.componentLabel}"` : "",
          });
        });

        // Add deduplicated component:vars events with counts
        for (const [, data] of componentVarsCounts) {
          const { entry, count, meta } = data;
          events.push({
            entry: { ...entry, _dedupCount: count },
            meta,
            eventTitle: entry.kind + (entry.eventName ? ` ${entry.eventName}` : ""),
            label: entry.componentLabel ? `"${entry.componentLabel}"` : "",
          });
          if (count > 1) dedupedCount += count - 1;
        }

        // Add deduplicated api:start events with counts
        for (const [, data] of apiStartCounts) {
          const { entry, count, meta } = data;
          const method = normalizeMethod(entry.method);
          const url = normalizeUrl(entry.url);
          events.push({
            entry: { ...entry, _dedupCount: count },
            meta,
            eventTitle: `api:start ${method} ${url}`,
            label: "",
          });
          if (count > 1) dedupedCount += count - 1;
        }

        // Add deduplicated api:complete events with counts
        for (const [, data] of apiCompleteCounts) {
          const { entry, count, meta } = data;
          const method = normalizeMethod(entry.method);
          const url = normalizeUrl(entry.url);
          events.push({
            entry: { ...entry, _dedupCount: count },
            meta,
            eventTitle: `api:complete ${method} ${url}`,
            label: "",
          });
          if (count > 1) dedupedCount += count - 1;
        }

        // Add deduplicated handler events with counts
        for (const [, data] of handlerCounts) {
          const { entry, count, meta } = data;
          let eventTitle = entry.kind + (entry.eventName ? ` ${entry.eventName}` : "");
          if (entry.kind === "handler:complete" && entry.duration !== undefined) {
            eventTitle += ` (${entry.duration.toFixed(1)}ms)`;
          }
          events.push({
            entry: { ...entry, _dedupCount: count },
            meta,
            eventTitle,
            label: entry.componentLabel ? `"${entry.componentLabel}"` : "",
          });
          if (count > 1) dedupedCount += count - 1;
        }

        // Add polling state change summaries
        for (const [, data] of pollingStateChanges) {
          const { firstEntry, count, firstValues, lastValues, eventName, meta } = data;
          // Build range summary for each path
          const ranges = Object.keys(lastValues).map(path => {
            // Skip redundant root-level paths (same as eventName or empty)
            if (!path || path === eventName || path === eventName.replace("DataSource:", "") || path === eventName.replace("AppState:", "")) {
              return null;
            }
            const first = firstValues[path];
            const last = lastValues[path];
            // Format values - truncate long strings
            const formatVal = (v) => {
              if (v === undefined) return "undefined";
              if (typeof v === "string" && v.length > 30) return `"${v.substring(0, 30)}..."`;
              if (typeof v === "string") return `"${v}"`;
              if (typeof v === "object") return JSON.stringify(v).substring(0, 40) + (JSON.stringify(v).length > 40 ? "..." : "");
              return String(v);
            };
            if (first === undefined && last !== undefined) {
              return `${path}: → ${formatVal(last)}`;
            }
            if (JSON.stringify(first) === JSON.stringify(last)) {
              return null; // Same value, skip
            }
            return `${path}: ${formatVal(first)} → ${formatVal(last)}`;
          }).filter(Boolean);

          events.push({
            entry: { ...firstEntry, _pollingCount: count, _pollingRanges: ranges },
            meta,
            eventTitle: `state:changes ${eventName}`,
            label: "", // Count and ranges shown by renderer via _pollingCount and _pollingRanges
          });
          if (count > 1) dedupedCount += count - 1;
        }

        // Re-sort events by timestamp after adding deferred events
        events.sort((a, b) => sortKey(a.entry) - sortKey(b.entry));

        return { events, dedupedCount };
      }

      function buildInteractionText(entry) {
        const type = entry.componentType || "";
        const label = entry.componentLabel || entry.uid || "";
        const detailTextContent = entry.detail?.text;
        const hasOnlyTag = !type && label && /^[a-z]+$/.test(label);
        const contextText = hasOnlyTag && detailTextContent && detailTextContent.length < 40 ? ` "${detailTextContent}"` : "";
        return type ? (label && label !== type ? `${type} "${label}"` : type) : (label || "Unknown") + contextText;
      }

      function findDataSourceCollisions(entries) {
        const groups = new Map();
        entries.forEach((e) => {
          const isDataSource = e.componentType === "DataSource" || (e.eventName && e.eventName.startsWith("DataSource:"));
          if (!isDataSource) return;
          const key = e.dataSourceId || e.uid;
          if (!key) return;
          if (!groups.has(key)) groups.set(key, []);
          groups.get(key).push(e);
        });
        const collisions = [];
        for (const [key, list] of groups.entries()) {
          const uniqueInstances = new Set(list.map((e) => e.instanceId).filter(Boolean));
          if (uniqueInstances.size > 1 || list.length > 1) {
            // Deduplicate entries within this group - only show unique combinations
            const seen = new Set();
            const uniqueEntries = [];
            list.forEach((e) => {
              // Fingerprint by instanceId + url + file + source range
              const fp = `${e.instanceId || ""}|${e.url || ""}|${e.file || ""}|${e.ownerSource?.start || ""}-${e.ownerSource?.end || ""}`;
              if (!seen.has(fp)) {
                seen.add(fp);
                uniqueEntries.push({ entry: e, meta: buildEntryMeta(e) });
              }
            });
            // Only show if there are multiple unique entries (actual collision)
            if (uniqueEntries.length > 1) {
              collisions.push({ key, entries: uniqueEntries });
            }
          }
        }
        return collisions;
      }

      function groupDataSourceUpdates(entries) {
        const groups = new Map();
        entries.forEach((entry) => {
          const name = entry.uid || (entry.eventName && entry.eventName.replace("DataSource:", "")) || "unknown";
          const key = entry.instanceId ? `${name}::${entry.instanceId}` : name;
          if (!groups.has(key)) groups.set(key, { name, instanceId: entry.instanceId, entries: [] });
          groups.get(key).entries.push(entry);
        });

        const result = [];
        for (const [, group] of groups.entries()) {
          const { name, instanceId, entries } = group;
          entries.sort((a, b) => (a.ts || 0) - (b.ts || 0));
          const firstTs = entries[0]?.ts;
          const lastTs = entries[entries.length - 1]?.ts;
          const timeline = entries.map((e, i) => i === 0 ? "0ms" : `+${(e.ts || 0) - (firstTs || 0)}ms`);

          let isRedundant = false;
          if (entries.length > 1) {
            const firstData = entries[0]?.diffJson?.[0]?.after;
            isRedundant = entries.every((e) => {
              try { return JSON.stringify(e?.diffJson?.[0]?.after) === JSON.stringify(firstData); }
              catch { return false; }
            });
          }

          result.push({
            name, instanceId, timeline, isRedundant,
            entries: entries.map((e, i) => ({ entry: e, relTime: i === 0 ? "0ms" : `+${(e.ts || 0) - (firstTs || 0)}ms`, meta: buildEntryMeta(e) })),
            updateCount: entries.length, firstTs, lastTs,
            meta: buildEntryMeta(entries[0]),
          });
        }
        return result;
      }

      // Counter for generating unique request IDs
      let _requestIdCounter = 0;

      function processAllEntries(entries) {
        // NOTE: We intentionally do NOT pre-assign traceIds to orphaned api:complete events.
        // The old approach used the LAST api:start's traceId for ALL orphans, which caused
        // wrong matching when a DataSource makes multiple requests over time.
        // Instead, we rely on timing-based matching below to find the correct api:start,
        // then inherit its traceId.

        // Assign unique requestId to each API request lifecycle
        // This disambiguates multiple requests from the same DataSource (instanceId)
        // Also store traceId so we can correctly group api:complete with its api:start
        const pendingRequests = new Map(); // instanceId -> queue of {requestId, perfTs, method, url, traceId}
        entries.forEach((e) => {
          if (e.kind === "api:start") {
            // Don't reassign if already has requestId (from previous processing)
            if (!e._requestId) {
              e._requestId = `req-${++_requestIdCounter}`;
            }
            const requestId = e._requestId;
            const key = e.instanceId || "unknown";
            if (!pendingRequests.has(key)) pendingRequests.set(key, []);
            pendingRequests.get(key).push({
              requestId,
              perfTs: e.perfTs,
              method: (e.method || "GET").toUpperCase(), // Normalize case for matching
              url: e.url,
              traceId: e.traceId, // Store traceId for inheritance
            });
          }
        });

        // Match api:complete and api:error to pending requests by method+url+timing+traceId
        // Also inherit the correct traceId from the matched api:start
        // IMPORTANT: Process completions in chronological order so earlier completions
        // get matched to earlier starts (prevents later completion from "stealing" a match)
        const apiCompletions = entries
          .filter((e) => (e.kind === "api:complete" || e.kind === "api:error") && !e._requestId)
          .sort((a, b) => (a.perfTs || 0) - (b.perfTs || 0));

        apiCompletions.forEach((e) => {
            const key = e.instanceId || "unknown";
            const queue = pendingRequests.get(key);
            if (queue && queue.length > 0) {
              const method = (e.method || "GET").toUpperCase(); // Normalize case for matching
              const completePerfTs = e.perfTs || Infinity;
              const completeTraceId = e.traceId; // May be undefined

              // Find the best match: same method+url+traceId, started before completion, most recent start time
              let bestMatchIdx = -1;
              let bestMatchPerfTs = -1;

              queue.forEach((r, idx) => {
                if (r.method === method && r.url === e.url) {
                  // If completion has traceId, require matching traceId
                  if (completeTraceId && r.traceId && r.traceId !== completeTraceId) {
                    return; // Skip - traceId mismatch
                  }
                  // Match must have started before (or at same time as) completion
                  if (r.perfTs <= completePerfTs && r.perfTs > bestMatchPerfTs) {
                    bestMatchIdx = idx;
                    bestMatchPerfTs = r.perfTs;
                  }
                }
              });

              if (bestMatchIdx !== -1) {
                const matched = queue.splice(bestMatchIdx, 1)[0];
                e._requestId = matched.requestId;
                // Always use matched api:start's traceId (overrides any pre-pass inheritance)
                // If matched has no traceId, clear any incorrect one from pre-pass
                e.traceId = matched.traceId || undefined;
              } else {
                // Fallback: take the most recent pending request with matching traceId (if any)
                let fallbackIdx = -1;
                let fallbackPerfTs = -1;
                queue.forEach((r, idx) => {
                  // Prefer same traceId, or any if no traceId match
                  const traceMatch = !completeTraceId || !r.traceId || r.traceId === completeTraceId;
                  if (traceMatch && r.perfTs > fallbackPerfTs) {
                    fallbackIdx = idx;
                    fallbackPerfTs = r.perfTs;
                  }
                });
                if (fallbackIdx === -1) fallbackIdx = 0; // Last resort: first in queue
                const matched = queue.splice(fallbackIdx, 1)[0];
                e._requestId = matched.requestId;
                // Always use matched api:start's traceId (overrides any pre-pass inheritance)
                e.traceId = matched.traceId || undefined;
              }
            }
        });

        const interactions = entries.filter((e) => e.kind === "interaction" && !e.traceId);
        const nonInteractions = entries.filter((e) => e.kind !== "interaction" || e.traceId);

        const tracesMap = new Map();
        let orphans = [];
        nonInteractions.forEach((entry) => {
          if (entry.traceId) {
            if (!tracesMap.has(entry.traceId)) tracesMap.set(entry.traceId, []);
            tracesMap.get(entry.traceId).push(entry);
          } else {
            orphans.push(entry);
          }
        });

        // Find startup trace and merge bootstrap orphans into it
        // If no startup trace exists, create a synthetic one to collect orphaned polling events
        let startupTraceId = Array.from(tracesMap.keys()).find(id => id.startsWith("startup-"));
        if (!startupTraceId) {
          // Create synthetic startup trace
          startupTraceId = "startup-synthetic";
          tracesMap.set(startupTraceId, []);
        }
        {
          const startupEntries = tracesMap.get(startupTraceId);
          const startupMinTs = Math.min(...startupEntries.map(e => sortKey(e) || Infinity));

          // Bootstrap orphans: state changes that occurred before or at startup start
          const bootstrapOrphans = orphans.filter(e => {
            const ts = sortKey(e);
            // Include if: no timestamp (init events), or timestamp <= startup start + small buffer
            return ts === 0 || ts <= startupMinTs + 100;
          });

          // Mark and add bootstrap events to startup trace
          bootstrapOrphans.forEach(e => {
            e._bootstrap = true;
            startupEntries.push(e);
          });

          // Remove bootstrap orphans from orphans list
          orphans = orphans.filter(e => !e._bootstrap);

          // Note: We previously had "incidental interaction" merging here, but it was too aggressive.
          // A user clicking "Save" should still show as a trace even if the handler is on "settingsForm".
          // Now we only merge polling-only traces (where ALL handlers are "loaded").

          // Merge "polling-only" traces into Startup
          // These are traces where the only handlers are "loaded" handlers (from DataSource polling)
          // and there's no meaningful user-triggered handler
          const pollingTracesToMerge = [];
          for (const [traceId, traceEntries] of tracesMap.entries()) {
            if (traceId === startupTraceId) continue;

            // Get all handler:start events
            const handlers = traceEntries.filter(e => e.kind === "handler:start");
            if (handlers.length === 0) {
              // Trace with no handlers - skip (might be interaction-only)
              continue;
            }

            // Check if ALL handlers are "loaded" handlers (polling)
            const allAreLoaded = handlers.every(h => h.eventName === "loaded");
            if (allAreLoaded) {
              pollingTracesToMerge.push(traceId);
            }
          }

          // Merge polling traces into Startup
          pollingTracesToMerge.forEach(traceId => {
            const entries = tracesMap.get(traceId);
            entries.forEach(e => {
              if (e.kind !== "interaction") {
                startupEntries.push(e);
              }
            });
            tracesMap.delete(traceId);
          });

          // Remove synthetic startup if it ended up empty
          if (startupTraceId === "startup-synthetic" && startupEntries.length === 0) {
            tracesMap.delete(startupTraceId);
          }
        }

        // Merge orphaned API events into ChangeListener traces they triggered
        // When a DataSource refetch (api:start/api:complete without traceId) triggers a ChangeListener,
        // the ChangeListener gets a t- trace but the API events are orphaned. Merge them together.
        const orphanedApiEvents = orphans.filter(e =>
          (e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error") &&
          e.instanceId &&
          typeof e.perfTs === "number"
        );

        if (orphanedApiEvents.length > 0) {
          // Group orphaned API events by instanceId
          const orphanedByInstance = new Map();
          orphanedApiEvents.forEach(e => {
            if (!orphanedByInstance.has(e.instanceId)) orphanedByInstance.set(e.instanceId, []);
            orphanedByInstance.get(e.instanceId).push(e);
          });

          // For each t- trace with a ChangeListener, check if orphaned API events triggered it
          for (const [traceId, traceEntries] of tracesMap.entries()) {
            if (!traceId.startsWith("t-")) continue;

            // Check if this trace has a ChangeListener handler
            const hasChangeListener = traceEntries.some(e =>
              e.kind === "handler:start" && e.componentType === "ChangeListener"
            );
            if (!hasChangeListener) continue;

            // Find the earliest timestamp in this trace
            const traceMinTs = Math.min(...traceEntries.filter(e => typeof e.perfTs === "number").map(e => e.perfTs));
            if (!isFinite(traceMinTs)) continue;

            // Look for orphaned api:complete events that happened within 100ms before the trace started
            for (const [instanceId, apiEvents] of orphanedByInstance.entries()) {
              const apiComplete = apiEvents.find(e => e.kind === "api:complete");
              if (!apiComplete) continue;

              // Check if api:complete happened shortly before this trace started (within 100ms)
              const timeDiff = traceMinTs - apiComplete.perfTs;
              if (timeDiff >= 0 && timeDiff <= 100) {
                // Merge these API events into the trace
                apiEvents.forEach(e => {
                  e._mergedFromOrphan = true;
                  traceEntries.push(e);
                });
                // Remove from orphans
                orphanedByInstance.delete(instanceId);
              }
            }
          }

          // Remove merged orphans from the orphans list
          orphans = orphans.filter(e => !e._mergedFromOrphan);
        }

        // Time-based association: Move events from Startup/orphans into interaction traces
        // when they fall within the handler's time window (between handler:start and handler:complete)
        // This handles cases like confirm dialogs where the API call happens after user confirms
        // but gets the startup traceId instead of the interaction traceId

        // Helper to check if an event should be moved to an interaction trace
        const isUserActionEvent = (e) => {
          // API events (non-status, non-license polling)
          if ((e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error")) {
            if (e.url && (e.url.includes("/status") || e.url.includes("/license"))) return false;
            return true;
          }
          // State changes for user data (not serverInfo/polling)
          if (e.kind === "state:changes") {
            if (e.eventName === "DataSource:serverInfo") return false;
            if (e.eventName?.startsWith("AppState:")) {
              const isPolling = e.diffJson?.every(d =>
                d.path === "stats" || d.path?.startsWith("stats.") ||
                d.path === "status" || d.path === "logs" || d.path === "sessions"
              );
              if (isPolling) return false;
            }
            return true;
          }
          // Component variable changes (e.g., items array in Users component)
          if (e.kind === "component:vars:change") {
            // Skip serverStatus changes (polling-driven)
            if (e.diff?.some(d => d.path === "serverStatus")) return false;
            return true;
          }
          return false;
        };

        // First pass: collect interaction trace time windows
        const interactionWindows = [];
        for (const [traceId, traceEntries] of tracesMap.entries()) {
          if (!traceId.startsWith("i-")) continue;

          const handlerStarts = traceEntries.filter(e => e.kind === "handler:start" && typeof e.perfTs === "number");
          const handlerCompletes = traceEntries.filter(e => e.kind === "handler:complete" && typeof e.perfTs === "number");

          if (handlerStarts.length === 0 || handlerCompletes.length === 0) continue;

          const traceStartTs = Math.min(...handlerStarts.map(e => e.perfTs));
          const traceEndTs = Math.max(...handlerCompletes.map(e => e.perfTs));

          interactionWindows.push({ traceId, traceEntries, traceStartTs, traceEndTs });
        }

        // Second pass: move events from Startup trace into interaction traces
        const startupTraceEntries = tracesMap.get(startupTraceId);
        if (startupTraceEntries && interactionWindows.length > 0) {
          const eventsToMove = [];

          startupTraceEntries.forEach(e => {
            if (typeof e.perfTs !== "number") return;
            if (!isUserActionEvent(e)) return;

            // Find an interaction trace whose window contains this event
            // Add small buffer after handler:complete for state changes that arrive just after
            for (const win of interactionWindows) {
              if (e.perfTs >= win.traceStartTs && e.perfTs <= win.traceEndTs + 500) {
                eventsToMove.push({ event: e, targetTrace: win.traceEntries });
                break;
              }
            }
          });

          // Move the events
          eventsToMove.forEach(({ event, targetTrace }) => {
            event._movedFromStartup = true;
            targetTrace.push(event);
          });

          // Remove moved events from startup
          if (eventsToMove.length > 0) {
            const movedSet = new Set(eventsToMove.map(m => m.event));
            tracesMap.set(startupTraceId, startupTraceEntries.filter(e => !movedSet.has(e)));
          }
        }

        // Also check orphans (events with no traceId at all)
        for (const win of interactionWindows) {
          const orphansInWindow = orphans.filter(e => {
            if (typeof e.perfTs !== "number") return false;
            if (e.perfTs < win.traceStartTs || e.perfTs > win.traceEndTs + 500) return false;
            return isUserActionEvent(e);
          });

          orphansInWindow.forEach(e => {
            e._mergedByTimeWindow = true;
            win.traceEntries.push(e);
          });
        }

        // Remove time-window merged orphans from the orphans list
        orphans = orphans.filter(e => !e._mergedByTimeWindow);

        // Merge remaining orphaned polling events into Startup
        // This includes API events, "loaded" handlers, and DataSource state changes
        const startupEntries = tracesMap.get(startupTraceId);
        if (startupEntries) {
          // Only merge orphaned events that look like polling, not user actions
          // Be selective: only merge "loaded" handlers and status polling, not all DataSource events
          const pollingOrphans = orphans.filter(e => {
            // "loaded" handlers (from DataSource polling)
            if ((e.kind === "handler:start" || e.kind === "handler:complete") && e.eventName === "loaded") {
              return true;
            }
            // Status polling API events
            if ((e.kind === "api:start" || e.kind === "api:complete") && e.url && e.url.includes("/status")) {
              return true;
            }
            // DataSource:serverInfo state changes (polling)
            if (e.kind === "state:changes" && e.eventName === "DataSource:serverInfo") {
              return true;
            }
            // AppState changes that are likely from polling (only if diff is stats-related)
            if (e.kind === "state:changes" && e.eventName && e.eventName.startsWith("AppState:")) {
              const isPollingChange = e.diffJson?.every(d =>
                d.path === "stats" || d.path?.startsWith("stats.") ||
                d.path === "status" || d.path === "logs" || d.path === "sessions"
              );
              if (isPollingChange) return true;
            }
            return false;
          });
          pollingOrphans.forEach(e => {
            e._mergedToStartup = true;
            startupEntries.push(e);
          });
          orphans = orphans.filter(e => !e._mergedToStartup);
        }

        // Filter polling events from interaction traces
        // These get the interaction traceId when they happen during handler execution
        // (e.g., serverInfo polling while waiting for confirm dialog)
        const isPollingEvent = (e) => {
          // serverInfo state changes
          if (e.kind === "state:changes" && e.eventName === "DataSource:serverInfo") return true;
          // status API calls
          if ((e.kind === "api:start" || e.kind === "api:complete") && e.url?.includes("/status")) return true;
          // loaded handlers for serverInfo
          if ((e.kind === "handler:start" || e.kind === "handler:complete") &&
              e.eventName === "loaded" && e.componentLabel === "serverInfo") return true;
          // AppState polling changes
          if (e.kind === "state:changes" && e.eventName?.startsWith("AppState:")) {
            const isPolling = e.diffJson?.every(d =>
              d.path === "stats" || d.path?.startsWith("stats.") ||
              d.path === "status" || d.path === "logs" || d.path === "sessions"
            );
            if (isPolling) return true;
          }
          return false;
        };

        for (const [traceId, traceEntries] of tracesMap.entries()) {
          // For interaction traces, filter out polling noise
          if (traceId.startsWith("i-")) {
            const filtered = traceEntries.filter(e => !isPollingEvent(e));
            tracesMap.set(traceId, filtered);
          }
        }

        const processedTraces = [];
        for (const [traceId, traceEntries] of tracesMap.entries()) {
          const summary = buildTraceSummary(traceEntries);
          const { events, dedupedCount } = processTraceEvents(traceEntries);
          // Use minimum timestamp from all entries (first event in trace)
          const minTs = Math.min(...traceEntries.map(e => sortKey(e) || Infinity));
          processedTraces.push({ traceId, summary, events, dedupedCount, ts: minTs === Infinity ? 0 : minTs });
        }
        processedTraces.sort((a, b) => b.ts - a.ts);

        const processedInteractions = interactions.map((entry) => ({
          entry, componentText: buildInteractionText(entry), ts: sortKey(entry) || 0,
        }));

        const timelineItems = [];
        processedTraces.forEach((trace) => timelineItems.push({ type: "trace", ...trace }));
        processedInteractions.forEach((interaction) => timelineItems.push({ type: "interaction", ...interaction }));
        // Sort by timestamp descending, but pin startup traces to the bottom
        timelineItems.sort((a, b) => {
          const aIsStartup = a.traceId && a.traceId.startsWith("startup-");
          const bIsStartup = b.traceId && b.traceId.startsWith("startup-");
          if (aIsStartup && !bIsStartup) return 1;  // a goes after b
          if (!aIsStartup && bIsStartup) return -1; // a goes before b
          return b.ts - a.ts; // normal descending timestamp order
        });

        const dataSourceOrphans = orphans.filter((e) => e.componentType === "DataSource" || (e.eventName && e.eventName.startsWith("DataSource:")));
        const otherOrphans = orphans
          .filter((e) => e.componentType !== "DataSource" && !(e.eventName && e.eventName.startsWith("DataSource:")))
          // Filter out API events without URLs (likely incomplete/internal events)
          .filter((e) => {
            const isApiWithoutUrl = (e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error") && !e.url;
            if (isApiWithoutUrl) {
              console.log("[Inspector] Filtered orphan API event without URL:", JSON.stringify(e, null, 2));
            }
            return !isApiWithoutUrl;
          });

        return {
          timelineItems,
          groupedDataSources: groupDataSourceUpdates(dataSourceOrphans),
          otherOrphans: otherOrphans.map((e) => {
            // Build title - include URL for API events
            let title = e.kind;
            if (e.eventName) title += ` ${e.eventName}`;
            else if (e.url) title += ` ${normalizeMethod(e.method)} ${normalizeUrl(e.url)}`;
            return { entry: e, meta: buildEntryMeta(e), title };
          }),
          collisions: findDataSourceCollisions(entries),
          sourceFiles: getSourceFileList(),
          totalEvents: entries.length,
          totalDeduped: processedTraces.reduce((acc, t) => acc + t.dedupedCount, 0),
        };
      }

      // =============================================================================
      // PRETTY VIEW RENDERING
      // =============================================================================

      // Check if two traces are similar enough to collapse
      function areTracesSimilar(trace1, trace2) {
        if (!trace1 || !trace2) return false;
        // Same component/handler description
        if (trace1.summary.componentText !== trace2.summary.componentText) return false;
        // Same handler names
        const h1 = trace1.summary.handlerNames.join(",");
        const h2 = trace2.summary.handlerNames.join(",");
        return h1 === h2;
      }

      // Group consecutive similar traces
      function groupSimilarTraces(items) {
        const result = [];
        let currentGroup = null;

        items.forEach((item) => {
          if (item.type === "trace") {
            // Skip traces with no meaningful content (but keep startup traces and traces with handlers)
            const isStartup = item.traceId && item.traceId.startsWith("startup-");
            const hasContent = item.summary.changeCount > 0 || item.summary.hasError || item.summary.startCount > 0;
            if (!hasContent && !isStartup) return;

            if (!currentGroup) {
              currentGroup = { type: "trace-group", traces: [item] };
            } else if (areTracesSimilar(currentGroup.traces[0], item)) {
              currentGroup.traces.push(item);
            } else {
              result.push(currentGroup);
              currentGroup = { type: "trace-group", traces: [item] };
            }
          } else {
            // Push any pending trace group before interaction
            if (currentGroup) {
              result.push(currentGroup);
              currentGroup = null;
            }
            result.push(item);
          }
        });

        // Push final trace group
        if (currentGroup) {
          result.push(currentGroup);
        }

        return result;
      }

      function renderPrettyView(processed) {
        const blocks = [];
        const notes = [];

        // Group similar consecutive traces
        const groupedItems = groupSimilarTraces(processed.timelineItems);

        groupedItems.forEach((item) => {
          if (item.type === "trace-group") {
            const traces = item.traces;
            if (traces.length === 1) {
              // Single trace - render normally
              blocks.push(renderTraceGroupPretty(traces[0]));
            } else if (traces.length === 2) {
              // Two traces - render both (reverse order: oldest first for readability)
              blocks.push(renderTraceGroupPretty(traces[1]));
              blocks.push(renderTraceGroupPretty(traces[0]));
            } else {
              // 3+ traces - show first (chronologically), ellipsis, last (chronologically)
              // Since timeline is reverse-chron, traces[length-1] is oldest, traces[0] is newest
              blocks.push(renderTraceGroupPretty(traces[traces.length - 1]));
              const skipped = traces.length - 2;
              blocks.push(`
                <div class="trace-group" style="text-align: center; padding: 8px; color: var(--color-text-muted); font-style: italic;">
                  … ${skipped} more similar "${traces[0].summary.componentText}" trace${skipped > 1 ? "s" : ""} …
                </div>
              `);
              blocks.push(renderTraceGroupPretty(traces[0]));
            }
          } else if (item.type === "trace") {
            // Should not happen after grouping, but handle just in case
            const isStartup = item.traceId && item.traceId.startsWith("startup-");
            const hasContent = item.summary.changeCount > 0 || item.summary.hasError || item.summary.startCount > 0;
            if (!hasContent && !isStartup) return;
            blocks.push(renderTraceGroupPretty(item));
          } else if (item.type === "interaction") {
            blocks.push(renderInteractionPretty(item));
          }
        });

        if (processed.groupedDataSources.length) {
          blocks.push(`<div class="section-header">DataSource updates (async):</div>`);
          blocks.push(renderDataSourceGroupsPretty(processed.groupedDataSources));
        }

        if (processed.otherOrphans.length) {
          blocks.push(`<div class="section-header">Other events without trace:</div>`);
          processed.otherOrphans.slice().reverse().forEach((orphan) => blocks.push(renderOrphanPretty(orphan)));
        }

        // Notes section disabled for now - collision detection kept in code but not rendered
        // if (processed.collisions.length) {
        //   const items = processed.collisions.map((c) => {
        //     const rows = c.entries.map((item) => {
        //       const parts = item.meta.parts.filter((p) => !p.startsWith("perfTs"));
        //       return `<div class="note-item">- ${parts.join(" | ")}</div>`;
        //     }).join("");
        //     return `<div class="note-key">${c.key}</div>${rows}`;
        //   }).join("");
        //   notes.push(`
        //     <div class="note-title">DataSource identity reused across components</div>
        //     <div class="note-description">These are independent instances that share the same id/uid. If you intended shared state, lift the DataSource to a common parent.</div>
        //     <div class="note-items">${items}</div>
        //   `);
        // }

        if (notes.length) {
          blocks.push(`
            <details class="collapsible-section">
              <summary>Notes (${notes.length})</summary>
              <div class="collapsible-content">
                <ol class="notes-list">${notes.map((note) => `<li>${note}</li>`).join("")}</ol>
              </div>
            </details>
          `);
        }

        if (processed.sourceFiles.length) {
          const items = processed.sourceFiles.map((file, idx) => `<div class="source-file">[${idx}] <span class="file-link" data-file="${file}">${file}</span></div>`).join("");
          blocks.push(`
            <details class="collapsible-section">
              <summary>Source files (${processed.sourceFiles.length})</summary>
              <div class="collapsible-content">${items}</div>
            </details>
          `);
        }

        return blocks.join("");
      }

      function renderTraceGroupPretty(trace) {
        const { summary, events, dedupedCount, traceId } = trace;
        const age = formatAge(summary.timestamp);

        // Build header: just error badge and total duration
        let changesHtml = "";
        if (summary.hasError) {
          changesHtml = `<span class="badge-error">error</span> `;
        }

        let durationHtml = "";
        if (summary.totalDuration !== null) {
          durationHtml = `<span class="text-muted">duration: ${summary.totalDuration.toFixed(0)}ms</span>`;
        }

        let bodyHtml = "";

        // Show timeline breakdown as a table (chronological order)
        if (summary.timelineBreakdown.length > 0 && summary.totalDuration) {
          const sorted = summary.timelineBreakdown.slice().sort((a, b) => a.order - b.order);
          let tableRows = sorted.map(item => {
            return `<tr><td>${item.phase}</td><td class="text-right">${item.duration.toFixed(0)}ms</td></tr>`;
          }).join("");
          tableRows += `<tr class="timeline-total"><td><strong>total</strong></td><td class="text-right"><strong>${summary.totalDuration.toFixed(0)}ms</strong></td></tr>`;
          bodyHtml += `<table class="timeline-table"><thead><tr><th>phase</th><th class="text-right">duration</th></tr></thead><tbody>${tableRows}</tbody></table>`;
        }

        // Build map of API event pairs by requestId for linking (supports multiple requests per instanceId)
        const apiPairs = new Map(); // requestId -> { startIdx, completeIdx, errorIdx }
        events.forEach((evt, idx) => {
          const e = evt.entry;
          if ((e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error") && e._requestId) {
            if (!apiPairs.has(e._requestId)) apiPairs.set(e._requestId, {});
            if (e.kind === "api:start") apiPairs.get(e._requestId).startIdx = idx;
            if (e.kind === "api:complete") apiPairs.get(e._requestId).completeIdx = idx;
            if (e.kind === "api:error") apiPairs.get(e._requestId).errorIdx = idx;
          }
        });

        events.forEach((evt, idx) => {
          const e = evt.entry;
          const metaInline = evt.meta.parts.length ? `<span class="meta-inline">(${evt.meta.parts.join(" | ")})</span>` : "";

          // Add anchor above the event for API events to enable linking (anchor above for better scroll position)
          // Use _requestId if available for precise linking, fall back to instanceId
          const anchorKey = e._requestId || e.instanceId;
          const anchorId = (e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error") && anchorKey
            ? `api-${e.kind.replace(':', '-')}-${anchorKey}`
            : "";
          if (anchorId) {
            bodyHtml += `<a id="${anchorId}" class="api-anchor"></a>`;
          }
          bodyHtml += `<div class="trace-event">`;

          if (e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error") {
            const method = normalizeMethod(e.method);
            const url = normalizeUrl(e.url);
            const errorClass = e.kind === "api:error" ? "text-error" : "";
            const errorInfo = e.kind === "api:error" && e.error ? ` <span class="text-error">- ${e.error.message || e.error}</span>` : "";
            const durationInfo = e.kind === "api:complete" && typeof e._apiDuration === "number" ? ` (${e._apiDuration.toFixed(1)}ms)` : "";
            const statusInfo = e.kind === "api:complete" && e.status ? ` <span class="badge-success">${e.status}</span>` : "";
            // Show short requestId to disambiguate multiple requests from same DataSource
            const requestIdInfo = e._requestId ? ` <span class="badge-muted">${e._requestId}</span>` : "";
            // Show dedup count for repeated polling calls
            const dedupCount = e._dedupCount || 1;
            const dedupInfo = dedupCount > 1 ? ` <span class="badge-muted">×${dedupCount}</span>` : "";

            // Build link to paired event using requestId
            let pairLink = "";
            if (e._requestId && apiPairs.has(e._requestId)) {
              const pair = apiPairs.get(e._requestId);
              if (e.kind === "api:start") {
                if (pair.completeIdx !== undefined) {
                  pairLink = ` <a href="#api-api-complete-${e._requestId}" class="api-pair-link">→ response</a>`;
                } else if (pair.errorIdx !== undefined) {
                  pairLink = ` <a href="#api-api-error-${e._requestId}" class="api-pair-link">→ error</a>`;
                }
              } else if ((e.kind === "api:complete" || e.kind === "api:error") && pair.startIdx !== undefined) {
                pairLink = ` <a href="#api-api-start-${e._requestId}" class="api-pair-link">← request</a>`;
              }
            }

            bodyHtml += `<div class="trace-event-header ${errorClass}">[${e.kind}]${statusInfo}${durationInfo}${dedupInfo} <strong>${method}</strong> ${url}${errorInfo}${requestIdInfo}${pairLink}${metaInline}</div>`;
            // Show body expression if present (for api:start)
            if (e.bodyExpression && e.kind === "api:start") {
              bodyHtml += `<div class="body-expression">body: <code>${e.bodyExpression}</code></div>`;
            }
            // Show request body if present (for api:start)
            if (e.body && e.kind === "api:start") {
              const bodyStr = typeof e.body === "string" ? e.body : JSON.stringify(e.body, null, 2);
              const truncatedBody = bodyStr.length > 500 ? bodyStr.substring(0, 500) + "..." : bodyStr;
              bodyHtml += `<details><summary>Request</summary><pre class="api-body">${truncatedBody}</pre></details>`;
            }
            // Show response for api:complete
            if (e.kind === "api:complete") {
              let resultStr;
              if (e.result === undefined) {
                resultStr = "(no response body)";
              } else if (e.result === null) {
                resultStr = "null";
              } else if (e.result === "") {
                resultStr = "(empty string)";
              } else if (typeof e.result === "string") {
                resultStr = e.result || "(empty string)";
              } else {
                resultStr = JSON.stringify(e.result, null, 2);
              }
              const truncatedResult = resultStr.length > 500 ? resultStr.substring(0, 500) + "..." : resultStr;
              bodyHtml += `<details><summary>Response</summary><pre class="api-body">${truncatedResult}</pre></details>`;
            }
          } else if (e.kind === "error:boundary") {
            const location = e.location ? ` in <code>${e.location}</code>` : "";
            bodyHtml += `<div class="trace-event-header text-error">[${e.kind}] <strong>${e.error || "Unknown error"}</strong>${location}${metaInline}</div>`;
            if (e.stack) bodyHtml += `<details><summary>Stack trace</summary><pre class="stack-trace">${e.stack}</pre></details>`;
            if (e.componentStack) bodyHtml += `<details><summary>Component stack</summary><pre class="stack-trace">${e.componentStack}</pre></details>`;
          } else if (e.kind === "handler:error") {
            const errorMsg = e.error?.message || "Unknown error";
            const fileLabel = e.ownerFileId !== undefined ? resolveFileLabel(e.ownerFileId) : null;
            const fileInfo = fileLabel ? ` <span class="text-muted">in ${fileLabel}</span>` : "";
            // Filter file from metadata since we show it prominently in the error text
            const filteredParts = evt.meta.parts.filter(p => !p.startsWith("file "));
            const errorMetaInline = filteredParts.length ? `<span class="meta-inline">(${filteredParts.join(" | ")})</span>` : "";
            bodyHtml += `<div class="trace-event-header text-error">[${e.kind}] ${e.eventName || ""} <strong>${errorMsg}</strong>${fileInfo}${errorMetaInline}</div>`;
            if (e.error?.stack) bodyHtml += `<details><summary>Stack trace</summary><pre class="stack-trace">${e.error.stack}</pre></details>`;
            // Add XMLUI source expander if available
            if (e.ownerSource && fileLabel) {
              const [startChar, endChar] = [e.ownerSource.start, e.ownerSource.end];
              bodyHtml += `<details class="source-loader" data-file="${fileLabel}" data-start="${startChar}" data-end="${endChar}">`;
              bodyHtml += `<summary>XMLUI Source</summary>`;
              bodyHtml += `<pre class="source-code">Click to load...</pre>`;
              bodyHtml += `</details>`;
            }
          } else if (e.kind === "navigate") {
            const from = e.from || "/";
            const to = e.to || "?";
            bodyHtml += `<div class="trace-event-header">[navigate] <strong>${from}</strong> → <strong>${to}</strong>${metaInline}</div>`;
          } else if (e.kind === "modal:show" || e.kind === "modal:confirm" || e.kind === "modal:cancel") {
            const icon = e.kind === "modal:show" ? "📋" : e.kind === "modal:confirm" ? "✓" : "✗";
            const title = e.title ? ` "${e.title}"` : "";
            bodyHtml += `<div class="trace-event-header">[${e.kind}] ${icon}${title}${metaInline}</div>`;
          } else if (e.kind === "state:changes" && (e.componentType === "DataSource" || (e.eventName && e.eventName.startsWith("DataSource:")))) {
            // DataSource state change - structured display
            const dsName = e.eventName?.replace("DataSource:", "") || e.uid || "unknown";
            const pollingCount = e._pollingCount || 1;
            const pollingInfo = pollingCount > 1 ? ` <span class="badge-muted">×${pollingCount}</span>` : "";
            bodyHtml += `<div class="trace-event-header">[state:changes] <strong>DataSource:${dsName}</strong>${pollingInfo}</div>`;

            // Show polling ranges if present
            if (e._pollingRanges && e._pollingRanges.length > 0) {
              bodyHtml += `<div class="trace-meta" style="font-size: var(--font-sm); color: var(--color-text-muted); margin-left: var(--space-4);">`;
              bodyHtml += e._pollingRanges.map(r => `<div>${r}</div>`).join("");
              bodyHtml += `</div>`;
            }

            // Add expandable metadata section
            bodyHtml += `<div class="event-metadata">`;

            // Instance details expander
            if (e.instanceId || e.dataSourceUrl || e.ownerUid || evt.meta.resolvedFile) {
              bodyHtml += `<details><summary>Instance Details</summary><dl class="metadata-grid">`;
              if (e.instanceId) bodyHtml += `<dt>Instance</dt><dd>${e.instanceId}</dd>`;
              if (e.dataSourceUrl) {
                // Try to resolve window variable expressions like { window.query }
                let resolvedUrl = e.dataSourceUrl;
                const windowVarMatch = e.dataSourceUrl.match(/^\{\s*window\.(\w+)\s*\}$/);
                if (windowVarMatch) {
                  try {
                    const varName = windowVarMatch[1];
                    const parentWindow = window.parent || window;
                    if (parentWindow[varName]) {
                      resolvedUrl = parentWindow[varName];
                    }
                  } catch (err) { /* ignore resolution errors */ }
                }
                bodyHtml += `<dt>API URL</dt><dd>${resolvedUrl}</dd>`;
              }
              if (e.dataSourceBody) {
                // Show body expression
                const bodyExpr = e.dataSourceBody;
                bodyHtml += `<dt>Body</dt><dd><code>${bodyExpr}</code></dd>`;
                // If it's a function call like { window.functionName() } or { window.functionName(args) }, try to show function source
                const funcMatch = bodyExpr.match(/^\{\s*window\.(\w+)\s*\([^)]*\)\s*\}$/);
                if (funcMatch) {
                  const funcName = funcMatch[1];
                  bodyHtml += `<dt></dt><dd><details class="function-source-loader" data-func-name="${funcName}"><summary>Function Source</summary><pre class="source-code">Click to load...</pre></details></dd>`;
                }
              }
              if (e.ownerUid) bodyHtml += `<dt>uid</dt><dd>${e.ownerUid}</dd>`;
              if (evt.meta.resolvedFile) bodyHtml += `<dt>File</dt><dd><span class="file-link" data-file="${evt.meta.resolvedFile}">${evt.meta.resolvedFile}</span></dd>`;
              if (evt.meta.sourceRange) bodyHtml += `<dt>Source</dt><dd>chars ${evt.meta.sourceRange}</dd>`;
              bodyHtml += `</dl></details>`;
            }

            // XMLUI source expander (lazy-loaded)
            if (evt.meta.hasSource && evt.meta.resolvedFile) {
              const sourceId = `src-${Math.random().toString(36).slice(2, 10)}`;
              const [startChar, endChar] = evt.meta.sourceRange.split("-").map(Number);
              bodyHtml += `<details class="source-loader" data-file="${evt.meta.resolvedFile}" data-start="${startChar}" data-end="${endChar}">`;
              bodyHtml += `<summary>XMLUI Source</summary>`;
              bodyHtml += `<pre class="source-code">Click to load...</pre>`;
              bodyHtml += `</details>`;
            }

            bodyHtml += `</div>`;
          } else if (e.kind === "state:changes" && e.eventName && e.eventName.startsWith("AppState:")) {
            // AppState change - add link to find initialValue source
            const bucketName = e.eventName.replace("AppState:", "");
            const pollingCount = e._pollingCount || 1;
            const pollingInfo = pollingCount > 1 ? ` <span class="badge-muted">×${pollingCount}</span>` : "";
            bodyHtml += `<div class="trace-event-header">[state:changes] <strong>AppState:${bucketName}</strong>${pollingInfo}${metaInline}</div>`;

            // Show polling ranges if present
            if (e._pollingRanges && e._pollingRanges.length > 0) {
              bodyHtml += `<div class="trace-meta" style="font-size: var(--font-sm); color: var(--color-text-muted); margin-left: var(--space-4);">`;
              bodyHtml += e._pollingRanges.map(r => `<div>${r}</div>`).join("");
              bodyHtml += `</div>`;
            }

            // Add "View initialValue Source" expander
            bodyHtml += `<details class="appstate-source-loader" data-bucket="${bucketName}">`;
            bodyHtml += `<summary>View initialValue Source</summary>`;
            bodyHtml += `<pre class="source-code">Click to load...</pre>`;
            bodyHtml += `</details>`;
          } else if (e.kind === "component:vars:init" || e.kind === "component:vars:change") {
            // Component variable initialization/change - show var names and file
            const varNames = e.eventName || "unknown";
            const fileLabel = e.ownerFileId !== undefined ? resolveFileLabel(e.ownerFileId) : e.file;
            const kindLabel = e.kind === "component:vars:init" ? "init" : "change";
            const dedupCount = e._dedupCount || 1;
            const dedupInfo = dedupCount > 1 ? ` <span class="badge-warning">×${dedupCount} instances</span>` : "";
            const perfTsInfo = e.perfTs !== undefined ? `<span class="meta-inline">(perfTs ${e.perfTs.toFixed(1)})</span>` : "";
            bodyHtml += `<div class="trace-event-header">[component:vars:${kindLabel}] <strong>${varNames}</strong>${dedupInfo} ${perfTsInfo}</div>`;

            // Add expandable metadata section (matching state:changes structure)
            bodyHtml += `<div class="event-metadata">`;

            // Instance details expander (omit source char range - not useful for vars)
            if (e.componentLabel || e.componentType || evt.meta.resolvedFile) {
              bodyHtml += `<details><summary>Instance Details</summary><dl class="metadata-grid">`;
              if (e.componentLabel) bodyHtml += `<dt>Component</dt><dd>${e.componentLabel}</dd>`;
              if (e.componentType && e.componentType !== e.componentLabel) bodyHtml += `<dt>Type</dt><dd>${e.componentType}</dd>`;
              if (evt.meta.resolvedFile) bodyHtml += `<dt>File</dt><dd><span class="file-link" data-file="${evt.meta.resolvedFile}">${evt.meta.resolvedFile}</span></dd>`;
              if (dedupCount > 1) bodyHtml += `<dt>Instances</dt><dd>${dedupCount} identical</dd>`;
              bodyHtml += `</dl></details>`;
            }

            // XMLUI source expander (lazy-loaded) - for vars, search for declaration
            if (evt.meta.resolvedFile) {
              const varName = e.eventName || "";
              // For component:vars, load whole file and search for var declaration
              bodyHtml += `<details class="source-loader" data-file="${evt.meta.resolvedFile}" data-var-name="${varName}" data-search-var="true">`;
              bodyHtml += `<summary>XMLUI Source</summary>`;
              bodyHtml += `<pre class="source-code">Click to load...</pre>`;
              bodyHtml += `</details>`;
            }

            // Diff expander - use pretty diff like state:changes does, with array summary for large arrays
            if (Array.isArray(e.diff) && e.diff.length) {
              let usedArraySummary = false;
              // Check if this is an array diff that should be summarized
              if (e.diff.length === 1) {
                const only = e.diff[0];
                if (Array.isArray(only.before) && Array.isArray(only.after) && (isKeyedArray(only.before) || isKeyedArray(only.after))) {
                  const analysis = analyzeArrayDiff(only.before, only.after);
                  if (analysis.isSignificant) {
                    bodyHtml += `<div>${renderArrayDiffSummary(analysis)}</div>`;
                    usedArraySummary = true;
                  }
                } else if (only.before === undefined && Array.isArray(only.after) && isKeyedArray(only.after)) {
                  // Init case: undefined → array
                  bodyHtml += `<div class="text-success">${only.after.length} item${only.after.length !== 1 ? "s" : ""} initialized</div>`;
                  usedArraySummary = true;
                }
              }

              // Skip redundant diff when array summary already shows field-level changes
              if (!usedArraySummary) {
                const snapshots = buildSnapshotsFromDiff(e.diff);
                const delta = jsondiffpatch.diff(snapshots.left, snapshots.right);
                if (delta) {
                  const diffHtml = htmlFormatter.format(delta, snapshots.left);
                  bodyHtml += wrapDiffInExpander(diffHtml, "Diff", false);
                }
              }
            } else if (e.diffPretty) {
              // Fallback to text display in expander
              const cleanDiff = e.diffPretty.replace(/^file:.*\n/m, "");
              bodyHtml += `<details><summary>Diff</summary><pre class="source-code">${cleanDiff.replace(/</g, "&lt;")}</pre></details>`;
            }

            bodyHtml += `</div>`;
          } else if (e.kind === "handler:start" || e.kind === "handler:complete") {
            // Handler events - show with source info if available
            const handlerDedupCount = e._dedupCount || 1;
            const handlerDedupInfo = handlerDedupCount > 1 ? ` <span class="badge-muted">×${handlerDedupCount}</span>` : "";
            bodyHtml += `<div class="trace-event-header">${evt.eventTitle}${handlerDedupInfo}${evt.label ? ` ${evt.label}` : ""}${metaInline}</div>`;

            // Show eventArgs if available (the data passed to the handler)
            if (e.kind === "handler:start" && e.eventArgs && e.eventArgs.length > 0) {
              try {
                const cleanedArgs = cleanEventArgs(e.eventArgs);
                const argsStr = safeStringify(cleanedArgs, 2);
                if (argsStr && argsStr.length < 200) {
                  bodyHtml += `<div class="trace-meta">args: <code>${argsStr.replace(/</g, "&lt;")}</code></div>`;
                } else if (argsStr && argsStr.length < 5000) {
                  bodyHtml += `<details><summary>Event Args (${e.eventArgs.length} items)</summary><pre class="source-code">${argsStr.replace(/</g, "&lt;")}</pre></details>`;
                } else {
                  bodyHtml += `<div class="trace-meta">args: <code>[${e.eventArgs.length} items, too large to display]</code></div>`;
                }
              } catch (err) {
                bodyHtml += `<div class="trace-meta">args: <code>[${e.eventArgs.length} items, failed to serialize]</code></div>`;
              }
            }

            // Show handler code if available
            if (e.handlerCode) {
              const code = e.handlerCode.trim();
              // Check if it's a .xs function call (just function name with parens, like "functionName()")
              const xsFuncMatch = code.match(/^(\w+)\(\)$/);
              // Check if it's a window function call pattern
              const windowMatch = code.match(/^\{\s*window\.(\w+)\s*\([^)]*\)\s*\}$/);
              // Check if it's a simple function call inside braces
              const simpleFuncMatch = code.match(/^\{\s*(\w+)\s*\([^)]*\)\s*\}$/);
              // Check if it's an arrow function like (data) => { ... } or () => { ... }
              const arrowMatch = code.match(/^\([^)]*\)\s*=>\s*\{/);
              // Check if it's an APICall handler - extract method and url
              const apiCallMatch = code.match(/Actions\.callApi\s*\(\s*\{[^}]*method:\s*["']?([^"',}]+)["']?\s*,[^}]*url:\s*["']?([^"',}]+)["']?/s) ||
                                   code.match(/Actions\.callApi\s*\(\s*\{[^}]*url:\s*["']?([^"',}]+)["']?\s*,[^}]*method:\s*["']?([^"',}]+)["']?/s);

              if (apiCallMatch) {
                // APICall handler - show summarized method/url
                const [, first, second] = apiCallMatch;
                // Determine which is method vs url based on content
                const hasSlash = (s) => s && s.includes("/");
                const method = hasSlash(first) ? normalizeMethod(second) : normalizeMethod(first);
                const url = hasSlash(first) ? first : second;
                bodyHtml += `<div class="trace-meta">APICall: <code>${method} ${url}</code></div>`;
                // Show full code in collapsed details for reference
                bodyHtml += `<details><summary>Full Handler</summary><pre class="source-code">${code.replace(/</g, "&lt;")}</pre></details>`;
              } else if (xsFuncMatch) {
                // .xs function reference
                bodyHtml += `<div class="trace-meta">.xs: <code>${xsFuncMatch[1]}()</code></div>`;
              } else if (windowMatch) {
                // Window function call
                bodyHtml += `<div class="trace-meta">window: <code>${windowMatch[1]}()</code></div>`;
              } else if (simpleFuncMatch && !windowMatch) {
                // Simple function call (probably from .xs)
                bodyHtml += `<div class="trace-meta">calls: <code>${simpleFuncMatch[1]}()</code></div>`;
              } else if (arrowMatch) {
                // Arrow function - show in expander (usually longer code)
                bodyHtml += `<details><summary>Handler Code</summary><pre class="source-code">${code.replace(/</g, "&lt;")}</pre></details>`;
              } else if (code.startsWith("{") && code.endsWith("}")) {
                // Inline handler code
                const innerCode = code.slice(1, -1).trim();
                if (innerCode.length < 80) {
                  bodyHtml += `<div class="trace-meta">inline: <code>${innerCode.replace(/</g, "&lt;")}</code></div>`;
                } else {
                  bodyHtml += `<details><summary>Inline Handler</summary><pre class="source-code">${innerCode.replace(/</g, "&lt;")}</pre></details>`;
                }
              } else if (code.length < 100) {
                // Other short code
                bodyHtml += `<div class="trace-meta">code: <code>${code.replace(/</g, "&lt;")}</code></div>`;
              } else {
                // Longer code - show in expander
                bodyHtml += `<details><summary>Handler Code</summary><pre class="source-code">${code.replace(/</g, "&lt;")}</pre></details>`;
              }

              // Extract and show function source lookups for called functions
              const calledFuncs = extractFunctionCalls(code);
              if (calledFuncs.length > 0) {
                const sourceFile = evt.meta.resolvedFile || "";
                calledFuncs.forEach(funcName => {
                  // Add a lazy-loaded function source expander with file context
                  bodyHtml += `<details class="xs-function-loader" data-func-name="${funcName}" data-source-file="${sourceFile}">`;
                  bodyHtml += `<summary>↳ <code>${funcName}</code> source</summary>`;
                  bodyHtml += `<pre class="source-code">Click to load...</pre>`;
                  bodyHtml += `</details>`;
                });
              }

              // Extract and show Action source lookups for .execute() calls
              const actionRefs = extractActionReferences(code);
              if (actionRefs.length > 0) {
                const sourceFile = evt.meta.resolvedFile || "";
                actionRefs.forEach(actionId => {
                  // Add a lazy-loaded Action source expander
                  bodyHtml += `<details class="action-source-loader" data-action-id="${actionId}" data-source-file="${sourceFile}">`;
                  bodyHtml += `<summary>↳ <code>&lt;Action id="${actionId}"&gt;</code> source</summary>`;
                  bodyHtml += `<pre class="source-code">Click to load...</pre>`;
                  bodyHtml += `</details>`;
                });
              }

              // Extract and show AppState method lookups for stateId.value.methodName() calls
              const appStateMethodPattern = /(\w+)\.value\.(\w+)\s*\(/g;
              let appStateMatch;
              const seenAppStateMethods = new Set();
              while ((appStateMatch = appStateMethodPattern.exec(code)) !== null) {
                const stateId = appStateMatch[1];
                const methodName = appStateMatch[2];
                const key = `${stateId}.${methodName}`;
                if (!seenAppStateMethods.has(key)) {
                  seenAppStateMethods.add(key);
                  bodyHtml += `<details class="appstate-method-loader" data-state-id="${stateId}" data-method-name="${methodName}">`;
                  bodyHtml += `<summary>↳ <code>${stateId}.value.${methodName}</code> source</summary>`;
                  bodyHtml += `<pre class="source-code">Click to load...</pre>`;
                  bodyHtml += `</details>`;
                }
              }
            }

            // Add XMLUI source expander only when we don't already have handlerCode shown
            // (if handlerCode is displayed, the expander would be redundant)
            if (e.kind === "handler:complete" && !e.handlerCode && evt.meta.hasSource && evt.meta.resolvedFile) {
              bodyHtml += `<div class="event-metadata">`;
              const eventName = e.eventName || "";
              const componentLabel = e.componentLabel || "";
              // Use special handler source loader that highlights the handler attribute and shows .xs code
              bodyHtml += `<details class="source-loader" data-file="${evt.meta.resolvedFile}" data-handler-name="${eventName}" data-component-label="${componentLabel}" data-search-handler="true">`;
              bodyHtml += `<summary>XMLUI Source</summary>`;
              bodyHtml += `<pre class="source-code">Click to load...</pre>`;
              bodyHtml += `</details>`;
              bodyHtml += `</div>`;
            }
          } else if (e.kind === "app:timing") {
            // App-level timing events from xsTrace()
            const durationStr = typeof e.duration === "number" ? ` (${e.duration.toFixed(1)}ms)` : "";
            bodyHtml += `<div class="trace-event-header">[app:timing] <strong>${e.label || "timing"}</strong>${durationStr}${metaInline}</div>`;
          } else if (e.kind === "interaction") {
            // Interaction events - show the interaction type (click, contextmenu, etc.)
            const interactionType = e.interaction || "unknown";
            bodyHtml += `<div class="trace-event-header">interaction ${interactionType}${evt.label ? ` ${evt.label}` : ""}${metaInline}</div>`;
          } else {
            const bootstrapBadge = e._bootstrap ? ` <span class="badge-bootstrap">bootstrap</span>` : "";
            bodyHtml += `<div class="trace-event-header">${evt.eventTitle}${evt.label ? ` ${evt.label}` : ""}${bootstrapBadge}${metaInline}</div>`;

            // Show source range for non-DataSource events too
            if (evt.meta.hasSource) {
              bodyHtml += `<div class="trace-meta">source ${evt.meta.sourceRange}</div>`;
            }
          }

          // Skip diff for component:vars (handled separately with their own diff display)
          if (Array.isArray(e.diffJson) && e.diffJson.length && e.kind !== "component:vars:init" && e.kind !== "component:vars:change") {
            let usedArraySummary = false;
            let arrayBefore = null, arrayAfter = null;
            if (e.diffJson.length === 1) {
              const only = e.diffJson[0];
              if (Array.isArray(only.before) && Array.isArray(only.after) && (isKeyedArray(only.before) || isKeyedArray(only.after))) {
                const analysis = analyzeArrayDiff(only.before, only.after);
                if (analysis.isSignificant) {
                  bodyHtml += `<div>${renderArrayDiffSummary(analysis)}</div>`;
                  usedArraySummary = true;
                  // Save arrays for full diff with context
                  arrayBefore = only.before;
                  arrayAfter = only.after;
                }
              } else if (Array.isArray(only.before) && only.after === undefined && isKeyedArray(only.before)) {
                bodyHtml += `<div class="text-error">${only.before.length} item${only.before.length !== 1 ? "s" : ""} → cleared</div>`;
                usedArraySummary = true;
              }
            }

            // Skip redundant diff when array summary already shows field-level changes
            if (!usedArraySummary) {
              try {
                const snapshots = buildSnapshotsFromDiff(e.diffJson);
                const delta = jsondiffpatch.diff(snapshots.left, snapshots.right);
                if (delta) {
                  const diffHtml = htmlFormatter.format(delta, snapshots.left);
                  bodyHtml += wrapDiffInExpander(diffHtml, "Diff", false);
                }
              } catch (diffErr) {
                bodyHtml += `<div class="text-warning">Could not render diff: ${diffErr.message}</div>`;
              }
            }
          }

          bodyHtml += `</div>`;
        });

        if (dedupedCount > 0) {
          bodyHtml += `<div class="trace-event text-warning">Deduped ${dedupedCount} repeated state change${dedupedCount > 1 ? "s" : ""}.</div>`;
        }

        return `
          <div class="trace-group" data-trace-id="${traceId}">
            <div class="trace-header" onclick="this.parentElement.classList.toggle('expanded'); this.classList.toggle('expanded');">
              <span class="arrow">▶</span>
              <div class="trace-summary">
                <span class="component">${summary.componentText}</span>
                ${changesHtml}${durationHtml}
              </div>
              <span class="trace-age">${age}</span>
            </div>
            <div class="trace-body">
              <div class="trace-meta">trace: ${traceId} <span class="help-icon" data-help="traceId">?</span></div>
              ${bodyHtml}
            </div>
          </div>
        `;
      }

      function renderInteractionPretty(interaction) {
        const { entry, componentText } = interaction;
        const age = formatAge(entry.ts);
        const detailText = entry.detail ? JSON.stringify(entry.detail) : "";

        return `
          <div class="trace-group trace-group--interaction">
            <div class="trace-header trace-header--interaction" onclick="this.parentElement.classList.toggle('expanded'); this.classList.toggle('expanded');">
              <span class="arrow">▶</span>
              <div class="trace-summary">
                <span class="badge-info">⚡</span>
                <span class="component">${componentText}</span>
                <span class="badge-info">${entry.interaction}</span>
              </div>
              <span class="trace-age">${age}</span>
            </div>
            <div class="trace-body">
              ${detailText ? `<pre class="stack-trace">${detailText}</pre>` : '<div class="text-faint">No additional detail</div>'}
            </div>
          </div>
        `;
      }

      function renderDataSourceGroupsPretty(groups) {
        let html = "";
        for (const group of groups) {
          const { name, instanceId, entries, timeline, isRedundant, updateCount, lastTs, meta } = group;
          const redundancyNote = isRedundant ? ` <span class="badge-error">⚠️ redundant</span>` : "";
          const countClass = updateCount > 1 ? "text-warning" : "";
          const sourceMetaParts = meta.parts.filter((p) => !p.startsWith("perfTs"));
          const sourceMeta = sourceMetaParts.length ? ` <span class="meta-inline">(${sourceMetaParts.join(" | ")})</span>` : "";

          html += `
            <div class="trace-group" data-datasource="${name}">
              <div class="trace-header" onclick="this.parentElement.classList.toggle('expanded'); this.classList.toggle('expanded');">
                <span class="arrow">▶</span>
                <div class="trace-summary">
                  <span class="component">DataSource "${name}"</span>
                  ${instanceId ? `<span class="meta-inline">(instance: ${instanceId})</span>` : ""}
                  ${sourceMeta}
                  <span class="${countClass}"> updated ${updateCount}x</span>
                  <span class="text-muted"> (${timeline.join(", ")})</span>
                  ${redundancyNote}
                </div>
                <span class="trace-age">${formatAge(lastTs)}</span>
              </div>
              <div class="trace-body">
          `;

          entries.forEach((item, i) => {
            const e = item.entry;
            const metaParts = item.meta.parts.filter((p) => !p.startsWith("perfTs"));

            html += `<div class="trace-event">`;
            html += `<div class="trace-event-header">Update ${i + 1} @ ${item.relTime}</div>`;
            if (metaParts.length) html += `<div class="trace-meta">${metaParts.join(" | ")}</div>`;

            if (Array.isArray(e.diffJson) && e.diffJson.length) {
              let usedArraySummary = false;
              if (e.diffJson.length === 1) {
                const only = e.diffJson[0];
                if (Array.isArray(only.before) && Array.isArray(only.after) && (isKeyedArray(only.before) || isKeyedArray(only.after))) {
                  const analysis = analyzeArrayDiff(only.before, only.after);
                  if (analysis.isSignificant) {
                    html += `<div>${renderArrayDiffSummary(analysis)}</div>`;
                    usedArraySummary = true;
                  }
                } else if (Array.isArray(only.before) && only.after === undefined && isKeyedArray(only.before)) {
                  html += `<div class="text-error">${only.before.length} item${only.before.length !== 1 ? "s" : ""} → cleared</div>`;
                  usedArraySummary = true;
                }
              }
              // Skip redundant diff when array summary already shows field-level changes
              if (!usedArraySummary) {
                const snapshots = buildSnapshotsFromDiff(e.diffJson);
                const delta = jsondiffpatch.diff(snapshots.left, snapshots.right);
                if (delta) {
                  const diffHtml = htmlFormatter.format(delta, snapshots.left);
                  html += wrapDiffInExpander(diffHtml, "Diff", false);
                }
              }
            }
            html += `</div>`;
          });

          html += `</div></div>`;
        }
        return html;
      }

      function renderOrphanPretty(orphan) {
        const { entry, meta, title } = orphan;
        const age = formatAge(entry.ts);
        const instanceTag = entry.instanceId ? ` (instance: ${entry.instanceId})` : "";

        let html = `<div class="text-muted">${age} ${title}${instanceTag}</div>`;

        if (Array.isArray(entry.diffJson) && entry.diffJson.length) {
          let usedArraySummary = false;
          if (entry.diffJson.length === 1) {
            const only = entry.diffJson[0];
            if (Array.isArray(only.before) && Array.isArray(only.after) && (isKeyedArray(only.before) || isKeyedArray(only.after))) {
              const analysis = analyzeArrayDiff(only.before, only.after);
              if (analysis.isSignificant) {
                html += `<div>${renderArrayDiffSummary(analysis)}</div>`;
                usedArraySummary = true;
              }
            } else if (Array.isArray(only.before) && only.after === undefined && isKeyedArray(only.before)) {
              html += `<div class="text-error">${only.before.length} item${only.before.length !== 1 ? "s" : ""} → cleared</div>`;
              usedArraySummary = true;
            }
          }
          // Skip redundant diff when array summary already shows field-level changes
          if (!usedArraySummary) {
            const snapshots = buildSnapshotsFromDiff(entry.diffJson);
            const delta = jsondiffpatch.diff(snapshots.left, snapshots.right);
            if (delta) {
              const diffHtml = htmlFormatter.format(delta, snapshots.left);
              html += wrapDiffInExpander(diffHtml, "Diff", false);
            }
          }
        }

        return html;
      }

      // =============================================================================
      // RAW VIEW RENDERING
      // =============================================================================

      function renderRawView(processed) {
        const lines = [];

        lines.push("=== XMLUI Inspector Export ===");
        lines.push(`Total events: ${processed.totalEvents}`);
        lines.push("");

        let traceIndex = 0;
        processed.timelineItems.forEach((item) => {
          if (item.type === "trace") {
            // Skip traces with no meaningful content (but keep startup traces and traces with handlers)
            const isStartup = item.traceId && item.traceId.startsWith("startup-");
            const hasContent = item.summary.changeCount > 0 || item.summary.hasError || item.summary.startCount > 0;
            if (!hasContent && !isStartup) return;
            traceIndex++;
            lines.push(...renderTraceRaw(item, traceIndex));
            lines.push("");
          }
        });

        const standaloneInteractions = processed.timelineItems.filter((item) => item.type === "interaction");
        if (standaloneInteractions.length) {
          lines.push("--- Standalone interactions ---");
          standaloneInteractions.forEach((item) => {
            lines.push(`    [interaction] ${item.componentText} ${item.entry.interaction}`);
          });
          lines.push("");
        }

        if (processed.groupedDataSources.length) {
          lines.push("--- DataSource updates (async) ---");
          processed.groupedDataSources.forEach((group) => {
            lines.push(`    DataSource "${group.name}"${group.instanceId ? ` (instance: ${group.instanceId})` : ""} updated ${group.updateCount}x${group.isRedundant ? " [REDUNDANT]" : ""}`);
            group.entries.forEach((item, i) => {
              const e = item.entry;
              lines.push(`        Update ${i + 1} @ ${item.relTime}`);
              if (e.diffJson) {
                e.diffJson.forEach((d) => {
                  if (Array.isArray(d.before) && Array.isArray(d.after) && (isKeyedArray(d.before) || isKeyedArray(d.after))) {
                    const summary = summarizeArrayDiff(d.before, d.after);
                    lines.push(`            ${d.path}:`);
                    summary.split("\n").forEach((line) => lines.push(`                ${line}`));
                  } else if (Array.isArray(d.after) && d.before === undefined && isKeyedArray(d.after)) {
                    lines.push(`            ${d.path}: initialized with ${d.after.length} items`);
                  } else if (Array.isArray(d.before) && d.after === undefined && isKeyedArray(d.before)) {
                    lines.push(`            ${d.path}: ${d.before.length} items → cleared`);
                  } else if (d.before && d.after && typeof d.before === "object" && typeof d.after === "object" && !Array.isArray(d.before) && !Array.isArray(d.after)) {
                    // Object diff - show which fields changed
                    const allKeys = new Set([...Object.keys(d.before), ...Object.keys(d.after)]);
                    const changedKeys = [];
                    allKeys.forEach((key) => {
                      const bv = JSON.stringify(d.before[key]);
                      const av = JSON.stringify(d.after[key]);
                      if (bv !== av) changedKeys.push(key);
                    });
                    if (changedKeys.length === 0) {
                      lines.push(`            ${d.path}: (no visible change)`);
                    } else {
                      lines.push(`            ${d.path}:`);
                      changedKeys.forEach((key) => {
                        const bv = d.before[key];
                        const av = d.after[key];
                        const bvStr = bv === undefined ? "undefined" : JSON.stringify(bv)?.slice(0, 60) || "null";
                        const avStr = av === undefined ? "undefined" : JSON.stringify(av)?.slice(0, 60) || "null";
                        lines.push(`                ${key}: ${bvStr} → ${avStr}`);
                      });
                    }
                  } else {
                    lines.push(`            ${d.path}: ${JSON.stringify(d.before)?.slice(0, 80) || "undefined"} → ${JSON.stringify(d.after)?.slice(0, 80) || "undefined"}`);
                  }
                });
              }
            });
          });
          lines.push("");
        }

        if (processed.otherOrphans.length) {
          lines.push("--- Other events (no trace) ---");
          processed.otherOrphans.forEach((orphan) => {
            lines.push(`    [${orphan.entry.kind}] ${orphan.entry.eventName || ""} (perfTs: ${orphan.entry.perfTs?.toFixed(1) || "?"})`);
          });
          lines.push("");
        }

        // Notes section disabled for now - collision detection kept in code but not rendered
        // if (processed.collisions.length) {
        //   lines.push("--- Notes ---");
        //   lines.push("1. DataSource identity reused across components. These are independent instances that share the same id/uid.");
        //   processed.collisions.forEach((c) => {
        //     lines.push(`    id/uid: ${c.key}`);
        //     c.entries.forEach((item) => {
        //       const parts = item.meta.parts.filter((p) => !p.startsWith("perfTs"));
        //       if (item.meta.hasSource) parts.push(`source: ${item.meta.sourceRange}`);
        //       lines.push(`        - ${parts.join(", ")}`);
        //     });
        //   });
        //   lines.push("");
        // }

        if (processed.sourceFiles.length) {
          lines.push("--- Source files (index → path) ---");
          processed.sourceFiles.forEach((file, idx) => lines.push(`    [${idx}] ${file}`));
        }

        return lines.join("\n");
      }

      function renderTraceRaw(trace, index) {
        const { summary, events, dedupedCount, traceId } = trace;
        const lines = [];

        lines.push(`--- Trace ${index}: ${summary.componentText}${summary.totalDuration !== null ? ` (${summary.totalDuration.toFixed(0)}ms)` : ""} ---`);
        lines.push(`    traceId: ${traceId}`);
        if (summary.timelineBreakdown.length > 0 && summary.totalDuration) {
          lines.push(`    timeline:`);
          const sorted = summary.timelineBreakdown.slice().sort((a, b) => a.order - b.order);
          sorted.forEach(item => {
            lines.push(`      ${item.phase.padEnd(40)} ${String(item.duration.toFixed(0) + "ms").padStart(8)}`);
          });
          lines.push(`      ${"total".padEnd(40)} ${String(summary.totalDuration.toFixed(0) + "ms").padStart(8)}`);
        } else if (summary.totalDuration !== null) {
          lines.push(`    duration: ${summary.totalDuration.toFixed(0)}ms`);
        }

        events.forEach((evt) => {
          const e = evt.entry;
          // Strip HTML tags from meta parts for raw text output
          const metaParts = evt.meta.parts.map(stripHtml);

          if (e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error") {
            const method = normalizeMethod(e.method);
            const url = normalizeUrl(e.url);
            const errorSuffix = e.kind === "api:error" && e.error ? ` - ${e.error.message || e.error}` : "";
            const statusSuffix = e.kind === "api:complete" && e.status ? ` [${e.status}]` : "";
            const durationSuffix = e.kind === "api:complete" && typeof e._apiDuration === "number" ? ` (${e._apiDuration.toFixed(1)}ms)` : "";
            const requestIdSuffix = e._requestId ? ` [${e._requestId}]` : "";
            const dedupCount = e._dedupCount || 1;
            const dedupSuffix = dedupCount > 1 ? ` ×${dedupCount}` : "";
            lines.push(`    [${e.kind}]${statusSuffix}${durationSuffix}${dedupSuffix} ${method} ${url}${errorSuffix}${requestIdSuffix}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);
            // Show body expression for api:start
            if (e.bodyExpression && e.kind === "api:start") {
              lines.push(`      body: ${e.bodyExpression}`);
            }
            // Show request body for api:start
            if (e.body && e.kind === "api:start") {
              const bodyStr = typeof e.body === "string" ? e.body : JSON.stringify(e.body, null, 2);
              const truncatedBody = bodyStr.length > 200 ? bodyStr.substring(0, 200) + "..." : bodyStr;
              lines.push(`      request: ${truncatedBody}`);
            }
            // Show response for api:complete
            if (e.kind === "api:complete" && e.result !== undefined) {
              const resultStr = typeof e.result === "string" ? e.result : JSON.stringify(e.result, null, 2);
              const truncatedResult = resultStr.length > 200 ? resultStr.substring(0, 200) + "..." : resultStr;
              lines.push(`      response: ${truncatedResult}`);
            }
            return;
          }
          if (e.kind === "app:timing") {
            const durationStr = typeof e.duration === "number" ? ` (${e.duration.toFixed(1)}ms)` : "";
            lines.push(`    [app:timing]${durationStr} ${e.label || "timing"}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);
            return;
          }
          if (e.kind === "error:boundary") {
            lines.push(`    [${e.kind}] ${e.error || "Unknown error"}${e.location ? ` in ${e.location}` : ""}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);
            return;
          }
          if (e.kind === "handler:error") {
            const fileLabel = e.ownerFileId !== undefined ? resolveFileLabel(e.ownerFileId) : null;
            const fileInfo = fileLabel ? ` in ${fileLabel}` : "";
            lines.push(`    [${e.kind}] ${e.eventName || ""} - ${e.error?.message || "Unknown error"}${fileInfo}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);
            return;
          }
          if (e.kind === "navigate") {
            lines.push(`    [navigate] ${e.from || "/"} → ${e.to || "?"}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);
            return;
          }
          if (e.kind === "modal:show" || e.kind === "modal:confirm" || e.kind === "modal:cancel") {
            const title = e.title ? ` "${e.title}"` : "";
            lines.push(`    [${e.kind}]${title}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);
            return;
          }
          if (e.kind === "handler:start" || e.kind === "handler:complete") {
            const handlerDedupCount = e._dedupCount || 1;
            const handlerDedupSuffix = handlerDedupCount > 1 ? ` ×${handlerDedupCount}` : "";
            lines.push(`    [${e.kind}]${handlerDedupSuffix}${e.eventName ? ` ${e.eventName}` : ""}${evt.label ? ` ${evt.label}` : ""}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);
            // Show eventArgs if available
            if (e.kind === "handler:start" && e.eventArgs && e.eventArgs.length > 0) {
              try {
                const cleanedArgs = cleanEventArgs(e.eventArgs);
                const argsStr = safeStringify(cleanedArgs);
                if (argsStr && argsStr.length < 1000) {
                  lines.push(`      args: ${argsStr.length < 100 ? argsStr : argsStr.substring(0, 100) + "..."}`);
                } else {
                  lines.push(`      args: [${e.eventArgs.length} items]`);
                }
              } catch (err) {
                lines.push(`      args: [${e.eventArgs.length} items, failed to serialize]`);
              }
            }
            // Show handler code if available
            if (e.handlerCode) {
              const code = e.handlerCode.trim();
              const xsFuncMatch = code.match(/^(\w+)\(\)$/);
              const windowMatch = code.match(/^\{\s*window\.(\w+)\s*\([^)]*\)\s*\}$/);
              const simpleFuncMatch = code.match(/^\{\s*(\w+)\s*\([^)]*\)\s*\}$/);
              const arrowMatch = code.match(/^\([^)]*\)\s*=>\s*\{/);
              // Check if it's an APICall handler - extract method and url
              const apiCallMatch = code.match(/Actions\.callApi\s*\(\s*\{[^}]*method:\s*["']?([^"',}]+)["']?\s*,[^}]*url:\s*["']?([^"',}]+)["']?/s) ||
                                   code.match(/Actions\.callApi\s*\(\s*\{[^}]*url:\s*["']?([^"',}]+)["']?\s*,[^}]*method:\s*["']?([^"',}]+)["']?/s);

              if (apiCallMatch) {
                // APICall handler - show summarized method/url
                const [, first, second] = apiCallMatch;
                const hasSlash = (s) => s && s.includes("/");
                const method = hasSlash(first) ? normalizeMethod(second) : normalizeMethod(first);
                const url = hasSlash(first) ? first : second;
                lines.push(`      APICall: ${method} ${url}`);
              } else if (xsFuncMatch) {
                lines.push(`      .xs: ${xsFuncMatch[1]}()`);
              } else if (windowMatch) {
                lines.push(`      window: ${windowMatch[1]}()`);
              } else if (simpleFuncMatch && !windowMatch) {
                lines.push(`      calls: ${simpleFuncMatch[1]}()`);
              } else if (arrowMatch) {
                // Arrow function - show first line
                const firstLine = code.split('\n')[0];
                lines.push(`      arrow: ${firstLine.length < 60 ? firstLine : firstLine.substring(0, 60) + "..."}`);
              } else if (code.startsWith("{") && code.endsWith("}")) {
                const innerCode = code.slice(1, -1).trim();
                if (innerCode.length < 60) {
                  lines.push(`      inline: ${innerCode}`);
                } else {
                  lines.push(`      inline: ${innerCode.substring(0, 60)}...`);
                }
              } else if (code.length < 80) {
                lines.push(`      code: ${code}`);
              } else {
                lines.push(`      code: ${code.substring(0, 80)}...`);
              }
            }
            return;
          }

          const bootstrapTag = e._bootstrap ? " [bootstrap]" : "";
          const pollingCount = e._pollingCount || 1;
          const pollingSuffix = pollingCount > 1 ? ` ×${pollingCount}` : "";
          lines.push(`    [${e.kind}]${pollingSuffix}${e.eventName ? ` ${e.eventName}` : ""}${evt.label ? ` ${evt.label}` : ""}${bootstrapTag}${metaParts.length ? ` (${metaParts.join(" | ")})` : ""}`);

          // Show polling ranges if present
          if (e._pollingRanges && e._pollingRanges.length > 0) {
            e._pollingRanges.forEach(r => lines.push(`        ${r}`));
          }

          if (evt.meta.hasSource) lines.push(`        source ${evt.meta.sourceRange}`);

          // Show component:vars diffs inline with array summaries
          if ((e.kind === "component:vars:init" || e.kind === "component:vars:change") && e.diff) {
            const dedupCount = e._dedupCount || 1;
            if (dedupCount > 1) {
              lines.push(`        (×${dedupCount} identical instances)`);
            }
            // Show file if available
            if (e.file) {
              lines.push(`        file: ${e.file}`);
            }
            // Summarize each var change
            e.diff.forEach((d) => {
              const varName = d.path || "value";
              if (Array.isArray(d.before) && Array.isArray(d.after) && (isKeyedArray(d.before) || isKeyedArray(d.after))) {
                // Array diff - summarize
                const summary = summarizeArrayDiff(d.before, d.after);
                lines.push(`        ${varName}:`);
                summary.split("\n").forEach((line) => lines.push(`            ${line}`));
              } else if (Array.isArray(d.after) && d.before === undefined && isKeyedArray(d.after)) {
                // Init with array
                lines.push(`        ${varName}: initialized with ${d.after.length} items`);
                d.after.slice(0, 5).forEach((item) => lines.push(`            • ${getItemLabel(item)}`));
                if (d.after.length > 5) lines.push(`            … and ${d.after.length - 5} more`);
              } else if (d.after === undefined && d.before === undefined) {
                // Skip no-op
              } else {
                // Simple value change - show compact
                const beforeStr = d.before === undefined ? "undefined" : JSON.stringify(d.before);
                const afterStr = d.after === undefined ? "undefined" : JSON.stringify(d.after);
                // Truncate if too long
                const maxLen = 80;
                const beforeDisplay = beforeStr.length > maxLen ? beforeStr.slice(0, maxLen) + "..." : beforeStr;
                const afterDisplay = afterStr.length > maxLen ? afterStr.slice(0, maxLen) + "..." : afterStr;
                lines.push(`        ${varName}: ${beforeDisplay} → ${afterDisplay}`);
              }
            });
          }

          if (e.kind === "state:changes" && e.diffJson) {
            e.diffJson.forEach((d) => {
              if (Array.isArray(d.before) && Array.isArray(d.after) && (isKeyedArray(d.before) || isKeyedArray(d.after))) {
                const summary = summarizeArrayDiff(d.before, d.after);
                lines.push(`        ${d.path}:`);
                summary.split("\n").forEach((line) => lines.push(`            ${line}`));
              } else if (Array.isArray(d.after) && d.before === undefined && isKeyedArray(d.after)) {
                lines.push(`        ${d.path}: initialized with ${d.after.length} items`);
                d.after.slice(0, 5).forEach((item) => lines.push(`            • ${getItemLabel(item)}`));
                if (d.after.length > 5) lines.push(`            … and ${d.after.length - 5} more`);
              } else if (Array.isArray(d.before) && d.after === undefined && isKeyedArray(d.before)) {
                lines.push(`        ${d.path}: ${d.before.length} items → cleared`);
              } else if (d.before && d.after && typeof d.before === "object" && typeof d.after === "object" && !Array.isArray(d.before) && !Array.isArray(d.after)) {
                // Object diff - show which fields changed
                const allKeys = new Set([...Object.keys(d.before), ...Object.keys(d.after)]);
                const changedKeys = [];
                allKeys.forEach((key) => {
                  const bv = JSON.stringify(d.before[key]);
                  const av = JSON.stringify(d.after[key]);
                  if (bv !== av) changedKeys.push(key);
                });
                if (changedKeys.length === 0) {
                  lines.push(`        ${d.path}: (no visible change)`);
                } else {
                  lines.push(`        ${d.path}:`);
                  changedKeys.forEach((key) => {
                    const bv = d.before[key];
                    const av = d.after[key];
                    const bvStr = bv === undefined ? "undefined" : JSON.stringify(bv)?.slice(0, 60) || "null";
                    const avStr = av === undefined ? "undefined" : JSON.stringify(av)?.slice(0, 60) || "null";
                    lines.push(`            ${key}: ${bvStr} → ${avStr}`);
                  });
                }
              } else {
                lines.push(`        ${d.path}: ${JSON.stringify(d.before)?.slice(0, 80) || "undefined"} → ${JSON.stringify(d.after)?.slice(0, 80) || "undefined"}`);
              }
            });
          }
        });

        if (dedupedCount > 0) lines.push(`    [dedupe] ${dedupedCount} repeated state change${dedupedCount > 1 ? "s" : ""} removed`);

        return lines;
      }

      // =============================================================================
      // MAIN RENDER FUNCTION
      // =============================================================================

      // Track when test view is active to prevent auto-refresh from overwriting it
      let testViewActive = false;

      function render() {
        testViewActive = false; // Reset test mode when normal render is triggered
        const showRaw = document.getElementById("viewRaw").checked;
        const container = document.getElementById("diff");

        // Save expanded state before re-rendering
        const expandedTraceIds = new Set();
        const expandedDataSources = new Set();
        const openDetailsIds = new Set();
        container.querySelectorAll(".trace-group.expanded").forEach(el => {
          if (el.dataset.traceId) expandedTraceIds.add(el.dataset.traceId);
          if (el.dataset.datasource) expandedDataSources.add(el.dataset.datasource);
        });
        container.querySelectorAll("details[open]").forEach(el => {
          // Save by a combination of attributes to identify the details element
          const id = el.id || el.dataset.file || el.dataset.funcName || el.dataset.varName;
          if (id) openDetailsIds.add(id);
        });

        container.innerHTML = "";

        const allEntries = getAllEntries();
        const diffEntries = allEntries.filter((entry) => entryMatches(entry, ""));

        if (!diffEntries.length) return;

        const processed = processAllEntries(diffEntries);

        if (showRaw) {
          container.innerHTML = '<div class="trace-group"><div class="trace-body" style="display:block;"><pre>' + renderRawView(processed).replace(/</g, "&lt;") + "</pre></div></div>";
        } else {
          container.innerHTML = renderPrettyView(processed);
          htmlFormatter.hideUnchanged();

          // Wire up lazy source loaders
          container.querySelectorAll("details.source-loader").forEach((details) => {
            const filePath = details.dataset.file;
            const searchVar = details.dataset.searchVar === "true";
            const searchHandler = details.dataset.searchHandler === "true";
            const varName = details.dataset.varName;
            const handlerName = details.dataset.handlerName;

            if (searchHandler && filePath && handlerName) {
              // For handlers - load file and search for handler attribute + .xs function
              const componentLabel = details.dataset.componentLabel || "";
              setupHandlerSourceLoader(details, filePath, handlerName, componentLabel);
            } else if (searchVar && filePath && varName) {
              // For component:vars - load file and search for variable declaration
              setupVarSourceLoader(details, filePath, varName);
            } else {
              const startChar = parseInt(details.dataset.start, 10);
              const endChar = parseInt(details.dataset.end, 10);
              if (filePath && !isNaN(startChar) && !isNaN(endChar)) {
                setupSourceLoader(details, filePath, startChar, endChar);
              }
            }
          });

          // Wire up function source loaders (for window.* functions)
          container.querySelectorAll("details.function-source-loader").forEach((details) => {
            const funcName = details.dataset.funcName;
            if (!funcName) return;

            let loaded = false;
            details.addEventListener("toggle", () => {
              if (!details.open || loaded) return;
              loaded = true;

              const pre = details.querySelector("pre");
              try {
                const parentWindow = window.parent || window;
                const func = parentWindow[funcName];
                if (typeof func === "function") {
                  const source = func.toString();
                  // Format with line numbers
                  const lines = source.split("\n");
                  const formatted = lines.map((line, i) => {
                    const lineNum = String(i + 1).padStart(4, " ");
                    return `${lineNum}: ${line}`;
                  }).join("\n");
                  pre.textContent = `// window.${funcName}\n${formatted}`;
                } else {
                  pre.textContent = `// window.${funcName} is not a function (type: ${typeof func})`;
                }
              } catch (err) {
                pre.textContent = `// Error loading function: ${err.message}`;
              }
            });
          });

          // Wire up .xs function source loaders (searches source files, then _xsFunctions, then window)
          container.querySelectorAll("details.xs-function-loader").forEach((details) => {
            const funcName = details.dataset.funcName;
            const sourceFile = details.dataset.sourceFile;
            if (!funcName) return;

            let loaded = false;
            details.addEventListener("toggle", async () => {
              if (!details.open || loaded) return;
              loaded = true;

              const pre = details.querySelector("pre");
              pre.textContent = "Loading...";

              try {
                let result = null;

                // 1. Search the .xmlui file (in <Script> blocks)
                if (sourceFile) {
                  const xmluiSource = await fetchSourceRange(sourceFile, 0, 999999);
                  if (xmluiSource) {
                    result = findFunctionInSource(xmluiSource, funcName, sourceFile.split("/").pop());
                  }

                  // 2. Try .xmlui.xs code-behind file
                  if (!result) {
                    const xsFile = sourceFile + ".xs";
                    const xsSource = await fetchSourceRange(xsFile, 0, 999999);
                    if (xsSource) {
                      result = findFunctionInSource(xsSource, funcName, xsFile.split("/").pop());
                    }
                  }
                }

                // 3. Search all known source files
                if (!result) {
                  const allFiles = getSourceFileList();
                  for (const file of allFiles) {
                    if (file === sourceFile) continue; // Already checked
                    const src = await fetchSourceRange(file, 0, 999999);
                    if (src) {
                      result = findFunctionInSource(src, funcName, file.split("/").pop());
                      if (result) {
                        result.location = file.split("/").pop() + ":" + result.startLine;
                        break;
                      }
                    }
                  }
                }

                // 4. Fall back to _xsFunctions or window
                if (!result) {
                  result = lookupFunctionSource(funcName);
                }

                if (result) {
                  const lines = result.source.split("\n");
                  const startLine = result.startLine || 1;
                  const formatted = lines.map((line, i) => {
                    const lineNum = String(startLine + i).padStart(4, " ");
                    return `${lineNum}: ${line}`;
                  }).join("\n");
                  pre.textContent = `// ${funcName} (from ${result.location})\n${formatted}`;
                } else {
                  // Check if this looks like a built-in component event
                  const builtInEvents = [
                    "loadChildren", "selectionDidChange", "nodeClick", "nodeExpand", "nodeCollapse",
                    "rowClick", "cellClick", "headerClick", "loaded", "error", "success",
                    "submit", "validate", "change", "didChange", "willChange",
                    "open", "close", "toggle", "focus", "blur"
                  ];
                  if (builtInEvents.includes(funcName)) {
                    pre.textContent = `// "${funcName}" is a built-in component event.\n` +
                      `// The handler implementation is provided by the XMLUI component.\n` +
                      `// Event args show the data passed to your handler.`;
                  } else {
                    // Check if we could even fetch the files
                    const allFiles = getSourceFileList();
                    const searchedCount = allFiles.length;
                    pre.textContent = `// ${funcName} not found in:\n` +
                      `//   - ${sourceFile || "(no source file)"}\n` +
                      `//   - ${searchedCount} other source files\n` +
                      `//   - window._xsFunctions\n` +
                      `//   - window.${funcName}`;
                  }
                }
              } catch (err) {
                pre.textContent = `// Error looking up ${funcName}: ${err.message}`;
              }
            });
          });

          // Wire up Action source loaders (for .execute() calls)
          container.querySelectorAll("details.action-source-loader").forEach((details) => {
            const actionId = details.dataset.actionId;
            const sourceFile = details.dataset.sourceFile;
            if (!actionId) return;

            if (sourceFile) {
              setupActionSourceLoader(details, sourceFile, actionId);
            } else {
              // No source file - show message on toggle
              let loaded = false;
              details.addEventListener("toggle", () => {
                if (!details.open || loaded) return;
                loaded = true;
                const pre = details.querySelector("pre");
                pre.textContent = `// Action "${actionId}" - no source file available to search`;
              });
            }
          });

          // Wire up AppState initialValue source loaders
          container.querySelectorAll("details.appstate-source-loader").forEach((details) => {
            const bucketName = details.dataset.bucket;
            if (!bucketName) return;

            let loaded = false;
            details.addEventListener("toggle", async () => {
              if (!details.open || loaded) return;
              loaded = true;
              const pre = details.querySelector("pre");
              pre.textContent = "Searching for AppState definition...";

              try {
                // Search all source files for bucket="bucketName"
                const sourceFiles = getSourceFileList();
                let foundFunc = null;
                let foundFile = null;
                let foundInlineValue = null;

                for (const file of sourceFiles) {
                  const source = await fetchSourceRange(file, 0, 999999);
                  if (!source) continue;

                  // For "default" bucket, find AppState without explicit bucket attribute
                  if (bucketName === "default") {
                    // Find <AppState ...> elements
                    const lines = source.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                      if (lines[i].includes('<AppState')) {
                        // Find the complete AppState element
                        let startLine = i;
                        let endLine = i;
                        while (endLine < lines.length && !lines[endLine].includes('/>') && !lines[endLine].includes('</AppState>') && !lines[endLine].includes('>')) endLine++;

                        const appStateBlock = lines.slice(startLine, endLine + 1).join('\n');
                        // Skip if it has an explicit bucket attribute (not the default)
                        if (/bucket\s*=/.test(appStateBlock)) continue;

                        // Found default AppState - check for initialValue
                        const funcMatch = appStateBlock.match(/initialValue\s*=\s*["']\{\s*(\w+)\s*\(/);
                        if (funcMatch) {
                          foundFunc = funcMatch[1];
                          foundFile = file;
                          break;
                        }
                        // Check for inline value
                        const inlineMatch = appStateBlock.match(/initialValue\s*=\s*["']\{\{([\s\S]*?)\}\}["']/);
                        if (inlineMatch) {
                          foundInlineValue = { content: inlineMatch[1].trim(), startLine: startLine + 1, file };
                          break;
                        }
                      }
                    }
                    if (foundFunc || foundInlineValue) break;
                    continue;
                  }

                  // Look for bucket="bucketName" with initialValue function call
                  const bucketPattern = new RegExp(`bucket\\s*=\\s*["']${bucketName}["'][^>]*initialValue\\s*=\\s*["']\\{\\s*(\\w+)\\s*\\(`, 'i');
                  const match = source.match(bucketPattern);
                  if (match) {
                    foundFunc = match[1];
                    foundFile = file;
                    break;
                  }
                  // Also try reverse order: initialValue before bucket
                  const reversePattern = new RegExp(`initialValue\\s*=\\s*["']\\{\\s*(\\w+)\\s*\\([^>]*bucket\\s*=\\s*["']${bucketName}["']`, 'i');
                  const reverseMatch = source.match(reversePattern);
                  if (reverseMatch) {
                    foundFunc = reverseMatch[1];
                    foundFile = file;
                    break;
                  }

                  // Look for inline object literal: initialValue="{{...}}"
                  const inlinePattern = new RegExp(`bucket\\s*=\\s*["']${bucketName}["']`, 'i');
                  if (inlinePattern.test(source)) {
                    // Find the AppState element and extract initialValue
                    const lines = source.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                      if (lines[i].includes(`bucket="${bucketName}"`) || lines[i].includes(`bucket='${bucketName}'`)) {
                        // Look backwards and forwards for the full AppState element
                        let startLine = i;
                        let endLine = i;
                        // Find start of AppState
                        while (startLine > 0 && !lines[startLine].includes('<AppState')) startLine--;
                        // Find end (closing > or />)
                        while (endLine < lines.length && !lines[endLine].includes('/>') && !lines[endLine].includes('</AppState>')) endLine++;

                        const appStateBlock = lines.slice(startLine, endLine + 1).join('\n');
                        // Extract initialValue content
                        const inlineMatch = appStateBlock.match(/initialValue\s*=\s*["']\{\{([\s\S]*?)\}\}["']/);
                        if (inlineMatch) {
                          foundInlineValue = inlineMatch[1].trim();
                          foundFile = file;
                          // Store line number for display
                          foundInlineValue = { content: foundInlineValue, startLine: startLine + 1, file };
                        }
                        break;
                      }
                    }
                    if (foundInlineValue) break;
                  }
                }

                if (foundFunc && foundFile) {
                  // Now find the function source in .xmlui or .xmlui.xs file
                  let funcSource = null;

                  // Try .xmlui file first
                  const xmluiSource = await fetchSourceRange(foundFile, 0, 999999);
                  if (xmluiSource) {
                    funcSource = findFunctionInSource(xmluiSource, foundFunc, foundFile.split("/").pop());
                  }

                  // Try .xmlui.xs code-behind file
                  if (!funcSource) {
                    const xsFile = foundFile + ".xs";
                    const xsSource = await fetchSourceRange(xsFile, 0, 999999);
                    if (xsSource) {
                      funcSource = findFunctionInSource(xsSource, foundFunc, xsFile.split("/").pop());
                    }
                  }

                  if (funcSource) {
                    const formatted = funcSource.source.split("\n").map((line, i) =>
                      `${String(funcSource.startLine + i).padStart(4)}  ${line}`
                    ).join("\n");
                    pre.textContent = `// ${foundFunc}() from ${funcSource.location}\n// AppState bucket="${bucketName}" in ${foundFile}\n\n${formatted}`;
                  } else {
                    pre.textContent = `// Found bucket="${bucketName}" in ${foundFile}\n// initialValue calls ${foundFunc}()\n// But could not locate function source`;
                  }
                } else if (foundInlineValue) {
                  // Show inline object literal
                  const formatted = `{\n  ${foundInlineValue.content}\n}`;
                  pre.textContent = `// AppState bucket="${bucketName}" in ${foundInlineValue.file}\n// Inline initialValue (line ${foundInlineValue.startLine}):\n\n${formatted}`;
                } else {
                  pre.textContent = `// Could not find AppState with bucket="${bucketName}"\n// Searched ${sourceFiles.length} source files`;
                }
              } catch (err) {
                pre.textContent = `// Error searching for AppState source: ${err.message}`;
              }
            });
          });

          // Wire up AppState method source loaders (for stateId.value.methodName() calls)
          container.querySelectorAll("details.appstate-method-loader").forEach((details) => {
            const stateId = details.dataset.stateId;
            const methodName = details.dataset.methodName;
            if (!stateId || !methodName) return;

            let loaded = false;
            details.addEventListener("toggle", async () => {
              if (!details.open || loaded) return;
              loaded = true;
              const pre = details.querySelector("pre");
              pre.textContent = "Searching for AppState definition...";

              try {
                const sourceFiles = getSourceFileList();
                let bucketName = null;
                let foundFile = null;
                let foundFunc = null;

                // Step 1: Find <AppState id="stateId" to get the bucket name
                for (const file of sourceFiles) {
                  const source = await fetchSourceRange(file, 0, 999999);
                  if (!source) continue;

                  // Look for <AppState id="stateId" ... bucket="bucketName"
                  const idPattern = new RegExp(`<AppState[^>]*\\bid\\s*=\\s*["']${stateId}["'][^>]*bucket\\s*=\\s*["'](\\w+)["']`, 'i');
                  const match = source.match(idPattern);
                  if (match) {
                    bucketName = match[1];
                    foundFile = file;
                    break;
                  }
                  // Try reverse order
                  const reversePattern = new RegExp(`<AppState[^>]*bucket\\s*=\\s*["'](\\w+)["'][^>]*\\bid\\s*=\\s*["']${stateId}["']`, 'i');
                  const reverseMatch = source.match(reversePattern);
                  if (reverseMatch) {
                    bucketName = reverseMatch[1];
                    foundFile = file;
                    break;
                  }
                }

                if (!bucketName) {
                  pre.textContent = `// Could not find <AppState id="${stateId}" ...>\n// Searched ${sourceFiles.length} source files`;
                  return;
                }

                // Step 2: Find the initialValue function for this bucket
                for (const file of sourceFiles) {
                  const source = await fetchSourceRange(file, 0, 999999);
                  if (!source) continue;

                  const bucketPattern = new RegExp(`bucket\\s*=\\s*["']${bucketName}["'][^>]*initialValue\\s*=\\s*["']\\{\\s*(\\w+)\\s*\\(`, 'i');
                  const match = source.match(bucketPattern);
                  if (match) {
                    foundFunc = match[1];
                    foundFile = file;
                    break;
                  }
                  const reversePattern = new RegExp(`initialValue\\s*=\\s*["']\\{\\s*(\\w+)\\s*\\([^>]*bucket\\s*=\\s*["']${bucketName}["']`, 'i');
                  const reverseMatch = source.match(reversePattern);
                  if (reverseMatch) {
                    foundFunc = reverseMatch[1];
                    foundFile = file;
                    break;
                  }
                }

                if (foundFunc && foundFile) {
                  // Step 3: Find the function source
                  let funcSource = null;
                  const xmluiSource = await fetchSourceRange(foundFile, 0, 999999);
                  if (xmluiSource) {
                    funcSource = findFunctionInSource(xmluiSource, foundFunc, foundFile.split("/").pop());
                  }
                  if (!funcSource) {
                    const xsFile = foundFile + ".xs";
                    const xsSource = await fetchSourceRange(xsFile, 0, 999999);
                    if (xsSource) {
                      funcSource = findFunctionInSource(xsSource, foundFunc, xsFile.split("/").pop());
                    }
                  }

                  if (funcSource) {
                    // Highlight the method name in the source
                    const lines = funcSource.source.split("\n");
                    const formatted = lines.map((line, i) => {
                      const lineNum = String(funcSource.startLine + i).padStart(4);
                      // Highlight lines containing the method name
                      if (line.includes(`${methodName}:`) || line.includes(`${methodName} :`)) {
                        return `${lineNum}► ${line}`;
                      }
                      return `${lineNum}  ${line}`;
                    }).join("\n");
                    pre.textContent = `// ${stateId}.value.${methodName}()\n// from ${foundFunc}() in ${funcSource.location}\n// AppState id="${stateId}" bucket="${bucketName}"\n\n${formatted}`;
                  } else {
                    pre.textContent = `// Found bucket="${bucketName}" for ${stateId}\n// initialValue calls ${foundFunc}()\n// But could not locate function source`;
                  }
                } else {
                  pre.textContent = `// Found <AppState id="${stateId}" bucket="${bucketName}">\n// But could not find initialValue function`;
                }
              } catch (err) {
                pre.textContent = `// Error: ${err.message}`;
              }
            });
          });

          // Restore expanded state after re-rendering
          container.querySelectorAll(".trace-group[data-trace-id]").forEach(el => {
            if (expandedTraceIds.has(el.dataset.traceId)) {
              el.classList.add("expanded");
              const header = el.querySelector(".trace-header");
              if (header) header.classList.add("expanded");
            }
          });
          container.querySelectorAll(".trace-group[data-datasource]").forEach(el => {
            if (expandedDataSources.has(el.dataset.datasource)) {
              el.classList.add("expanded");
              const header = el.querySelector(".trace-header");
              if (header) header.classList.add("expanded");
            }
          });
          // Note: We don't restore details[open] state because lazy loaders depend on the toggle event
        }
      }

      // =============================================================================
      // EVENT HANDLERS
      // =============================================================================

      document.getElementById("viewPretty").addEventListener("change", render);
      document.getElementById("viewRaw").addEventListener("change", render);

      document.getElementById("clear").addEventListener("click", () => {
        if (window.parent && window.parent._xsLogs) window.parent._xsLogs.length = 0;
        clearStoredEntries(); // Also clear localStorage
        lastStoredCount = 0; // Reset storage counter
        _requestIdCounter = 0; // Reset counter for fresh numbering
        render();
      });

      // =============================================================================
      // SEARCH FUNCTIONALITY
      // =============================================================================

      const searchState = {
        query: "",
        matches: [],
        currentIndex: -1
      };

      function clearSearchHighlights() {
        // Remove highlight spans and restore original text
        document.querySelectorAll(".search-highlight").forEach(el => {
          const parent = el.parentNode;
          parent.replaceChild(document.createTextNode(el.textContent), el);
          parent.normalize();
        });
        // Remove container outlines
        document.querySelectorAll(".search-match-container").forEach(el => {
          el.classList.remove("search-match-container");
        });
        searchState.matches = [];
        searchState.currentIndex = -1;
        updateSearchCount();
      }

      function updateSearchCount() {
        const countEl = document.getElementById("searchCount");
        if (searchState.matches.length === 0) {
          countEl.textContent = searchState.query ? "0 matches" : "";
        } else {
          countEl.textContent = `${searchState.currentIndex + 1}/${searchState.matches.length}`;
        }
      }

      function expandParentDetails(element) {
        // Walk up the DOM and expand any collapsed ancestors
        let parent = element.parentElement;
        while (parent) {
          // Handle <details> elements
          if (parent.tagName === "DETAILS" && !parent.open) {
            parent.open = true;
          }
          // Handle trace-group elements (custom expand/collapse)
          if (parent.classList && parent.classList.contains("trace-group") && !parent.classList.contains("expanded")) {
            parent.classList.add("expanded");
            // Also rotate the arrow
            const arrow = parent.querySelector(".trace-header .arrow");
            if (arrow) arrow.style.transform = "rotate(90deg)";
          }
          // Handle trace-body that might be hidden
          if (parent.classList && parent.classList.contains("trace-body")) {
            parent.style.display = "block";
          }
          parent = parent.parentElement;
        }
      }

      function highlightTextInNode(node, regex) {
        const matches = [];
        const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null, false);
        const textNodes = [];

        while (walker.nextNode()) {
          // Skip text nodes inside script, style, input elements
          const parent = walker.currentNode.parentElement;
          if (parent && (parent.tagName === "SCRIPT" || parent.tagName === "STYLE" || parent.tagName === "INPUT")) {
            continue;
          }
          textNodes.push(walker.currentNode);
        }

        textNodes.forEach(textNode => {
          const text = textNode.textContent;
          if (!regex.test(text)) return;

          // Reset regex lastIndex
          regex.lastIndex = 0;

          const fragment = document.createDocumentFragment();
          let lastIndex = 0;
          let match;

          while ((match = regex.exec(text)) !== null) {
            // Add text before match
            if (match.index > lastIndex) {
              fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
            }

            // Create highlight span
            const span = document.createElement("span");
            span.className = "search-highlight";
            span.textContent = match[0];
            fragment.appendChild(span);
            matches.push(span);

            lastIndex = regex.lastIndex;
          }

          // Add remaining text
          if (lastIndex < text.length) {
            fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
          }

          textNode.parentNode.replaceChild(fragment, textNode);
        });

        return matches;
      }

      function performSearch(query) {
        clearSearchHighlights();
        searchState.query = query;

        if (!query || query.length < 2) {
          updateSearchCount();
          return;
        }

        const diffEl = document.getElementById("diff");
        const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const regex = new RegExp(escapedQuery, "gi");

        searchState.matches = highlightTextInNode(diffEl, regex);
        searchState.currentIndex = searchState.matches.length > 0 ? 0 : -1;

        if (searchState.matches.length > 0) {
          navigateToMatch(0);
        }

        updateSearchCount();
      }

      function navigateToMatch(index) {
        if (searchState.matches.length === 0) return;

        // Remove current highlight
        searchState.matches.forEach(m => m.classList.remove("search-highlight-current"));

        // Wrap index
        if (index < 0) index = searchState.matches.length - 1;
        if (index >= searchState.matches.length) index = 0;

        searchState.currentIndex = index;
        const match = searchState.matches[index];

        // Add current highlight
        match.classList.add("search-highlight-current");

        // Expand any collapsed parent details
        expandParentDetails(match);

        // Scroll into view
        match.scrollIntoView({ behavior: "smooth", block: "center" });

        updateSearchCount();
      }

      // Debounce search input
      let searchTimeout = null;
      document.getElementById("searchInput").addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => performSearch(e.target.value), 200);
      });

      document.getElementById("searchInput").addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          if (e.shiftKey) {
            navigateToMatch(searchState.currentIndex - 1);
          } else {
            navigateToMatch(searchState.currentIndex + 1);
          }
        } else if (e.key === "Escape") {
          e.target.value = "";
          clearSearchHighlights();
        }
      });

      document.getElementById("searchPrev").addEventListener("click", () => {
        navigateToMatch(searchState.currentIndex - 1);
      });

      document.getElementById("searchNext").addEventListener("click", () => {
        navigateToMatch(searchState.currentIndex + 1);
      });

      // Clear search when view changes or data refreshes
      const originalRender = render;
      render = function() {
        clearSearchHighlights();
        document.getElementById("searchInput").value = "";
        originalRender.apply(this, arguments);
      };

      // =============================================================================
      // TEST FRAMEWORK
      // =============================================================================

      const TestFramework = {
        // Generate unique IDs for test data
        _counter: 0,
        uid() { return `test-${++this._counter}-${Date.now().toString(36)}`; },
        traceId() { return `t-${this.uid()}`; },
        interactionTraceId() { return `i-${this.uid()}`; },
        instanceId() { return `ds-${this.uid()}`; },

        // Base timestamp for test events
        baseTs: Date.now(),
        basePerfTs: 10000,

        // Generate timestamps
        ts(offset = 0) { return this.baseTs + offset; },
        perfTs(offset = 0) { return this.basePerfTs + offset; },

        // Event generators
        events: {
          interaction(type, label, opts = {}) {
            return {
              kind: "interaction",
              interaction: type,
              componentLabel: label,
              uid: opts.uid || label,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              traceId: opts.traceId,
              detail: opts.detail || { text: label },
            };
          },

          handlerStart(eventName, opts = {}) {
            return {
              kind: "handler:start",
              eventName,
              componentType: opts.componentType || "Button",
              componentLabel: opts.componentLabel || "TestComponent",
              uid: opts.uid || "test-uid",
              traceId: opts.traceId || TestFramework.traceId(),
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              ownerFileId: opts.fileId,
              handlerCode: opts.handlerCode,
            };
          },

          handlerComplete(eventName, opts = {}) {
            return {
              kind: "handler:complete",
              eventName,
              componentType: opts.componentType || "Button",
              componentLabel: opts.componentLabel || "TestComponent",
              uid: opts.uid || "test-uid",
              traceId: opts.traceId || TestFramework.traceId(),
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              duration: opts.duration,
              startPerfTs: opts.startPerfTs,
              ownerFileId: opts.fileId,
            };
          },

          handlerError(eventName, error, opts = {}) {
            return {
              kind: "handler:error",
              eventName,
              error: error || new Error("Test error"),
              componentType: opts.componentType || "Button",
              componentLabel: opts.componentLabel || "TestComponent",
              traceId: opts.traceId || TestFramework.traceId(),
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
            };
          },

          apiStart(method, url, opts = {}) {
            return {
              kind: "api:start",
              method,
              url,
              instanceId: opts.instanceId || TestFramework.instanceId(),
              traceId: opts.traceId,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              body: opts.body,
            };
          },

          apiComplete(method, url, opts = {}) {
            return {
              kind: "api:complete",
              method,
              url,
              status: opts.status || 200,
              instanceId: opts.instanceId,
              traceId: opts.traceId,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              duration: opts.duration,
              body: opts.response,
              _apiDuration: opts.duration,
            };
          },

          apiError(method, url, error, opts = {}) {
            return {
              kind: "api:error",
              method,
              url,
              error: error || "Network error",
              instanceId: opts.instanceId,
              traceId: opts.traceId,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
            };
          },

          stateChange(eventName, diffs, opts = {}) {
            return {
              kind: "state:changes",
              eventName,
              componentType: opts.componentType,
              componentLabel: opts.componentLabel,
              uid: opts.uid,
              instanceId: opts.instanceId,
              traceId: opts.traceId,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              diffJson: diffs,
              ownerFileId: opts.fileId,
              dataSourceUrl: opts.dataSourceUrl,
              ownerUid: opts.ownerUid,
            };
          },

          navigate(from, to, opts = {}) {
            return {
              kind: "navigate",
              from,
              to,
              traceId: opts.traceId,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
            };
          },

          componentVarsChange(varNames, componentLabel, opts = {}) {
            return {
              kind: "component:vars:change",
              varNames,
              componentLabel,
              componentType: opts.componentType || "Component",
              traceId: opts.traceId,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              ownerFileId: opts.fileId,
              diffJson: opts.diffs,
            };
          },

          componentVarsInit(varNames, componentLabel, opts = {}) {
            return {
              kind: "component:vars:init",
              varNames,
              componentLabel,
              componentType: opts.componentType || "Component",
              traceId: opts.traceId,
              ts: opts.ts || TestFramework.ts(),
              perfTs: opts.perfTs || TestFramework.perfTs(),
              ownerFileId: opts.fileId,
              diffJson: opts.diffs,
            };
          },
        },

        // Scenario generators based on real trace patterns
        scenarios: {
          // Simple button click with state change
          buttonClick() {
            const traceId = TestFramework.interactionTraceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.interaction("click", "Submit Button", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerStart("click", { traceId, componentLabel: "Submit Button", ts: baseTs + 1, perfTs: basePerfTs + 1 }),
              TestFramework.events.stateChange("click Submit Button", [
                { path: "formState.isSubmitting", before: false, after: true }
              ], { traceId, ts: baseTs + 5, perfTs: basePerfTs + 5 }),
              TestFramework.events.handlerComplete("click", { traceId, componentLabel: "Submit Button", duration: 15, ts: baseTs + 16, perfTs: basePerfTs + 16 }),
            ];
          },

          // API request flow (start -> complete)
          apiRequest(method = "GET", url = "/api/data") {
            const traceId = TestFramework.traceId();
            const instanceId = TestFramework.instanceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.handlerStart("fetchData", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.apiStart(method, url, { traceId, instanceId, ts: baseTs + 5, perfTs: basePerfTs + 5 }),
              TestFramework.events.apiComplete(method, url, { traceId, instanceId, duration: 150, ts: baseTs + 155, perfTs: basePerfTs + 155, response: { data: [1, 2, 3] } }),
              TestFramework.events.stateChange("DataSource:testData", [
                { path: "value", before: null, after: [{ id: 1 }, { id: 2 }, { id: 3 }] }
              ], { traceId, componentType: "DataSource", instanceId, ts: baseTs + 160, perfTs: basePerfTs + 160 }),
              TestFramework.events.handlerComplete("fetchData", { traceId, duration: 165, ts: baseTs + 165, perfTs: basePerfTs + 165 }),
            ];
          },

          // API error scenario
          apiError(method = "POST", url = "/api/submit") {
            const traceId = TestFramework.traceId();
            const instanceId = TestFramework.instanceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.handlerStart("submitForm", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.apiStart(method, url, { traceId, instanceId, ts: baseTs + 5, perfTs: basePerfTs + 5, body: { name: "test" } }),
              TestFramework.events.apiError(method, url, "500 Internal Server Error", { traceId, instanceId, ts: baseTs + 100, perfTs: basePerfTs + 100 }),
              TestFramework.events.handlerComplete("submitForm", { traceId, duration: 105, ts: baseTs + 105, perfTs: basePerfTs + 105 }),
            ];
          },

          // Navigation flow
          navigation(from = "/home", to = "/details?id=123") {
            const traceId = TestFramework.traceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.handlerStart("selectionDidChange", { traceId, componentType: "Tree", componentLabel: "tree", ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.navigate(from, to, { traceId, ts: baseTs + 10, perfTs: basePerfTs + 10 }),
              TestFramework.events.handlerComplete("selectionDidChange", { traceId, componentType: "Tree", componentLabel: "tree", duration: 57, ts: baseTs + 57, perfTs: basePerfTs + 57 }),
            ];
          },

          // Context menu interaction
          contextMenu(itemLabel = "file.txt") {
            const traceId = TestFramework.interactionTraceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.interaction("contextmenu", itemLabel, { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerStart("contextMenu", { traceId, componentLabel: "HStack", ts: baseTs + 1, perfTs: basePerfTs + 1, handlerCode: "ev => {reselectAndOpenMenu(ev, $item)}" }),
              TestFramework.events.stateChange("AppState:selection", [
                { path: "selectedIds", before: [], after: [":sh:Documents:/file.txt"] }
              ], { traceId, ts: baseTs + 3, perfTs: basePerfTs + 3 }),
              TestFramework.events.handlerComplete("contextMenu", { traceId, componentLabel: "HStack", duration: 66, ts: baseTs + 66, perfTs: basePerfTs + 66 }),
            ];
          },

          // TextArea didChange with keystroke
          textInput(prevValue = "hello", newValue = "hello world") {
            const traceId = TestFramework.interactionTraceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.interaction("keydown", newValue, { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerStart("didChange", { traceId, componentType: "TextArea", componentLabel: "inputField", ts: baseTs + 1, perfTs: basePerfTs + 1 }),
              TestFramework.events.stateChange("didChange inputField", [
                { path: "inputValue", before: prevValue, after: newValue }
              ], { traceId, ts: baseTs + 10, perfTs: basePerfTs + 10 }),
              TestFramework.events.handlerComplete("didChange", { traceId, componentType: "TextArea", componentLabel: "inputField", duration: 22, ts: baseTs + 22, perfTs: basePerfTs + 22 }),
            ];
          },

          // Startup trace pattern
          startup() {
            const traceId = `startup-${TestFramework.uid()}`;
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            const instanceId = TestFramework.instanceId();
            return [
              TestFramework.events.stateChange("AppState:config", [
                { path: "AppState:config", before: undefined, after: { theme: "light", language: "en" } }
              ], { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.componentVarsInit(["rootPath", "treeData"], "FoldersTree", { traceId, ts: baseTs + 50, perfTs: basePerfTs + 50, diffs: [
                { path: "rootPath", before: undefined, after: "/root" },
                { path: "treeData", before: undefined, after: [{ name: "Root" }] }
              ]}),
              TestFramework.events.apiStart("GET", "/api/init", { traceId, instanceId, ts: baseTs + 100, perfTs: basePerfTs + 100 }),
              TestFramework.events.apiComplete("GET", "/api/init", { traceId, instanceId, duration: 200, ts: baseTs + 300, perfTs: basePerfTs + 300, response: { ready: true } }),
              TestFramework.events.stateChange("DataSource:initData", [
                { path: "DataSource:initData", before: undefined, after: { ready: true } }
              ], { traceId, componentType: "DataSource", instanceId, ts: baseTs + 310, perfTs: basePerfTs + 310 }),
              TestFramework.events.handlerStart("didChange", { traceId, ts: baseTs + 320, perfTs: basePerfTs + 320 }),
              TestFramework.events.handlerComplete("didChange", { traceId, duration: 20, ts: baseTs + 340, perfTs: basePerfTs + 340 }),
            ];
          },

          // Array diff scenario (items added/removed)
          arrayDiff() {
            const traceId = TestFramework.traceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            const instanceId = TestFramework.instanceId();
            return [
              TestFramework.events.handlerStart("loadChildren", { traceId, componentType: "Tree", componentLabel: "tree", ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.stateChange("DataSource:files", [
                { path: "value", before: [
                  { id: "1", name: "file1.txt", size: 1024 },
                  { id: "2", name: "file2.txt", size: 2048 },
                  { id: "3", name: "old-file.txt", size: 512 },
                ], after: [
                  { id: "1", name: "file1.txt", size: 1024 },
                  { id: "4", name: "new-file.txt", size: 4096 },
                  { id: "5", name: "another-new.txt", size: 8192 },
                ]}
              ], { traceId, componentType: "DataSource", instanceId, ts: baseTs + 50, perfTs: basePerfTs + 50 }),
              TestFramework.events.handlerComplete("loadChildren", { traceId, componentType: "Tree", componentLabel: "tree", duration: 54, ts: baseTs + 54, perfTs: basePerfTs + 54 }),
            ];
          },

          // Overlapping API requests (tests FIFO matching)
          overlappingApiRequests() {
            const traceId = TestFramework.traceId();
            const instanceId1 = TestFramework.instanceId();
            const instanceId2 = TestFramework.instanceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.handlerStart("refresh", { traceId, ts: baseTs, perfTs: basePerfTs }),
              // First request starts
              TestFramework.events.apiStart("GET", "/api/data", { traceId, instanceId: instanceId1, ts: baseTs + 5, perfTs: basePerfTs + 5 }),
              // Second request starts before first completes
              TestFramework.events.apiStart("GET", "/api/data", { traceId, instanceId: instanceId2, ts: baseTs + 10, perfTs: basePerfTs + 10 }),
              // First request completes
              TestFramework.events.apiComplete("GET", "/api/data", { traceId, instanceId: instanceId1, duration: 100, ts: baseTs + 105, perfTs: basePerfTs + 105 }),
              // Second request completes
              TestFramework.events.apiComplete("GET", "/api/data", { traceId, instanceId: instanceId2, duration: 150, ts: baseTs + 160, perfTs: basePerfTs + 160 }),
              TestFramework.events.handlerComplete("refresh", { traceId, duration: 165, ts: baseTs + 165, perfTs: basePerfTs + 165 }),
            ];
          },

          // Orphaned API complete (tests traceId inheritance)
          orphanedApiComplete() {
            const traceId = TestFramework.traceId();
            const instanceId = TestFramework.instanceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            // api:start has traceId, api:complete does not (simulating real scenario)
            return [
              TestFramework.events.handlerStart("fetch", { traceId, ts: baseTs, perfTs: basePerfTs }),
              { ...TestFramework.events.apiStart("GET", "/api/orphan-test", { instanceId, ts: baseTs + 5, perfTs: basePerfTs + 5 }), traceId },
              // This api:complete is missing traceId but has same instanceId
              TestFramework.events.apiComplete("GET", "/api/orphan-test", { instanceId, duration: 80, ts: baseTs + 85, perfTs: basePerfTs + 85 }),
              TestFramework.events.handlerComplete("fetch", { traceId, duration: 90, ts: baseTs + 90, perfTs: basePerfTs + 90 }),
            ];
          },

          // Duplicate state changes (tests deduplication)
          duplicateStateChanges() {
            const traceId = TestFramework.traceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.handlerStart("update", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.stateChange("AppState:counter", [
                { path: "counter", before: 0, after: 1 }
              ], { traceId, ts: baseTs + 5, perfTs: basePerfTs + 5 }),
              // Duplicate state change (same fingerprint)
              TestFramework.events.stateChange("AppState:counter", [
                { path: "counter", before: 0, after: 1 }
              ], { traceId, ts: baseTs + 6, perfTs: basePerfTs + 6 }),
              // Another duplicate
              TestFramework.events.stateChange("AppState:counter", [
                { path: "counter", before: 0, after: 1 }
              ], { traceId, ts: baseTs + 7, perfTs: basePerfTs + 7 }),
              TestFramework.events.handlerComplete("update", { traceId, duration: 10, ts: baseTs + 10, perfTs: basePerfTs + 10 }),
            ];
          },

          // Handler error scenario
          handlerError() {
            const traceId = TestFramework.traceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.handlerStart("processData", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerError("processData", new Error("Cannot read property 'foo' of undefined"), { traceId, ts: baseTs + 20, perfTs: basePerfTs + 20 }),
            ];
          },

          // Complex publish post scenario (based on Mastodon trace)
          publishPost() {
            const traceId = TestFramework.interactionTraceId();
            const instanceId = TestFramework.instanceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.interaction("click", "Publish Post", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerStart("click", { traceId, componentType: "Button", componentLabel: "Publish Post", ts: baseTs + 1, perfTs: basePerfTs + 1 }),
              TestFramework.events.stateChange("click Publish Post", [
                { path: "postContent", before: "@user test", after: "@user test6" }
              ], { traceId, ts: baseTs + 2, perfTs: basePerfTs + 2 }),
              TestFramework.events.handlerStart("beforeRequest", { traceId, componentType: "API", componentLabel: "publishPostAPI", ts: baseTs + 20, perfTs: basePerfTs + 20, handlerCode: "isPublishing = true" }),
              TestFramework.events.stateChange("beforeRequest publishPostAPI", [
                { path: "isPublishing", before: false, after: true }
              ], { traceId, ts: baseTs + 21, perfTs: basePerfTs + 21 }),
              TestFramework.events.handlerComplete("beforeRequest", { traceId, componentLabel: "publishPostAPI", duration: 24, ts: baseTs + 44, perfTs: basePerfTs + 44 }),
              TestFramework.events.apiStart("POST", "https://social.coop/api/v1/statuses", { traceId, instanceId, ts: baseTs + 45, perfTs: basePerfTs + 45, body: { status: "@user test6", visibility: "direct" } }),
              TestFramework.events.apiComplete("POST", "https://social.coop/api/v1/statuses", { traceId, instanceId, duration: 1414, ts: baseTs + 1459, perfTs: basePerfTs + 1459, response: { id: "115974768151239388", created_at: "2026-01-28T21:08:43.793Z" } }),
              TestFramework.events.handlerStart("success", { traceId, componentLabel: "publishPostAPI", ts: baseTs + 1460, perfTs: basePerfTs + 1460 }),
              TestFramework.events.stateChange("success publishPostAPI", [
                { path: "isPublishing", before: true, after: false }
              ], { traceId, ts: baseTs + 1461, perfTs: basePerfTs + 1461 }),
              TestFramework.events.stateChange("success publishPostAPI", [
                { path: "publishStatus", before: "", after: "Post published successfully!" }
              ], { traceId, ts: baseTs + 1475, perfTs: basePerfTs + 1475 }),
              TestFramework.events.stateChange("success publishPostAPI", [
                { path: "postContent", before: "@user test6", after: "" }
              ], { traceId, ts: baseTs + 1508, perfTs: basePerfTs + 1508 }),
              TestFramework.events.handlerComplete("success", { traceId, componentLabel: "publishPostAPI", duration: 72, ts: baseTs + 1532, perfTs: basePerfTs + 1532 }),
              TestFramework.events.handlerComplete("click", { traceId, componentType: "Button", componentLabel: "Publish Post", duration: 2689, ts: baseTs + 2690, perfTs: basePerfTs + 2690 }),
            ];
          },

          // Typeahead search with cancelled requests (AbortController pattern)
          // Based on Mastodon trace: rapid keystrokes trigger searches, earlier ones get aborted
          typeaheadSearch() {
            const instanceId = TestFramework.instanceId(); // Same DataSource instance reused
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            const events = [];

            // First keystroke: "w" - this request will complete
            const traceId1 = TestFramework.interactionTraceId();
            events.push(
              TestFramework.events.interaction("keydown", "TextBox", { traceId: traceId1, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerStart("didChange", { traceId: traceId1, componentType: "TextBox", componentLabel: "Enter search term...", ts: baseTs + 1, perfTs: basePerfTs + 1 }),
              TestFramework.events.stateChange("didChange Enter search term...", [
                { path: "query", before: "", after: "w" }
              ], { traceId: traceId1, ts: baseTs + 2, perfTs: basePerfTs + 2 }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId: traceId1, instanceId, ts: baseTs + 5, perfTs: basePerfTs + 5, body: { sql: "SELECT * FROM search WHERE term MATCH ?" } }),
            );

            // Second keystroke: "wa" - previous request gets aborted
            const traceId2 = TestFramework.interactionTraceId();
            events.push(
              TestFramework.events.interaction("keydown", "TextBox", { traceId: traceId2, ts: baseTs + 150, perfTs: basePerfTs + 150 }),
              TestFramework.events.handlerStart("didChange", { traceId: traceId2, componentType: "TextBox", componentLabel: "Enter search term...", ts: baseTs + 151, perfTs: basePerfTs + 151 }),
              TestFramework.events.stateChange("didChange Enter search term...", [
                { path: "query", before: "w", after: "wa" }
              ], { traceId: traceId2, ts: baseTs + 152, perfTs: basePerfTs + 152 }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId: traceId2, instanceId, ts: baseTs + 155, perfTs: basePerfTs + 155 }),
              // First request aborted
              TestFramework.events.apiError("POST", "/api/query", "signal is aborted without reason", { traceId: traceId1, instanceId, ts: baseTs + 156, perfTs: basePerfTs + 156 }),
            );

            // Third keystroke: "wal" - second request gets aborted
            const traceId3 = TestFramework.interactionTraceId();
            events.push(
              TestFramework.events.interaction("keydown", "TextBox", { traceId: traceId3, ts: baseTs + 300, perfTs: basePerfTs + 300 }),
              TestFramework.events.handlerStart("didChange", { traceId: traceId3, componentType: "TextBox", componentLabel: "Enter search term...", ts: baseTs + 301, perfTs: basePerfTs + 301 }),
              TestFramework.events.stateChange("didChange Enter search term...", [
                { path: "query", before: "wa", after: "wal" }
              ], { traceId: traceId3, ts: baseTs + 302, perfTs: basePerfTs + 302 }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId: traceId3, instanceId, ts: baseTs + 305, perfTs: basePerfTs + 305 }),
              // Second request aborted
              TestFramework.events.apiError("POST", "/api/query", "signal is aborted without reason", { traceId: traceId2, instanceId, ts: baseTs + 306, perfTs: basePerfTs + 306 }),
            );

            // Final request completes successfully
            events.push(
              TestFramework.events.apiComplete("POST", "/api/query", { traceId: traceId3, instanceId, duration: 48, ts: baseTs + 353, perfTs: basePerfTs + 353, response: [{ id: 1, text: "result" }] }),
              TestFramework.events.stateChange("DataSource:searchResults", [
                { path: "value", before: [], after: [{ id: 1, text: "result" }] }
              ], { traceId: traceId3, componentType: "DataSource", instanceId, ts: baseTs + 355, perfTs: basePerfTs + 355 }),
              // All handlers complete (long-spanning)
              TestFramework.events.handlerComplete("didChange", { traceId: traceId1, componentType: "TextBox", componentLabel: "Enter search term...", duration: 360, startPerfTs: basePerfTs + 1, ts: baseTs + 360, perfTs: basePerfTs + 360 }),
              TestFramework.events.handlerComplete("didChange", { traceId: traceId2, componentType: "TextBox", componentLabel: "Enter search term...", duration: 210, startPerfTs: basePerfTs + 151, ts: baseTs + 360, perfTs: basePerfTs + 360 }),
              TestFramework.events.handlerComplete("didChange", { traceId: traceId3, componentType: "TextBox", componentLabel: "Enter search term...", duration: 60, startPerfTs: basePerfTs + 301, ts: baseTs + 360, perfTs: basePerfTs + 360 }),
            );

            return events;
          },

          // Parallel API burst - multiple simultaneous requests (like post-publish refresh)
          parallelApiBurst() {
            const traceId = TestFramework.interactionTraceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            const instanceIds = Array.from({ length: 6 }, () => TestFramework.instanceId());

            return [
              TestFramework.events.interaction("click", "Refresh All", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerStart("click", { traceId, componentType: "Button", componentLabel: "Refresh All", ts: baseTs + 1, perfTs: basePerfTs + 1 }),
              // Six parallel API calls
              TestFramework.events.apiStart("POST", "/api/query", { traceId, instanceId: instanceIds[0], ts: baseTs + 5, perfTs: basePerfTs + 5, body: { sql: "SELECT * FROM config" } }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId, instanceId: instanceIds[1], ts: baseTs + 6, perfTs: basePerfTs + 6, body: { sql: "CREATE TABLE IF NOT EXISTS cache" } }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId, instanceId: instanceIds[2], ts: baseTs + 7, perfTs: basePerfTs + 7, body: { sql: "INSERT INTO cache SELECT * FROM source" } }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId, instanceId: instanceIds[3], ts: baseTs + 8, perfTs: basePerfTs + 8, body: { sql: "CREATE TABLE IF NOT EXISTS index" } }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId, instanceId: instanceIds[4], ts: baseTs + 9, perfTs: basePerfTs + 9, body: { sql: "INSERT INTO index SELECT * FROM data" } }),
              TestFramework.events.apiStart("GET", "/api/user/me", { traceId, instanceId: instanceIds[5], ts: baseTs + 10, perfTs: basePerfTs + 10 }),
              // Completions come back in different order
              TestFramework.events.apiComplete("POST", "/api/query", { traceId, instanceId: instanceIds[0], duration: 35, ts: baseTs + 40, perfTs: basePerfTs + 40 }),
              TestFramework.events.apiComplete("POST", "/api/query", { traceId, instanceId: instanceIds[1], duration: 34, ts: baseTs + 40, perfTs: basePerfTs + 40 }),
              TestFramework.events.apiComplete("POST", "/api/query", { traceId, instanceId: instanceIds[3], duration: 34, ts: baseTs + 42, perfTs: basePerfTs + 42 }),
              TestFramework.events.apiComplete("GET", "/api/user/me", { traceId, instanceId: instanceIds[5], duration: 280, ts: baseTs + 290, perfTs: basePerfTs + 290, response: { id: "user123", name: "Test User" } }),
              TestFramework.events.apiComplete("POST", "/api/query", { traceId, instanceId: instanceIds[2], duration: 295, ts: baseTs + 302, perfTs: basePerfTs + 302 }),
              TestFramework.events.apiComplete("POST", "/api/query", { traceId, instanceId: instanceIds[4], duration: 307, ts: baseTs + 316, perfTs: basePerfTs + 316 }),
              TestFramework.events.handlerComplete("click", { traceId, componentType: "Button", componentLabel: "Refresh All", duration: 320, ts: baseTs + 321, perfTs: basePerfTs + 321 }),
            ];
          },

          // Component vars init with many variables (like Compose panel)
          componentVarsInitComplex() {
            const traceId = TestFramework.interactionTraceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.interaction("click", "Compose", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.stateChange("DataSource:previousData", [
                { path: "value", before: [{ id: 1 }, { id: 2 }], after: [] }
              ], { traceId, componentType: "DataSource", ts: baseTs + 50, perfTs: basePerfTs + 50 }),
              TestFramework.events.componentVarsInit(
                ["postContent", "isPublishing", "publishStatus", "currentLength", "visibility", "visibilityOptions"],
                "Compose",
                {
                  traceId,
                  ts: baseTs + 97,
                  perfTs: basePerfTs + 97,
                  fileId: "http://localhost:8080/components/Compose.xmlui",
                  diffs: [
                    { path: "postContent", before: undefined, after: "" },
                    { path: "isPublishing", before: undefined, after: false },
                    { path: "publishStatus", before: undefined, after: "" },
                    { path: "currentLength", before: undefined, after: 0 },
                    { path: "visibility", before: undefined, after: "direct" },
                    { path: "visibilityOptions", before: undefined, after: [
                      { value: "public", label: "Public", description: "all", icon: "globe", enabled: true },
                      { value: "unlisted", label: "Unlisted", description: "all", icon: "unlock", enabled: true },
                      { value: "private", label: "Followers only", description: "followers", icon: "lock", enabled: true },
                      { value: "direct", label: "Direct", description: "mentioned", icon: "mail", enabled: true },
                    ]},
                  ],
                }
              ),
            ];
          },

          // Large array diff with many items added/removed (like search results changing)
          largeArrayDiff() {
            const traceId = TestFramework.traceId();
            const instanceId = TestFramework.instanceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            // Generate 30 IDs for before, 3 for after (simulating search refinement)
            const beforeIds = Array.from({ length: 30 }, (_, i) => `id-${1000 + i}`);
            const afterIds = ["id-1005", "id-1012", "id-1025"]; // 3 that remain
            return [
              TestFramework.events.handlerStart("didChange", { traceId, componentType: "TextBox", componentLabel: "Enter search term...", ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.stateChange("DataSource:searchResults", [
                {
                  path: "value",
                  before: beforeIds.map(id => ({ id, name: `Item ${id}` })),
                  after: afterIds.map(id => ({ id, name: `Item ${id}` })),
                }
              ], { traceId, componentType: "DataSource", instanceId, uid: "searchResults", ts: baseTs + 50, perfTs: basePerfTs + 50 }),
              TestFramework.events.handlerComplete("didChange", { traceId, componentType: "TextBox", componentLabel: "Enter search term...", duration: 55, ts: baseTs + 55, perfTs: basePerfTs + 55 }),
            ];
          },

          // Query execution with SQL and results (like Run Query button)
          sqlQueryExecution() {
            const traceId = TestFramework.interactionTraceId();
            const instanceId = TestFramework.instanceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.interaction("click", "Run Query", { traceId, ts: baseTs, perfTs: basePerfTs }),
              TestFramework.events.handlerStart("click", { traceId, componentType: "Button", componentLabel: "Run Query", ts: baseTs + 1, perfTs: basePerfTs + 1, fileId: "http://localhost:8080/components/Query.xmlui" }),
              TestFramework.events.stateChange("AppState:queryState", [
                { path: "loading", before: false, after: true },
                { path: "runSql", before: "", after: "SELECT count(*) as count FROM notifications" },
                { path: "nonce", before: 0, after: 1 },
              ], { traceId, ts: baseTs + 2, perfTs: basePerfTs + 2 }),
              TestFramework.events.apiStart("POST", "/api/query", { traceId, instanceId, ts: baseTs + 20, perfTs: basePerfTs + 20, body: { sql: "-- 1\nSELECT count(*) as count FROM notifications" } }),
              TestFramework.events.handlerComplete("click", { traceId, componentType: "Button", componentLabel: "Run Query", duration: 24, startPerfTs: basePerfTs + 1, ts: baseTs + 25, perfTs: basePerfTs + 25 }),
              TestFramework.events.apiComplete("POST", "/api/query", { traceId, instanceId, duration: 9, ts: baseTs + 29, perfTs: basePerfTs + 29, response: [{ count: 2351 }] }),
              TestFramework.events.stateChange("DataSource:queryResults", [
                { path: "DataSource:queryResults", before: undefined, after: [{ count: 2351 }] }
              ], { traceId, componentType: "DataSource", instanceId, uid: "queryResults", ts: baseTs + 30, perfTs: basePerfTs + 30 }),
              TestFramework.events.handlerStart("loaded", { traceId, componentLabel: "queryResults", ts: baseTs + 35, perfTs: basePerfTs + 35 }),
              TestFramework.events.stateChange("AppState:queryState", [
                { path: "loading", before: true, after: false },
                { path: "results", before: [], after: [{ count: 2351 }] },
              ], { traceId, ts: baseTs + 36, perfTs: basePerfTs + 36 }),
              TestFramework.events.handlerComplete("loaded", { traceId, componentLabel: "queryResults", duration: 1, startPerfTs: basePerfTs + 35, ts: baseTs + 36, perfTs: basePerfTs + 36 }),
            ];
          },

          // Tab/panel navigation clearing previous DataSource
          panelNavigation(fromPanel = "Home", toPanel = "Search") {
            const traceId = TestFramework.interactionTraceId();
            const baseTs = TestFramework.ts();
            const basePerfTs = TestFramework.perfTs();
            return [
              TestFramework.events.interaction("click", toPanel, { traceId, ts: baseTs, perfTs: basePerfTs }),
              // Previous panel's DataSource gets cleared
              TestFramework.events.stateChange("DataSource:homeData", [
                { path: "value", before: Array.from({ length: 50 }, (_, i) => ({ id: i })), after: [] }
              ], { traceId, componentType: "DataSource", uid: "homeData", ts: baseTs + 15, perfTs: basePerfTs + 15 }),
              // New panel initializes its variables
              TestFramework.events.componentVarsInit(
                ["query"],
                toPanel,
                {
                  traceId,
                  ts: baseTs + 30,
                  perfTs: basePerfTs + 30,
                  fileId: `http://localhost:8080/components/${toPanel}.xmlui`,
                  diffs: [{ path: "query", before: undefined, after: "" }],
                }
              ),
            ];
          },
        },
      };

      // Test runner
      async function runTests() {
        const container = document.getElementById("diff");
        container.innerHTML = '<div class="test-results"><h2>Running Tests...</h2></div>';

        const results = { suites: [], passed: 0, failed: 0 };

        // Helper to add test results
        function test(suiteName, testName, fn) {
          let suite = results.suites.find(s => s.name === suiteName);
          if (!suite) {
            suite = { name: suiteName, tests: [], passed: 0, failed: 0 };
            results.suites.push(suite);
          }
          try {
            fn();
            suite.tests.push({ name: testName, passed: true });
            suite.passed++;
            results.passed++;
          } catch (e) {
            suite.tests.push({ name: testName, passed: false, error: e.message });
            suite.failed++;
            results.failed++;
          }
        }

        function assertEqual(actual, expected, msg = "") {
          const actualStr = JSON.stringify(actual);
          const expectedStr = JSON.stringify(expected);
          if (actualStr !== expectedStr) {
            throw new Error(`${msg}\nExpected: ${expectedStr}\nActual: ${actualStr}`);
          }
        }

        function assertTrue(value, msg = "Expected true") {
          if (!value) throw new Error(msg);
        }

        function assertContains(str, substring, msg = "") {
          if (!str.includes(substring)) {
            throw new Error(`${msg}\nExpected "${str}" to contain "${substring}"`);
          }
        }

        function assertGreaterThan(actual, expected, msg = "") {
          if (!(actual > expected)) {
            throw new Error(`${msg}\nExpected ${actual} > ${expected}`);
          }
        }

        // =========================================================================
        // TEST SUITE: Event Generation
        // =========================================================================
        test("Event Generation", "generates valid interaction event", () => {
          const evt = TestFramework.events.interaction("click", "TestButton");
          assertEqual(evt.kind, "interaction");
          assertEqual(evt.interaction, "click");
          assertEqual(evt.componentLabel, "TestButton");
          assertTrue(evt.ts > 0, "Should have timestamp");
          assertTrue(evt.perfTs > 0, "Should have perfTs");
        });

        test("Event Generation", "generates valid handler:start event", () => {
          const evt = TestFramework.events.handlerStart("onClick", { componentLabel: "MyButton" });
          assertEqual(evt.kind, "handler:start");
          assertEqual(evt.eventName, "onClick");
          assertEqual(evt.componentLabel, "MyButton");
          assertTrue(evt.traceId.startsWith("t-"), "Should have trace ID");
        });

        test("Event Generation", "generates valid api:start event", () => {
          const evt = TestFramework.events.apiStart("POST", "/api/test", { body: { foo: "bar" } });
          assertEqual(evt.kind, "api:start");
          assertEqual(evt.method, "POST");
          assertEqual(evt.url, "/api/test");
          assertTrue(evt.instanceId.startsWith("ds-"), "Should have instance ID");
        });

        test("Event Generation", "generates valid state:changes event", () => {
          const evt = TestFramework.events.stateChange("AppState:test", [
            { path: "value", before: 1, after: 2 }
          ]);
          assertEqual(evt.kind, "state:changes");
          assertEqual(evt.diffJson.length, 1);
          assertEqual(evt.diffJson[0].before, 1);
          assertEqual(evt.diffJson[0].after, 2);
        });

        // =========================================================================
        // TEST SUITE: Scenario Generation
        // =========================================================================
        test("Scenario Generation", "buttonClick generates correct event sequence", () => {
          const events = TestFramework.scenarios.buttonClick();
          assertEqual(events.length, 4);
          assertEqual(events[0].kind, "interaction");
          assertEqual(events[1].kind, "handler:start");
          assertEqual(events[2].kind, "state:changes");
          assertEqual(events[3].kind, "handler:complete");
          // All should share same traceId
          const traceId = events[0].traceId;
          assertTrue(events.every(e => e.traceId === traceId), "All events should share traceId");
        });

        test("Scenario Generation", "apiRequest generates API flow with matching instanceIds", () => {
          const events = TestFramework.scenarios.apiRequest("GET", "/api/users");
          const apiStart = events.find(e => e.kind === "api:start");
          const apiComplete = events.find(e => e.kind === "api:complete");
          assertTrue(apiStart, "Should have api:start");
          assertTrue(apiComplete, "Should have api:complete");
          assertEqual(apiStart.instanceId, apiComplete.instanceId);
          assertEqual(apiStart.url, "/api/users");
        });

        test("Scenario Generation", "startup generates startup trace pattern", () => {
          const events = TestFramework.scenarios.startup();
          assertTrue(events[0].traceId.startsWith("startup-"), "Should have startup- prefix");
          const hasVarsInit = events.some(e => e.kind === "component:vars:init");
          assertTrue(hasVarsInit, "Should have component:vars:init");
        });

        test("Scenario Generation", "overlappingApiRequests generates two API pairs", () => {
          const events = TestFramework.scenarios.overlappingApiRequests();
          const apiStarts = events.filter(e => e.kind === "api:start");
          const apiCompletes = events.filter(e => e.kind === "api:complete");
          assertEqual(apiStarts.length, 2);
          assertEqual(apiCompletes.length, 2);
          // Instance IDs should be different
          assertTrue(apiStarts[0].instanceId !== apiStarts[1].instanceId, "Instance IDs should differ");
        });

        // =========================================================================
        // TEST SUITE: Entry Processing
        // =========================================================================
        test("Entry Processing", "normalizeEntry handles string input", () => {
          const result = normalizeEntry("test message");
          assertEqual(result.kind, "log");
          assertEqual(result.text, "test message");
        });

        test("Entry Processing", "normalizeEntry preserves object entries", () => {
          const input = { kind: "test", eventName: "foo", ts: 123 };
          const result = normalizeEntry(input);
          assertEqual(result.kind, "test");
          assertEqual(result.eventName, "foo");
        });

        test("Entry Processing", "entryMatches filters Inspector events", () => {
          const inspectorEvt = { kind: "test", componentLabel: "Inspector" };
          assertTrue(!entryMatches(inspectorEvt, ""), "Should filter Inspector");
        });

        test("Entry Processing", "entryMatches filters vite-error-overlay", () => {
          const viteEvt = { kind: "test", componentType: "vite-error-overlay" };
          assertTrue(!entryMatches(viteEvt, ""), "Should filter vite events");
        });

        // =========================================================================
        // TEST SUITE: Trace Processing
        // =========================================================================
        test("Trace Processing", "processAllEntries groups events by traceId", () => {
          const events = TestFramework.scenarios.buttonClick();
          const processed = processAllEntries(events);
          assertEqual(processed.timelineItems.length, 1);
          assertEqual(processed.timelineItems[0].type, "trace");
        });

        test("Trace Processing", "processAllEntries handles multiple traces", () => {
          const events1 = TestFramework.scenarios.buttonClick();
          const events2 = TestFramework.scenarios.navigation();
          const allEvents = [...events1, ...events2];
          const processed = processAllEntries(allEvents);
          assertEqual(processed.timelineItems.length, 2);
        });

        test("Trace Processing", "api:complete without traceId matches api:start by timing and inherits traceId", () => {
          // Scenario: api:start has traceId, api:complete does not
          // The api:complete should match by timing and inherit api:start's traceId
          const events = TestFramework.scenarios.orphanedApiComplete();
          const processed = processAllEntries(events);
          // Should be one trace containing all events
          assertEqual(processed.timelineItems.length, 1);
          const trace = processed.timelineItems[0];
          // Should have both api:start and api:complete (matched by timing)
          const hasApiStart = trace.events.some(e => e.entry.kind === "api:start");
          const hasApiComplete = trace.events.some(e => e.entry.kind === "api:complete");
          assertTrue(hasApiStart, "Trace should contain api:start");
          assertTrue(hasApiComplete, "Trace should contain api:complete (matched by timing, inherited traceId)");
        });

        test("Trace Processing", "api:complete should not inherit traceId from later api:start", () => {
          // Scenario: api:start A (no traceId) -> api:complete A -> api:start B (has traceId)
          // Bug was: api:complete A would get api:start B's traceId because pre-pass uses LAST
          const instanceId = TestFramework.instanceId();
          const traceIdB = TestFramework.traceId();
          const baseTs = 1000;
          const events = [
            // First request - no traceId (orphaned)
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, perfTs: baseTs },
            { kind: "api:complete", method: "GET", url: "/api/data", instanceId, perfTs: baseTs + 50 },
            // Second request - has traceId (from later interaction)
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, traceId: traceIdB, perfTs: baseTs + 200 },
            { kind: "api:complete", method: "GET", url: "/api/data", instanceId, traceId: traceIdB, perfTs: baseTs + 250 },
          ];
          processAllEntries(events);
          // First api:complete should NOT have traceIdB (it happened before that trace existed)
          const firstComplete = events[1];
          assertTrue(firstComplete.traceId !== traceIdB, "First api:complete should not inherit traceId from later api:start");
        });

        test("Trace Processing", "processAllEntries separates standalone interactions", () => {
          const standaloneInteraction = TestFramework.events.interaction("click", "Orphan");
          delete standaloneInteraction.traceId;
          const processed = processAllEntries([standaloneInteraction]);
          const interactions = processed.timelineItems.filter(i => i.type === "interaction");
          assertEqual(interactions.length, 1);
        });

        test("Trace Processing", "processAllEntries assigns unique requestIds to API events", () => {
          const events = TestFramework.scenarios.typeaheadSearch();
          processAllEntries(events); // This mutates events to add _requestId
          const apiStarts = events.filter(e => e.kind === "api:start");
          const apiErrors = events.filter(e => e.kind === "api:error");
          const apiCompletes = events.filter(e => e.kind === "api:complete");
          // All api:start events should have unique requestIds
          const startRequestIds = apiStarts.map(e => e._requestId);
          assertTrue(startRequestIds.every(id => id), "All api:start should have _requestId");
          assertEqual(new Set(startRequestIds).size, apiStarts.length, "All requestIds should be unique");
          // Errors and completes should have matching requestIds
          apiErrors.forEach(e => assertTrue(e._requestId, "api:error should have _requestId"));
          apiCompletes.forEach(e => assertTrue(e._requestId, "api:complete should have _requestId"));
        });

        test("Trace Processing", "out-of-order api:completes matched correctly by perfTs", () => {
          // Scenario: Two overlapping requests, but api:completes arrive in array in wrong order
          // api:start A at t=100, api:start B at t=200
          // api:complete B at t=250 (appears first in array)
          // api:complete A at t=300 (appears second in array)
          // Without sorting, A's completion would match B's start (wrong!)
          const instanceId = TestFramework.instanceId();
          const traceId = TestFramework.traceId();
          const events = [
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, traceId, perfTs: 100 },
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, traceId, perfTs: 200 },
            // Note: completes are in WRONG order in array (later completion first)
            { kind: "api:complete", method: "GET", url: "/api/data", instanceId, traceId, perfTs: 300 },
            { kind: "api:complete", method: "GET", url: "/api/data", instanceId, traceId, perfTs: 250 },
          ];
          processAllEntries(events);
          // Find the api:starts and their matched completes
          const start100 = events.find(e => e.kind === "api:start" && e.perfTs === 100);
          const start200 = events.find(e => e.kind === "api:start" && e.perfTs === 200);
          const complete250 = events.find(e => e.kind === "api:complete" && e.perfTs === 250);
          const complete300 = events.find(e => e.kind === "api:complete" && e.perfTs === 300);
          // complete at 250 should match start at 200 (started before 250, closest)
          assertEqual(complete250._requestId, start200._requestId, "Complete at 250 should match start at 200");
          // complete at 300 should match start at 100 (only one left)
          assertEqual(complete300._requestId, start100._requestId, "Complete at 300 should match start at 100");
        });

        test("Trace Processing", "requestIds link api:start to api:complete/error correctly", () => {
          const events = TestFramework.scenarios.typeaheadSearch();
          processAllEntries(events);
          // Find api:start and its corresponding api:error for first aborted request
          const firstStart = events.find(e => e.kind === "api:start");
          const matchingError = events.find(e => e.kind === "api:error" && e._requestId === firstStart._requestId);
          assertTrue(matchingError, "First api:start should have matching api:error with same requestId");
          assertTrue(matchingError.error.includes("signal is aborted"), "Matched error should be abort error");
        });

        test("Trace Processing", "method case normalization - lowercase get matches uppercase GET", () => {
          const traceId = TestFramework.traceId();
          const instanceId = TestFramework.instanceId();
          const baseTs = 1000;
          const events = [
            { kind: "api:start", method: "get", url: "/api/test", instanceId, traceId, perfTs: baseTs },
            { kind: "api:complete", method: "GET", url: "/api/test", instanceId, traceId, perfTs: baseTs + 50 },
          ];
          processAllEntries(events);
          const apiStart = events.find(e => e.kind === "api:start");
          const apiComplete = events.find(e => e.kind === "api:complete");
          assertEqual(apiStart._requestId, apiComplete._requestId, "Lowercase get should match uppercase GET");
        });

        test("Trace Processing", "timing-based matching - most recent api:start matches completion", () => {
          const traceId = TestFramework.traceId();
          const instanceId = TestFramework.instanceId();
          const baseTs = 1000;
          // Two requests to same URL, second one completes
          const events = [
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, traceId, perfTs: baseTs },
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, traceId, perfTs: baseTs + 100 },
            { kind: "api:complete", method: "GET", url: "/api/data", instanceId, traceId, perfTs: baseTs + 150 },
          ];
          processAllEntries(events);
          const apiStarts = events.filter(e => e.kind === "api:start");
          const apiComplete = events.find(e => e.kind === "api:complete");
          // Should match the second (more recent) api:start, not the first
          assertEqual(apiComplete._requestId, apiStarts[1]._requestId, "Should match most recent api:start");
        });

        test("Trace Processing", "traceId matching - completion matches start with same traceId", () => {
          const traceId1 = TestFramework.traceId();
          const traceId2 = TestFramework.traceId();
          const instanceId = TestFramework.instanceId();
          const baseTs = 1000;
          // Two requests from different traces to same URL
          const events = [
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, traceId: traceId1, perfTs: baseTs },
            { kind: "api:start", method: "GET", url: "/api/data", instanceId, traceId: traceId2, perfTs: baseTs + 50 },
            { kind: "api:complete", method: "GET", url: "/api/data", instanceId, traceId: traceId1, perfTs: baseTs + 100 },
          ];
          processAllEntries(events);
          const start1 = events.find(e => e.kind === "api:start" && e.traceId === traceId1);
          const apiComplete = events.find(e => e.kind === "api:complete");
          assertEqual(apiComplete._requestId, start1._requestId, "Should match api:start with same traceId");
        });

        test("Trace Processing", "idempotent reprocessing - double processing preserves requestIds", () => {
          const events = TestFramework.scenarios.apiRequest();
          processAllEntries(events);
          const apiStart = events.find(e => e.kind === "api:start");
          const apiComplete = events.find(e => e.kind === "api:complete");
          const originalStartId = apiStart._requestId;
          const originalCompleteId = apiComplete._requestId;
          // Process again
          processAllEntries(events);
          assertEqual(apiStart._requestId, originalStartId, "api:start requestId should not change on reprocessing");
          assertEqual(apiComplete._requestId, originalCompleteId, "api:complete requestId should not change on reprocessing");
          assertEqual(apiStart._requestId, apiComplete._requestId, "Should still match after reprocessing");
        });

        // =========================================================================
        // TEST SUITE: Timeline Calculation
        // =========================================================================
        test("Timeline Calculation", "buildTraceSummary calculates total duration", () => {
          const events = TestFramework.scenarios.buttonClick();
          const summary = buildTraceSummary(events);
          assertTrue(summary.totalDuration !== null, "Should calculate duration");
          assertGreaterThan(summary.totalDuration, 0, "Duration should be positive");
        });

        test("Timeline Calculation", "buildTraceSummary detects startup traces", () => {
          const events = TestFramework.scenarios.startup();
          const summary = buildTraceSummary(events);
          assertEqual(summary.componentText, "Startup");
        });

        test("Timeline Calculation", "buildTraceSummary builds timeline breakdown", () => {
          const events = TestFramework.scenarios.publishPost();
          const summary = buildTraceSummary(events);
          assertTrue(summary.timelineBreakdown.length > 0, "Should have timeline breakdown");
        });

        // =========================================================================
        // TEST SUITE: State Change Formatting
        // =========================================================================
        test("State Change Formatting", "analyzeArrayDiff detects added items", () => {
          const before = [{ id: "1", name: "a" }];
          const after = [{ id: "1", name: "a" }, { id: "2", name: "b" }];
          const analysis = analyzeArrayDiff(before, after);
          assertEqual(analysis.added.length, 1);
          assertEqual(analysis.removed.length, 0);
          assertEqual(analysis.beforeCount, 1);
          assertEqual(analysis.afterCount, 2);
        });

        test("State Change Formatting", "analyzeArrayDiff detects removed items", () => {
          const before = [{ id: "1", name: "a" }, { id: "2", name: "b" }];
          const after = [{ id: "1", name: "a" }];
          const analysis = analyzeArrayDiff(before, after);
          assertEqual(analysis.added.length, 0);
          assertEqual(analysis.removed.length, 1);
        });

        test("State Change Formatting", "analyzeArrayDiff detects modified items", () => {
          const before = [{ id: "1", name: "old" }];
          const after = [{ id: "1", name: "new" }];
          const analysis = analyzeArrayDiff(before, after);
          assertEqual(analysis.changed.length, 1);
        });

        test("State Change Formatting", "formatFileSize formats bytes correctly", () => {
          assertEqual(formatFileSize(0), "0 B");
          assertEqual(formatFileSize(1024), "1 KB");
          assertEqual(formatFileSize(1048576), "1 MB");
          assertEqual(formatFileSize(5242880), "5 MB");
        });

        test("State Change Formatting", "getItemLabel extracts name with size", () => {
          const item = { name: "test.txt", size: 1024 };
          const label = getItemLabel(item);
          assertContains(label, "test.txt");
          assertContains(label, "1 KB");
        });

        // =========================================================================
        // TEST SUITE: Deduplication
        // =========================================================================
        test("Deduplication", "fingerprintStateChange creates unique fingerprint", () => {
          const evt = TestFramework.events.stateChange("test", [
            { path: "x", before: 1, after: 2 }
          ]);
          const fp = fingerprintStateChange(evt);
          assertTrue(fp.length > 0, "Should create fingerprint");
        });

        test("Deduplication", "identical state changes have same fingerprint", () => {
          const evt1 = TestFramework.events.stateChange("test", [{ path: "x", before: 1, after: 2 }]);
          const evt2 = TestFramework.events.stateChange("test", [{ path: "x", before: 1, after: 2 }]);
          assertEqual(fingerprintStateChange(evt1), fingerprintStateChange(evt2));
        });

        test("Deduplication", "isNoopStateChange detects no-op", () => {
          const noop = { diffJson: [{ before: { a: 1 }, after: { a: 1 } }] };
          assertTrue(isNoopStateChange(noop), "Should detect no-op");
          const real = { diffJson: [{ before: { a: 1 }, after: { a: 2 } }] };
          assertTrue(!isNoopStateChange(real), "Should not detect real change as no-op");
        });

        test("Deduplication", "processTraceEvents deduplicates repeated state changes", () => {
          const events = TestFramework.scenarios.duplicateStateChanges();
          const { events: processedEvents, dedupedCount } = processTraceEvents(events);
          assertTrue(dedupedCount > 0, "Should have deduped some events");
          assertGreaterThan(events.length, processedEvents.length, "Processed should be shorter");
        });

        test("Deduplication", "fingerprintApiCall creates fingerprint for api:start", () => {
          const evt = { kind: "api:start", method: "GET", url: "/status" };
          const fp = fingerprintApiCall(evt);
          assertEqual(fp, "GET|/status");
        });

        test("Deduplication", "fingerprintApiCall includes response for api:complete", () => {
          const evt = { kind: "api:complete", method: "GET", url: "/status", response: { ok: true } };
          const fp = fingerprintApiCall(evt);
          assertTrue(fp.includes("GET|/status|"), "Should include method and url");
          assertTrue(fp.includes("ok"), "Should include response");
        });

        test("Deduplication", "identical api:complete events have same fingerprint", () => {
          const evt1 = { kind: "api:complete", method: "GET", url: "/status", response: { count: 5 } };
          const evt2 = { kind: "api:complete", method: "GET", url: "/status", response: { count: 5 } };
          assertEqual(fingerprintApiCall(evt1), fingerprintApiCall(evt2));
        });

        test("Deduplication", "different api:complete responses have different fingerprints", () => {
          const evt1 = { kind: "api:complete", method: "GET", url: "/status", response: { count: 5 } };
          const evt2 = { kind: "api:complete", method: "GET", url: "/status", response: { count: 6 } };
          assertTrue(fingerprintApiCall(evt1) !== fingerprintApiCall(evt2), "Different responses should have different fingerprints");
        });

        test("Deduplication", "processTraceEvents deduplicates repeated API calls", () => {
          const traceId = "test-api-dedupe";
          const events = [
            { kind: "api:start", method: "GET", url: "/status", traceId, perfTs: 100 },
            { kind: "api:complete", method: "GET", url: "/status", response: { ok: true }, traceId, perfTs: 150 },
            { kind: "api:start", method: "GET", url: "/status", traceId, perfTs: 200 },
            { kind: "api:complete", method: "GET", url: "/status", response: { ok: true }, traceId, perfTs: 250 },
            { kind: "api:start", method: "GET", url: "/status", traceId, perfTs: 300 },
            { kind: "api:complete", method: "GET", url: "/status", response: { ok: true }, traceId, perfTs: 350 },
          ];
          const { events: processedEvents, dedupedCount } = processTraceEvents(events);
          assertTrue(dedupedCount > 0, "Should have deduped some API events");
          // Should have 2 events (1 api:start + 1 api:complete, each with _dedupCount: 3)
          assertEqual(processedEvents.length, 2, "Should collapse to 2 events");
          const apiStart = processedEvents.find(e => e.entry.kind === "api:start");
          const apiComplete = processedEvents.find(e => e.entry.kind === "api:complete");
          assertEqual(apiStart.entry._dedupCount, 3, "api:start should have count 3");
          assertEqual(apiComplete.entry._dedupCount, 3, "api:complete should have count 3");
        });

        test("Deduplication", "handler events from same file with same code are deduplicated", () => {
          const traceId = "test-handler-dedupe-same";
          const events = [
            { kind: "handler:start", eventName: "messageReceived", code: "(msg) => {}", uid: "comp1", ownerFileId: 0, traceId, perfTs: 100 },
            { kind: "handler:start", eventName: "messageReceived", code: "(msg) => {}", uid: "comp1", ownerFileId: 0, traceId, perfTs: 101 },
            { kind: "handler:complete", eventName: "messageReceived", code: "(msg) => {}", uid: "comp1", ownerFileId: 0, traceId, perfTs: 102 },
            { kind: "handler:complete", eventName: "messageReceived", code: "(msg) => {}", uid: "comp1", ownerFileId: 0, traceId, perfTs: 103 },
          ];
          const { events: processedEvents } = processTraceEvents(events);
          // Should collapse to 2 events (1 handler:start + 1 handler:complete with _dedupCount: 2 each)
          assertEqual(processedEvents.length, 2, "Should collapse same-file handlers");
          const start = processedEvents.find(e => e.entry.kind === "handler:start");
          const complete = processedEvents.find(e => e.entry.kind === "handler:complete");
          assertEqual(start.entry._dedupCount, 2, "handler:start should have count 2");
          assertEqual(complete.entry._dedupCount, 2, "handler:complete should have count 2");
        });

        test("Deduplication", "handler events from different files are NOT deduplicated", () => {
          const traceId = "test-handler-dedupe-files";
          const events = [
            { kind: "handler:start", eventName: "messageReceived", arrow: "(msg) => {", uid: "", ownerFileId: 0, traceId, perfTs: 100 },
            { kind: "handler:start", eventName: "messageReceived", arrow: "(msg) => {", uid: "", ownerFileId: 1, traceId, perfTs: 101 },
            { kind: "handler:start", eventName: "messageReceived", arrow: "(msg) => {", uid: "", ownerFileId: 2, traceId, perfTs: 102 },
          ];
          const { events: processedEvents } = processTraceEvents(events);
          // Should NOT collapse - each file should be separate
          const handlerStarts = processedEvents.filter(e => e.entry.kind === "handler:start");
          assertEqual(handlerStarts.length, 3, "Handlers from different files should remain separate");
        });

        test("Deduplication", "handler events with different componentIds are NOT deduplicated", () => {
          const traceId = "test-handler-dedupe-components";
          const events = [
            { kind: "handler:start", eventName: "messageReceived", code: "(msg) => handle(msg)", uid: "filesContainer", ownerFileId: 3, traceId, perfTs: 100 },
            { kind: "handler:start", eventName: "messageReceived", code: "(msg) => handle(msg)", uid: "foldersTree", ownerFileId: 3, traceId, perfTs: 101 },
          ];
          const { events: processedEvents } = processTraceEvents(events);
          // Should NOT collapse - different component IDs
          const handlerStarts = processedEvents.filter(e => e.entry.kind === "handler:start");
          assertEqual(handlerStarts.length, 2, "Handlers from different components should remain separate");
        });

        test("Deduplication", "handler events with different code are NOT deduplicated", () => {
          const traceId = "test-handler-dedupe-code";
          const events = [
            { kind: "handler:start", eventName: "messageReceived", code: "(msg) => handleFileOperation(msg)", uid: "", ownerFileId: 0, traceId, perfTs: 100 },
            { kind: "handler:start", eventName: "messageReceived", arrow: "(msg) => {", uid: "", ownerFileId: 0, traceId, perfTs: 101 },
          ];
          const { events: processedEvents } = processTraceEvents(events);
          // Should NOT collapse - different code
          const handlerStarts = processedEvents.filter(e => e.entry.kind === "handler:start");
          assertEqual(handlerStarts.length, 2, "Handlers with different code should remain separate");
        });

        // =========================================================================
        // TEST SUITE: Function Source Lookup
        // =========================================================================
        test("Function Source Lookup", "extractFunctionCalls finds standalone function calls", () => {
          const code = "ev => {reselectAndOpenMenu(ev, $item)}";
          const funcs = extractFunctionCalls(code);
          assertEqual(funcs.length, 1);
          assertEqual(funcs[0], "reselectAndOpenMenu");
        });

        test("Function Source Lookup", "extractFunctionCalls excludes method calls", () => {
          const code = "appState.update({ fileCatalogDataRef: fileCatalogData })";
          const funcs = extractFunctionCalls(code);
          // Should not include 'update' since it's a method call (preceded by .)
          assertTrue(!funcs.includes("update"), "Should not extract method calls");
        });

        test("Function Source Lookup", "extractFunctionCalls excludes built-ins", () => {
          const code = "console.log('test'); setTimeout(() => fetch('/api'), 100)";
          const funcs = extractFunctionCalls(code);
          assertTrue(!funcs.includes("console"), "Should not extract console");
          assertTrue(!funcs.includes("log"), "Should not extract log (method)");
          assertTrue(!funcs.includes("setTimeout"), "Should not extract setTimeout");
          assertTrue(!funcs.includes("fetch"), "Should not extract fetch");
        });

        test("Function Source Lookup", "extractFunctionCalls handles multiple functions", () => {
          const code = "handleClick(ev); processData(items); updateUI()";
          const funcs = extractFunctionCalls(code);
          assertEqual(funcs.length, 3);
          assertTrue(funcs.includes("handleClick"));
          assertTrue(funcs.includes("processData"));
          assertTrue(funcs.includes("updateUI"));
        });

        test("Function Source Lookup", "extractFunctionCalls handles simple function reference", () => {
          // When handler code is just a function name (e.g., code: onTreeSelectionDidChange)
          const code = "onTreeSelectionDidChange";
          const funcs = extractFunctionCalls(code);
          assertEqual(funcs.length, 1);
          assertEqual(funcs[0], "onTreeSelectionDidChange");
        });

        test("Action Source Lookup", "extractActionReferences finds .execute() calls", () => {
          const code = "updateFollowersBackground.execute()";
          const actions = extractActionReferences(code);
          assertEqual(actions.length, 1);
          assertEqual(actions[0], "updateFollowersBackground");
        });

        test("Action Source Lookup", "extractActionReferences finds .execute() with args", () => {
          const code = "myAction.execute({ foo: 'bar' })";
          const actions = extractActionReferences(code);
          assertEqual(actions.length, 1);
          assertEqual(actions[0], "myAction");
        });

        test("Action Source Lookup", "extractActionReferences finds multiple actions", () => {
          const code = "actionA.execute(); doSomething(); actionB.execute()";
          const actions = extractActionReferences(code);
          assertEqual(actions.length, 2);
          assertTrue(actions.includes("actionA"));
          assertTrue(actions.includes("actionB"));
        });

        test("Action Source Lookup", "extractActionReferences excludes this.execute", () => {
          const code = "this.execute()";
          const actions = extractActionReferences(code);
          assertEqual(actions.length, 0);
        });

        test("Action Source Lookup", "findActionInSource finds Action component", () => {
          const source = `
            <App>
              <Action id="myAction" onExecute="doSomething()" />
              <Button onClick="myAction.execute()">Run</Button>
            </App>
          `;
          const result = findActionInSource(source, "myAction", "test.xmlui");
          assertTrue(result !== null, "Should find the Action");
          assertContains(result.source, '<Action id="myAction"');
          assertContains(result.source, 'onExecute="doSomething()"');
        });

        test("Action Source Lookup", "findActionInSource finds multi-line Action", () => {
          const source = `
            <App>
              <Action
                id="updateFollowers"
                onExecute="fetchFollowers()"
              />
              <Timer onTick="updateFollowers.execute()" />
            </App>
          `;
          const result = findActionInSource(source, "updateFollowers", "test.xmlui");
          assertTrue(result !== null, "Should find the multi-line Action");
          assertContains(result.source, 'id="updateFollowers"');
          assertContains(result.source, 'onExecute="fetchFollowers()"');
        });

        test("Function Source Lookup", "findFunctionInSource finds function declaration", () => {
          const source = `
            const helper = () => {};
            function myHandler(ev, item) {
              console.log(ev);
              return item;
            }
            const other = 1;
          `;
          const result = findFunctionInSource(source, "myHandler", "test.xmlui");
          assertTrue(result !== null, "Should find the function");
          assertContains(result.source, "function myHandler");
          assertContains(result.source, "return item");
          assertEqual(result.location, "test.xmlui:3");
        });

        test("Function Source Lookup", "findFunctionInSource finds const arrow function", () => {
          const source = `
            const myFunc = (a, b) => {
              return a + b;
            };
          `;
          const result = findFunctionInSource(source, "myFunc", "test.xs");
          assertTrue(result !== null, "Should find const arrow function");
          assertContains(result.source, "const myFunc");
          assertContains(result.source, "return a + b");
        });

        test("Function Source Lookup", "findFunctionInSource finds async function", () => {
          const source = `
            async function fetchData(url) {
              const resp = await fetch(url);
              return resp.json();
            }
          `;
          const result = findFunctionInSource(source, "fetchData", "api.xs");
          assertTrue(result !== null, "Should find async function");
          assertContains(result.source, "async function fetchData");
        });

        test("Function Source Lookup", "findFunctionInSource finds export function", () => {
          const source = `
            export function processItems(items) {
              return items.map(i => i.id);
            }
          `;
          const result = findFunctionInSource(source, "processItems", "utils.xs");
          assertTrue(result !== null, "Should find exported function");
          assertContains(result.source, "export function processItems");
        });

        test("Function Source Lookup", "findFunctionInSource returns null for missing function", () => {
          const source = `
            function otherFunc() {}
            const anotherFunc = () => {};
          `;
          const result = findFunctionInSource(source, "notHere", "test.xs");
          assertEqual(result, null, "Should return null for missing function");
        });

        test("Function Source Lookup", "findFunctionInSource handles nested braces", () => {
          const source = `
            function complexHandler(data) {
              if (data.items) {
                data.items.forEach(item => {
                  if (item.active) {
                    process(item);
                  }
                });
              }
              return true;
            }
          `;
          const result = findFunctionInSource(source, "complexHandler", "test.xs");
          assertTrue(result !== null, "Should find function with nested braces");
          assertContains(result.source, "return true");
          // Should include the full function, not cut off early
          const openBraces = (result.source.match(/\{/g) || []).length;
          const closeBraces = (result.source.match(/\}/g) || []).length;
          assertEqual(openBraces, closeBraces, "Braces should be balanced");
        });

        // =========================================================================
        // TEST SUITE: XMLUI Parser Integration
        // =========================================================================
        test("XMLUI Parser", "XmluiSource parses valid XMLUI markup", () => {
          const source = `<App><Button id="btn">Click</Button></App>`;
          const xmlui = new XmluiSource(source, "test.xmlui");
          assertEqual(xmlui.errors.length, 0, "Should have no parse errors");
          assertTrue(xmlui.ast !== null, "Should have AST");
        });

        test("XMLUI Parser", "XmluiSource.findById finds element by id", () => {
          const source = `
            <App>
              <Button id="submitBtn" variant="primary">Submit</Button>
              <Button id="cancelBtn" variant="secondary">Cancel</Button>
            </App>
          `;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const btn = xmlui.findById("submitBtn");
          assertTrue(btn !== null, "Should find submitBtn");
          assertEqual(btn.tagName, "Button");
          assertEqual(btn.attributes.id, "submitBtn");
          assertEqual(btn.attributes.variant, "primary");
        });

        test("XMLUI Parser", "XmluiSource.findById returns null for missing id", () => {
          const source = `<App><Button id="exists">Click</Button></App>`;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const result = xmlui.findById("notHere");
          assertEqual(result, null, "Should return null for missing id");
        });

        test("XMLUI Parser", "XmluiSource.findHandler finds specific handler on element", () => {
          const source = `
            <App>
              <Button id="myBtn" onClick="handleClick" onHover="handleHover">Click</Button>
            </App>
          `;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const handler = xmlui.findHandler("myBtn", "Click");
          assertTrue(handler !== null, "Should find onClick handler");
          assertEqual(handler.key, "onClick");
          assertEqual(handler.value, "handleClick");
          assertTrue(handler.line > 0, "Should have line number");
        });

        test("XMLUI Parser", "XmluiSource.findHandler returns null for missing handler", () => {
          const source = `<App><Button id="btn" onClick="doThing">Click</Button></App>`;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const result = xmlui.findHandler("btn", "Submit");
          assertEqual(result, null, "Should return null for missing handler");
        });

        test("XMLUI Parser", "XmluiSource.findHandlers finds all handlers of event type", () => {
          const source = `
            <App>
              <Button id="btn1" onClick="handler1">One</Button>
              <Button id="btn2" onClick="handler2" onHover="hover2">Two</Button>
              <Action id="action" onExecute="doAction" />
            </App>
          `;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const clickHandlers = xmlui.findHandlers("Click");
          assertEqual(clickHandlers.length, 2, "Should find 2 onClick handlers");
          assertTrue(clickHandlers.some(h => h.value === "handler1"), "Should include handler1");
          assertTrue(clickHandlers.some(h => h.value === "handler2"), "Should include handler2");
        });

        test("XMLUI Parser", "XmluiSource.findHandlers finds all handlers when no event specified", () => {
          const source = `
            <App>
              <Button id="btn" onClick="click" onHover="hover">Click</Button>
              <Action id="act" onExecute="exec" />
            </App>
          `;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const allHandlers = xmlui.findHandlers();
          assertEqual(allHandlers.length, 3, "Should find 3 handlers total");
        });

        test("XMLUI Parser", "XmluiSource handles multi-line elements", () => {
          const source = `
            <App>
              <Button
                id="multiLineBtn"
                onClick="handleClick"
                variant="primary"
                disabled={isLoading}>
                Submit Form
              </Button>
            </App>
          `;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const btn = xmlui.findById("multiLineBtn");
          assertTrue(btn !== null, "Should find multi-line element");
          assertEqual(btn.tagName, "Button");
          assertEqual(btn.attributes.onClick, "handleClick");
          assertEqual(btn.attributes.variant, "primary");
        });

        test("XMLUI Parser", "XmluiSource handles binding expressions in id", () => {
          // Note: binding expressions like id={foo} may need special handling
          // This test documents current behavior
          const source = `<App><Button id="staticId">Click</Button></App>`;
          const xmlui = new XmluiSource(source, "test.xmlui");
          const btn = xmlui.findById("staticId");
          assertTrue(btn !== null, "Should find element with static id");
        });

        // =========================================================================
        // TEST SUITE: Rendering
        // =========================================================================
        test("Rendering", "renderPrettyView generates HTML", () => {
          const events = TestFramework.scenarios.buttonClick();
          const processed = processAllEntries(events);
          const html = renderPrettyView(processed);
          assertTrue(html.length > 0, "Should generate HTML");
          assertContains(html, "trace-group", "Should have trace-group class");
        });

        test("Rendering", "renderPrettyView shows interaction traces", () => {
          const events = TestFramework.scenarios.contextMenu("test.txt");
          const processed = processAllEntries(events);
          const html = renderPrettyView(processed);
          assertContains(html, "contextmenu", "Should show contextmenu");
        });

        test("Rendering", "renderRawView generates markdown", () => {
          const events = TestFramework.scenarios.buttonClick();
          const processed = processAllEntries(events);
          const markdown = renderRawView(processed);
          assertTrue(markdown.length > 0, "Should generate markdown");
          assertContains(markdown, "Trace", "Should have Trace header");
        });

        test("Rendering", "renderRawView includes timeline breakdown", () => {
          const events = TestFramework.scenarios.publishPost();
          const processed = processAllEntries(events);
          const markdown = renderRawView(processed);
          assertContains(markdown, "timeline:", "Should have timeline section");
        });

        // =========================================================================
        // TEST SUITE: Export
        // =========================================================================
        test("Export", "generateMarkdownExport produces valid markdown", () => {
          const events = TestFramework.scenarios.apiRequest();
          const processed = processAllEntries(events);
          const md = generateMarkdownExport(processed);
          assertContains(md, "# XMLUI Inspector Export", "Should have title");
          assertContains(md, "Total events:", "Should have event count");
        });

        test("Export", "generateMarkdownExport includes API events", () => {
          const events = TestFramework.scenarios.apiRequest("POST", "/api/submit");
          const processed = processAllEntries(events);
          const md = generateMarkdownExport(processed);
          assertContains(md, "POST", "Should include method");
          assertContains(md, "/api/submit", "Should include URL");
        });

        // =========================================================================
        // TEST SUITE: Complex Scenarios
        // =========================================================================
        test("Complex Scenarios", "handles full publish post flow", () => {
          const events = TestFramework.scenarios.publishPost();
          const processed = processAllEntries(events);
          assertEqual(processed.timelineItems.length, 1);
          const trace = processed.timelineItems[0];
          assertTrue(trace.summary.totalDuration > 2000, "Should capture full duration");
        });

        test("Complex Scenarios", "handles navigation with API calls", () => {
          // Combine navigation and API scenarios
          const navEvents = TestFramework.scenarios.navigation();
          const apiEvents = TestFramework.scenarios.apiRequest();
          const processed = processAllEntries([...navEvents, ...apiEvents]);
          assertEqual(processed.timelineItems.length, 2);
        });

        test("Complex Scenarios", "handles error scenarios", () => {
          const events = TestFramework.scenarios.apiError();
          const processed = processAllEntries(events);
          const trace = processed.timelineItems[0];
          const hasApiError = trace.events.some(e => e.entry.kind === "api:error");
          assertTrue(hasApiError, "Should include api:error");
        });

        test("Complex Scenarios", "handles array diff scenario", () => {
          const events = TestFramework.scenarios.arrayDiff();
          const processed = processAllEntries(events);
          const trace = processed.timelineItems[0];
          const stateChange = trace.events.find(e => e.entry.kind === "state:changes");
          assertTrue(stateChange, "Should have state change");
          const diff = stateChange.entry.diffJson[0];
          assertTrue(Array.isArray(diff.before), "Before should be array");
          assertTrue(Array.isArray(diff.after), "After should be array");
        });

        // =========================================================================
        // TEST SUITE: Typeahead & Cancellation (Mastodon-inspired)
        // =========================================================================
        test("Typeahead & Cancellation", "typeaheadSearch generates multiple traces", () => {
          const events = TestFramework.scenarios.typeaheadSearch();
          const processed = processAllEntries(events);
          // Should have 3 traces (one per keystroke)
          assertEqual(processed.timelineItems.length, 3);
        });

        test("Typeahead & Cancellation", "typeaheadSearch includes api:error for aborted requests", () => {
          const events = TestFramework.scenarios.typeaheadSearch();
          const apiErrors = events.filter(e => e.kind === "api:error");
          assertEqual(apiErrors.length, 2, "Should have 2 aborted requests");
          assertTrue(apiErrors[0].error.includes("signal is aborted"), "Should be AbortController error");
        });

        test("Typeahead & Cancellation", "typeaheadSearch reuses same instanceId", () => {
          const events = TestFramework.scenarios.typeaheadSearch();
          const apiStarts = events.filter(e => e.kind === "api:start");
          const instanceIds = new Set(apiStarts.map(e => e.instanceId));
          assertEqual(instanceIds.size, 1, "All requests should use same DataSource instanceId");
        });

        test("Typeahead & Cancellation", "typeaheadSearch has long-spanning handlers", () => {
          const events = TestFramework.scenarios.typeaheadSearch();
          const completes = events.filter(e => e.kind === "handler:complete");
          const longHandler = completes.find(e => e.duration > 200);
          assertTrue(longHandler, "Should have long-spanning handler");
          assertTrue(longHandler.startPerfTs !== undefined, "Should have startPerfTs");
        });

        // =========================================================================
        // TEST SUITE: Parallel API Requests
        // =========================================================================
        test("Parallel API Requests", "parallelApiBurst generates 6 API starts", () => {
          const events = TestFramework.scenarios.parallelApiBurst();
          const apiStarts = events.filter(e => e.kind === "api:start");
          assertEqual(apiStarts.length, 6);
        });

        test("Parallel API Requests", "parallelApiBurst has unique instanceIds", () => {
          const events = TestFramework.scenarios.parallelApiBurst();
          const apiStarts = events.filter(e => e.kind === "api:start");
          const instanceIds = new Set(apiStarts.map(e => e.instanceId));
          assertEqual(instanceIds.size, 6, "Each request should have unique instanceId");
        });

        test("Parallel API Requests", "parallelApiBurst completions arrive out of order", () => {
          const events = TestFramework.scenarios.parallelApiBurst();
          const apiCompletes = events.filter(e => e.kind === "api:complete");
          // Check that the /api/user/me (last to start) completes before the INSERT queries
          const userComplete = apiCompletes.find(e => e.url === "/api/user/me");
          const insertCompletes = apiCompletes.filter(e => e.body?.sql?.includes("INSERT") || e.duration > 290);
          assertTrue(userComplete, "Should have user API complete");
          // userComplete should be before some INSERT completes in the event order
          const userIdx = events.indexOf(userComplete);
          const lastInsertIdx = Math.max(...insertCompletes.map(e => events.indexOf(e)));
          assertTrue(userIdx < lastInsertIdx, "User API should complete before some INSERT queries");
        });

        // =========================================================================
        // TEST SUITE: Component Initialization
        // =========================================================================
        test("Component Initialization", "componentVarsInitComplex has 6 variables", () => {
          const events = TestFramework.scenarios.componentVarsInitComplex();
          const varsInit = events.find(e => e.kind === "component:vars:init");
          assertTrue(varsInit, "Should have component:vars:init");
          assertEqual(varsInit.varNames.length, 6);
          assertContains(varsInit.varNames.join(","), "postContent");
          assertContains(varsInit.varNames.join(","), "visibilityOptions");
        });

        test("Component Initialization", "componentVarsInitComplex includes complex object in diffs", () => {
          const events = TestFramework.scenarios.componentVarsInitComplex();
          const varsInit = events.find(e => e.kind === "component:vars:init");
          const visibilityDiff = varsInit.diffJson.find(d => d.path === "visibilityOptions");
          assertTrue(visibilityDiff, "Should have visibilityOptions diff");
          assertTrue(Array.isArray(visibilityDiff.after), "visibilityOptions should be array");
          assertEqual(visibilityDiff.after.length, 4, "Should have 4 visibility options");
        });

        test("Component Initialization", "panelNavigation clears previous DataSource", () => {
          const events = TestFramework.scenarios.panelNavigation("Home", "Search");
          const stateChange = events.find(e => e.kind === "state:changes");
          assertTrue(stateChange, "Should have state change for cleared DataSource");
          const diff = stateChange.diffJson[0];
          assertEqual(diff.after.length, 0, "DataSource should be cleared");
          assertGreaterThan(diff.before.length, 0, "DataSource should have had items before");
        });

        // =========================================================================
        // TEST SUITE: Large Array Diffs
        // =========================================================================
        test("Large Array Diffs", "largeArrayDiff has 30 items before, 3 after", () => {
          const events = TestFramework.scenarios.largeArrayDiff();
          const stateChange = events.find(e => e.kind === "state:changes");
          const diff = stateChange.diffJson[0];
          assertEqual(diff.before.length, 30);
          assertEqual(diff.after.length, 3);
        });

        test("Large Array Diffs", "analyzeArrayDiff handles large removals", () => {
          const events = TestFramework.scenarios.largeArrayDiff();
          const stateChange = events.find(e => e.kind === "state:changes");
          const diff = stateChange.diffJson[0];
          const analysis = analyzeArrayDiff(diff.before, diff.after);
          assertEqual(analysis.removed.length, 27, "Should have 27 removed items");
          assertEqual(analysis.added.length, 0, "Should have 0 added items");
          // unchanged = afterCount - added (items that were already there)
          assertEqual(analysis.afterCount - analysis.added.length, 3, "Should have 3 unchanged items");
        });

        // =========================================================================
        // TEST SUITE: SQL Query Execution
        // =========================================================================
        test("SQL Query Execution", "sqlQueryExecution has correct event sequence", () => {
          const events = TestFramework.scenarios.sqlQueryExecution();
          const kinds = events.map(e => e.kind);
          assertTrue(kinds.includes("interaction"), "Should have interaction");
          assertTrue(kinds.includes("api:start"), "Should have api:start");
          assertTrue(kinds.includes("api:complete"), "Should have api:complete");
          // Handler complete should come before api:complete (async pattern)
          const handlerCompleteIdx = kinds.indexOf("handler:complete");
          const apiStartIdx = kinds.indexOf("api:start");
          assertTrue(handlerCompleteIdx > apiStartIdx, "Handler complete after API start");
        });

        test("SQL Query Execution", "sqlQueryExecution captures SQL in request body", () => {
          const events = TestFramework.scenarios.sqlQueryExecution();
          const apiStart = events.find(e => e.kind === "api:start");
          assertTrue(apiStart.body, "Should have request body");
          assertContains(apiStart.body.sql, "SELECT count(*)", "Should have SQL in body");
        });

        test("SQL Query Execution", "sqlQueryExecution shows loading state transition", () => {
          const events = TestFramework.scenarios.sqlQueryExecution();
          const stateChanges = events.filter(e => e.kind === "state:changes" && e.eventName === "AppState:queryState");
          assertEqual(stateChanges.length, 2, "Should have 2 AppState changes");
          // First sets loading: true, second sets loading: false
          const firstDiffs = stateChanges[0].diffJson;
          const loadingDiff = firstDiffs.find(d => d.path === "loading");
          assertEqual(loadingDiff.after, true, "First change should set loading: true");
        });

        // =========================================================================
        // TEST SUITE: Search Functionality
        // =========================================================================
        test("Search", "expandParentDetails expands trace-group ancestors", () => {
          // Create a mock DOM structure
          const container = document.createElement("div");
          container.innerHTML = `
            <div class="trace-group">
              <div class="trace-header"><span class="arrow">▶</span></div>
              <div class="trace-body">
                <span id="target">test content</span>
              </div>
            </div>
          `;
          document.body.appendChild(container);
          const target = container.querySelector("#target");
          expandParentDetails(target);
          const traceGroup = container.querySelector(".trace-group");
          assertTrue(traceGroup.classList.contains("expanded"), "Should expand trace-group");
          document.body.removeChild(container);
        });

        test("Search", "expandParentDetails expands details elements", () => {
          const container = document.createElement("div");
          container.innerHTML = `
            <details>
              <summary>Click to expand</summary>
              <div><span id="target">nested content</span></div>
            </details>
          `;
          document.body.appendChild(container);
          const target = container.querySelector("#target");
          const details = container.querySelector("details");
          assertTrue(!details.open, "Details should start closed");
          expandParentDetails(target);
          assertTrue(details.open, "Details should be open after expandParentDetails");
          document.body.removeChild(container);
        });

        test("Search", "highlightTextInNode creates highlight spans", () => {
          const container = document.createElement("div");
          container.innerHTML = `<p>The quick brown fox jumps over the lazy dog</p>`;
          document.body.appendChild(container);
          const regex = /fox/gi;
          const matches = highlightTextInNode(container, regex);
          assertEqual(matches.length, 1, "Should find 1 match");
          assertTrue(matches[0].classList.contains("search-highlight"), "Should have highlight class");
          assertEqual(matches[0].textContent, "fox", "Should contain matched text");
          document.body.removeChild(container);
        });

        test("Search", "highlightTextInNode finds multiple matches", () => {
          const container = document.createElement("div");
          container.innerHTML = `<p>foo bar foo baz foo</p>`;
          document.body.appendChild(container);
          const regex = /foo/gi;
          const matches = highlightTextInNode(container, regex);
          assertEqual(matches.length, 3, "Should find 3 matches");
          document.body.removeChild(container);
        });

        // =========================================================================
        // TEST SUITE: AppState Source Detection
        // =========================================================================
        test("AppState Source Detection", "detects AppState events by eventName prefix", () => {
          const appStateEvent = { kind: "state:changes", eventName: "AppState:fileOperations" };
          const dataSourceEvent = { kind: "state:changes", eventName: "DataSource:fileCatalog" };
          const otherEvent = { kind: "state:changes", eventName: "someOther" };

          const isAppState = (e) => e.kind === "state:changes" && e.eventName && e.eventName.startsWith("AppState:");
          assertTrue(isAppState(appStateEvent), "Should detect AppState event");
          assertTrue(!isAppState(dataSourceEvent), "Should not detect DataSource as AppState");
          assertTrue(!isAppState(otherEvent), "Should not detect other events as AppState");
        });

        test("AppState Source Detection", "extracts bucket name from eventName", () => {
          const eventName = "AppState:fileOperations";
          const bucketName = eventName.replace("AppState:", "");
          assertEqual(bucketName, "fileOperations");
        });

        // =========================================================================
        // TEST SUITE: AppState Method Pattern Detection
        // =========================================================================
        test("AppState Method Pattern", "detects stateId.value.methodName pattern", () => {
          const code = "fileOpsState.value.copyOrCut($props.selectedItems, 'copy')";
          const pattern = /(\w+)\.value\.(\w+)\s*\(/g;
          const match = pattern.exec(code);
          assertTrue(match !== null, "Should match pattern");
          assertEqual(match[1], "fileOpsState", "Should extract state ID");
          assertEqual(match[2], "copyOrCut", "Should extract method name");
        });

        test("AppState Method Pattern", "finds multiple method calls", () => {
          const code = "selectionState.value.clear(); fileOpsState.value.copyOrCut(items, 'cut')";
          const pattern = /(\w+)\.value\.(\w+)\s*\(/g;
          const matches = [];
          let match;
          while ((match = pattern.exec(code)) !== null) {
            matches.push({ stateId: match[1], method: match[2] });
          }
          assertEqual(matches.length, 2, "Should find 2 method calls");
          assertEqual(matches[0].stateId, "selectionState");
          assertEqual(matches[0].method, "clear");
          assertEqual(matches[1].stateId, "fileOpsState");
          assertEqual(matches[1].method, "copyOrCut");
        });

        test("AppState Method Pattern", "does not match non-value property access", () => {
          const code = "someObj.other.method()";
          const pattern = /(\w+)\.value\.(\w+)\s*\(/g;
          const match = pattern.exec(code);
          assertEqual(match, null, "Should not match non-.value. access");
        });

        test("AppState Method Pattern", "handles whitespace variations", () => {
          const code1 = "state.value.method()";
          const code2 = "state.value.method ()";
          const code3 = "state.value.method( )";
          const pattern = /(\w+)\.value\.(\w+)\s*\(/g;

          assertTrue(pattern.exec(code1) !== null, "Should match no space");
          pattern.lastIndex = 0;
          assertTrue(pattern.exec(code2) !== null, "Should match space before paren");
          pattern.lastIndex = 0;
          assertTrue(pattern.exec(code3) !== null, "Should match space in paren");
        });

        // =========================================================================
        // TEST SUITE: AppState Rendering
        // =========================================================================
        test("AppState Rendering", "isAppState condition correctly identifies AppState events", () => {
          const appStateEvent = { kind: "state:changes", eventName: "AppState:fileOperations", diffJson: [] };
          const dataSourceEvent = { kind: "state:changes", eventName: "DataSource:catalog", diffJson: [] };
          const varsEvent = { kind: "component:vars:init", eventName: "myVar", diffJson: [] };

          // This is the exact condition used in the rendering code
          const isAppState = (e) => e.kind === "state:changes" && e.eventName && e.eventName.startsWith("AppState:");

          assertTrue(isAppState(appStateEvent), "Should identify AppState event");
          assertTrue(!isAppState(dataSourceEvent), "Should not identify DataSource as AppState");
          assertTrue(!isAppState(varsEvent), "Should not identify component:vars as AppState");
        });

        test("AppState Rendering", "AppState events included in startup trace", () => {
          const events = TestFramework.scenarios.startup();
          // startup scenario includes AppState:config
          const appStateEvent = events.find(e => e.eventName && e.eventName.startsWith("AppState:"));
          assertTrue(appStateEvent !== undefined, "Startup should include AppState event");
          assertEqual(appStateEvent.eventName, "AppState:config");
        });

        // =========================================================================
        // Render Results
        // =========================================================================
        let html = '<div class="test-results">';
        html += `<h2>Test Results</h2>`;

        results.suites.forEach(suite => {
          const suiteStatus = suite.failed === 0 ? "pass" : "fail";
          html += `<div class="test-suite expanded">`;
          html += `<div class="test-suite-header" onclick="this.parentElement.classList.toggle('expanded')">`;
          html += `<span class="test-icon ${suiteStatus}">${suite.failed === 0 ? "✓" : "✗"}</span>`;
          html += `<span>${suite.name}</span>`;
          html += `<span class="text-muted">(${suite.passed}/${suite.tests.length})</span>`;
          html += `</div>`;
          html += `<div class="test-suite-body">`;

          suite.tests.forEach(t => {
            const status = t.passed ? "pass" : "fail";
            html += `<div class="test-case ${status}">`;
            html += `<span class="test-icon ${status}">${t.passed ? "✓" : "✗"}</span>`;
            html += `<div class="test-name">${t.name}`;
            if (t.error) {
              html += `<div class="test-error">${t.error.replace(/</g, "&lt;")}</div>`;
            }
            html += `</div></div>`;
          });

          html += `</div></div>`;
        });

        const summaryClass = results.failed === 0 ? "all-pass" : "has-failures";
        html += `<div class="test-summary ${summaryClass}">`;
        html += `${results.passed} passed, ${results.failed} failed`;
        html += `</div>`;

        html += '</div>';
        container.innerHTML = html;
      }

      document.getElementById("test").addEventListener("click", () => {
        // Clear logs
        if (window.parent && window.parent._xsLogs) window.parent._xsLogs.length = 0;
        // Mark test view as active to prevent auto-refresh
        testViewActive = true;
        // Run tests
        runTests();
      });

      // =============================================================================
      // FILE PREVIEW MODAL
      // =============================================================================

      const fileModal = document.getElementById("fileModal");
      const modalFilePath = document.getElementById("modalFilePath");
      const modalFileContent = document.getElementById("modalFileContent");
      const modalClose = document.getElementById("modalClose");

      function openFileModal(filePath, highlight) {
        modalFilePath.textContent = filePath;
        modalFileContent.textContent = "Loading...";
        fileModal.classList.add("open");

        fetch(filePath)
          .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
          })
          .then(content => {
            if (highlight) {
              // Search for the highlight text and mark it
              // Clean up the highlight - remove surrounding braces if present
              let searchText = highlight.trim();
              if (searchText.startsWith("{") && searchText.endsWith("}")) {
                searchText = searchText.slice(1, -1).trim();
              }

              // Find the line containing the highlight text
              const lines = content.split("\n");
              let highlightedContent = "";
              let found = false;
              let foundLineNum = -1;

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const escaped = line.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if (!found && line.includes(searchText)) {
                  // Highlight this line
                  highlightedContent += `<span class="highlight-line">→ ${escaped}</span>\n`;
                  found = true;
                  foundLineNum = i;
                } else {
                  highlightedContent += escaped + "\n";
                }
              }

              modalFileContent.innerHTML = highlightedContent;

              // Scroll to the highlighted line
              if (foundLineNum >= 0) {
                setTimeout(() => {
                  const highlighted = modalFileContent.querySelector(".highlight-line");
                  if (highlighted) {
                    highlighted.scrollIntoView({ block: "center" });
                  }
                }, 50);
              }
            } else {
              modalFileContent.textContent = content;
            }
          })
          .catch(err => {
            modalFileContent.textContent = `Error loading file: ${err.message}`;
          });
      }

      function closeFileModal() {
        fileModal.classList.remove("open");
      }

      modalClose.addEventListener("click", closeFileModal);
      fileModal.addEventListener("click", (e) => {
        if (e.target === fileModal) closeFileModal();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && fileModal.classList.contains("open")) {
          closeFileModal();
        }
      });

      // Handle clicks on file links
      document.addEventListener("click", (e) => {
        const fileLink = e.target.closest(".file-link");
        if (fileLink) {
          e.preventDefault();
          const filePath = fileLink.dataset.file;
          const highlight = fileLink.dataset.highlight;
          if (filePath) openFileModal(filePath, highlight);
        }
      });

      function downloadFile(filename, content, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function generateMarkdownExport(processed) {
        const lines = [];
        lines.push("# XMLUI Inspector Export");
        lines.push("");
        lines.push(`**Generated:** ${new Date().toISOString()}`);
        lines.push(`**Total events:** ${processed.totalEvents}`);
        lines.push("");

        processed.timelineItems.forEach((item, idx) => {
          if (item.type === "trace") {
            const { summary, events, traceId } = item;
            lines.push(`## Trace ${idx + 1}: ${summary.componentText}${summary.totalDuration !== null ? ` (${summary.totalDuration.toFixed(0)}ms)` : ""}`);
            lines.push("");
            lines.push(`- **traceId:** \`${traceId}\``);
            if (summary.timelineBreakdown.length > 0 && summary.totalDuration) {
              lines.push("");
              lines.push("| Phase | Duration |");
              lines.push("|-------|----------|");
              const sorted = summary.timelineBreakdown.slice().sort((a, b) => a.order - b.order);
              sorted.forEach(item => {
                lines.push(`| ${item.phase} | ${item.duration.toFixed(0)}ms |`);
              });
              lines.push(`| **total** | **${summary.totalDuration.toFixed(0)}ms** |`);
            } else if (summary.totalDuration !== null) {
              lines.push(`- **duration:** ${summary.totalDuration.toFixed(0)}ms`);
            }
            lines.push("");

            events.forEach((evt) => {
              const e = evt.entry;
              // Strip HTML tags from meta parts for markdown export
              const metaParts = evt.meta.parts.map(stripHtml);
              const meta = metaParts.length ? ` _(${metaParts.join(" | ")})_` : "";

              if (e.kind === "api:start" || e.kind === "api:complete" || e.kind === "api:error") {
                const durationSuffix = e.kind === "api:complete" && typeof e._apiDuration === "number" ? ` (${e._apiDuration.toFixed(1)}ms)` : "";
                const requestIdSuffix = e._requestId ? ` \`[${e._requestId}]\`` : "";
                lines.push(`- \`[${e.kind}]\`${durationSuffix} **${normalizeMethod(e.method)}** ${normalizeUrl(e.url)}${requestIdSuffix}${meta}`);
                if (e.body) {
                  const bodyStr = typeof e.body === "string" ? e.body : JSON.stringify(e.body);
                  const truncatedBody = bodyStr.length > 100 ? bodyStr.substring(0, 100) + "..." : bodyStr;
                  lines.push(`  - body: \`${truncatedBody}\``);
                }
              } else if (e.kind === "navigate") {
                lines.push(`- \`[navigate]\` **${e.from || "/"}** → **${e.to || "?"}**${meta}`);
              } else if (e.kind === "modal:show" || e.kind === "modal:confirm" || e.kind === "modal:cancel") {
                const title = e.title ? ` "${e.title}"` : "";
                lines.push(`- \`[${e.kind}]\`${title}${meta}`);
              } else if (e.kind === "state:changes") {
                lines.push(`- \`[${e.kind}]\` ${e.eventName || ""}${meta}`);
                if (e.diffJson) {
                  e.diffJson.forEach((d) => {
                    if (d.before && d.after && typeof d.before === "object" && typeof d.after === "object" && !Array.isArray(d.before) && !Array.isArray(d.after)) {
                      // Object diff
                      const allKeys = new Set([...Object.keys(d.before), ...Object.keys(d.after)]);
                      const changedKeys = [];
                      allKeys.forEach((key) => {
                        if (JSON.stringify(d.before[key]) !== JSON.stringify(d.after[key])) changedKeys.push(key);
                      });
                      if (changedKeys.length === 0) {
                        lines.push(`  - \`${d.path}\`: (no visible change)`);
                      } else {
                        lines.push(`  - \`${d.path}\`:`);
                        changedKeys.forEach((key) => {
                          lines.push(`    - \`${key}\`: ${JSON.stringify(d.before[key])?.slice(0, 60) || "undefined"} → ${JSON.stringify(d.after[key])?.slice(0, 60) || "undefined"}`);
                        });
                      }
                    } else {
                      lines.push(`  - \`${d.path}\`: ${JSON.stringify(d.before)?.slice(0, 80) || "undefined"} → ${JSON.stringify(d.after)?.slice(0, 80) || "undefined"}`);
                    }
                  });
                }
              } else {
                lines.push(`- \`[${e.kind}]\` ${e.eventName || ""}${evt.label ? ` ${evt.label}` : ""}${meta}`);
              }
            });
            lines.push("");
          }
        });

        if (processed.sourceFiles.length) {
          lines.push("## Source Files");
          lines.push("");
          processed.sourceFiles.forEach((file, idx) => {
            lines.push(`${idx}. \`${file}\``);
          });
        }

        return lines.join("\n");
      }

      function generateHtmlExport(processed) {
        // Static HTML snapshot - captures current rendered state
        const styles = document.querySelector("style").textContent;
        const diffContent = document.getElementById("diff").innerHTML;

        return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XMLUI Inspector Export - ${new Date().toISOString()}</title>
  <link rel="stylesheet" href="https://unpkg.com/jsondiffpatch@0.7.3/lib/formatters/styles/html.css" />
  <style>${styles}</style>
  <style>
    /* Export-specific: expand all trace groups by default */
    .trace-group { }
    .trace-group .trace-body { display: block; }
    .trace-group .trace-header .arrow { transform: rotate(90deg); }
  </style>
</head>
<body>
  <h1>XMLUI Inspector</h1>
  <p style="color: var(--color-text-muted); font-size: var(--font-sm);">
    Exported: ${new Date().toISOString()} | Events: ${processed.totalEvents}
  </p>
  <div id="diff">${diffContent}</div>
  <script>
    // Simple interactivity for exported file
    document.querySelectorAll(".trace-header").forEach(header => {
      header.addEventListener("click", () => {
        header.parentElement.classList.toggle("expanded");
        header.classList.toggle("expanded");
      });
    });
  <` + `/script>
</body>
</html>`;
      }

      document.getElementById("exportFormat").addEventListener("change", (e) => {
        const format = e.target.value;
        if (!format) return;
        e.target.value = ""; // Reset select

        const allEntries = getAllEntries();
        const filtered = allEntries.filter((entry) => entryMatches(entry, ""));
        if (!filtered.length) { alert("No entries to export"); return; }

        const processed = processAllEntries(filtered);
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, "");

        if (format === "md") {
          downloadFile(`xs-diff-${timestamp}.md`, generateMarkdownExport(processed), "text/markdown");
        } else if (format === "html") {
          downloadFile(`xs-diff-${timestamp}.html`, generateHtmlExport(processed), "text/html");
        } else if (format === "json") {
          // Export live _xsLogs only (not localStorage) for Playwright test generation.
          // The engine's splicePreservingInteractions() already preserves interaction and
          // API events from buffer eviction, so localStorage merge is unnecessary and
          // would contaminate exports with stale events from previous sessions.
          const rawLogs = ((window.parent && window.parent._xsLogs) || []).slice().sort((a, b) => (a.perfTs || a.ts || 0) - (b.perfTs || b.ts || 0));
          console.log(`Exporting ${rawLogs.length} entries as JSON for Playwright`);
          console.log(`Interaction entries: ${rawLogs.filter(e=>e.kind === 'interaction').length}`);
          if (rawLogs.length === 0) {
            alert("No logs found. Try running this in the app console:\ncopy(JSON.stringify(window._xsLogs, (k,v) => v instanceof Node || v instanceof Window || typeof v === 'function' ? undefined : v))");
            return;
          }
          // Stringify each entry separately to avoid cross-entry circular tracking
          const skipKeys = new Set(['_targetInst', '_debugOwner', '_debugSource', 'stateNode', 'nativeEvent', 'view', 'target', 'currentTarget', 'relatedTarget', '__reactFiber$', '__reactProps$']);
          const jsonEntries = rawLogs.map(entry => {
            const seen = new WeakSet();
            return JSON.stringify(entry, (key, value) => {
              if (value instanceof Node || value instanceof Window) return undefined;
              if (typeof value === 'function') return undefined;
              // Skip React internals and DOM-heavy fields that bloat the output
              if (skipKeys.has(key)) return undefined;
              if (key.startsWith('__react')) return undefined;
              if (typeof value === 'object' && value !== null) {
                if (seen.has(value)) return '[circular]';
                seen.add(value);
              }
              return value;
            });
          });
          const jsonContent = '[\n  ' + jsonEntries.join(',\n  ') + '\n]';
          console.log(`JSON size: ${jsonContent.length} bytes`);
          const defaultName = `xs-trace-${timestamp}`;
          const filename = prompt("Save trace as:", defaultName);
          if (filename) {
            const finalName = filename.endsWith('.json') ? filename : `${filename}.json`;
            downloadFile(finalName, jsonContent, "application/json");
          }
        }
      });

      // Handle hash navigation - expand parent trace-group and highlight target
      function handleHashNavigation() {
        const hash = window.location.hash;
        if (!hash) return;

        const targetId = hash.slice(1);
        const anchor = document.getElementById(targetId);
        if (!anchor) return;

        // Find the trace-event sibling (the div right after the anchor)
        const traceEvent = anchor.nextElementSibling;
        if (!traceEvent || !traceEvent.classList.contains("trace-event")) return;

        // Find and expand the parent trace-group
        const traceGroup = traceEvent.closest(".trace-group");
        if (traceGroup && !traceGroup.classList.contains("expanded")) {
          traceGroup.classList.add("expanded");
          const header = traceGroup.querySelector(".trace-header");
          if (header) header.classList.add("expanded");
        }

        // Auto-expand the Request/Response details within the trace event
        const details = traceEvent.querySelectorAll("details");
        details.forEach(d => d.setAttribute("open", ""));

        // Apply highlight animation
        traceEvent.classList.remove("jump-target");
        void traceEvent.offsetWidth; // Force reflow
        traceEvent.classList.add("jump-target");

        // Scroll into view
        anchor.scrollIntoView({ block: "start", behavior: "smooth" });
      }

      window.addEventListener("hashchange", handleHashNavigation);
      // Also handle initial page load with hash
      window.addEventListener("load", () => {
        if (window.location.hash) {
          setTimeout(handleHashNavigation, 100);
        }
      });

      // Handle clicks on API pair links - ensures expand happens even when hash doesn't change
      document.addEventListener("click", (e) => {
        const pairLink = e.target.closest(".api-pair-link");
        if (pairLink) {
          // Let the browser update the hash, then handle navigation
          setTimeout(handleHashNavigation, 0);
        }
      });

      let lastLogCount = -1;
      setInterval(() => {
        if (testViewActive) return; // Don't auto-refresh when test results are displayed
        const logs = (window.parent && window.parent._xsLogs) || [];
        if (logs.length !== lastLogCount) {
          lastLogCount = logs.length;
          render();
        }
      }, 250);

      // Help icon click handler
      document.addEventListener("click", (e) => {
        const helpIcon = e.target.closest(".help-icon");
        if (helpIcon) {
          e.stopPropagation();
          const helpType = helpIcon.dataset.help;
          const modal = document.getElementById("helpModal");
          if (modal && helpType === "traceId") {
            modal.classList.add("visible");
          }
        }
      });

      // Close modal on backdrop click or close button
      document.getElementById("helpModal").addEventListener("click", (e) => {
        if (e.target.classList.contains("help-modal") || e.target.classList.contains("help-modal-close")) {
          e.target.closest(".help-modal").classList.remove("visible");
        }
      });

      // Close modal on Escape key
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          document.getElementById("helpModal").classList.remove("visible");
        }
      });

      render();
    </script>

    <!-- Help Modal for TraceId -->
    <div id="helpModal" class="help-modal">
      <div class="help-modal-content">
        <button class="help-modal-close">&times;</button>
        <h3>What is a Trace ID?</h3>
        <p>A trace ID groups related events that happen as part of the same logical operation. The prefix indicates what triggered the trace:</p>
        <dl>
          <dt><code>i-</code> (interaction)</dt>
          <dd>Triggered by a user interaction such as click, contextmenu, keydown, or other direct user action.</dd>

          <dt><code>t-</code> (non-interaction)</dt>
          <dd>Triggered by data changes, timers, or handlers that fire without direct user interaction (e.g., ChangeListener responding to state updates).</dd>

          <dt><code>startup-</code> (bootstrap)</dt>
          <dd>Events that occur during app initialization before any user interaction.</dd>
        </dl>
      </div>
    </div>
  </body>
</html>
