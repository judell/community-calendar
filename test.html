<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Community Calendar - Tests</title>
    <style>
      :root {
        --color-pass: #059669;
        --color-fail: #dc2626;
        --color-bg: #f9fafb;
        --color-border: #e5e7eb;
      }
      body {
        font-family: system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 20px;
        background: var(--color-bg);
      }
      h1 { margin: 0 0 20px 0; }
      .summary {
        padding: 12px 16px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-weight: bold;
      }
      .summary.pass { background: #d1fae5; color: var(--color-pass); }
      .summary.fail { background: #fee2e2; color: var(--color-fail); }
      .test-group {
        background: white;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        margin-bottom: 16px;
        overflow: hidden;
      }
      .test-group h2 {
        margin: 0;
        padding: 12px 16px;
        background: #f3f4f6;
        border-bottom: 1px solid var(--color-border);
        font-size: 14px;
      }
      .test {
        padding: 8px 16px;
        border-bottom: 1px solid var(--color-border);
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .test:last-child { border-bottom: none; }
      .test.pass .status { color: var(--color-pass); }
      .test.fail .status { color: var(--color-fail); }
      .status { font-weight: bold; width: 40px; }
      .name { flex: 1; }
      .error {
        font-family: monospace;
        font-size: 12px;
        color: var(--color-fail);
        background: #fef2f2;
        padding: 4px 8px;
        border-radius: 4px;
        margin-left: 8px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/rrule@2.8.1/dist/es5/rrule.min.js"></script>
    <script src="helpers.js"></script>
  </head>
  <body>
    <h1>Community Calendar Tests</h1>
    <div id="summary" class="summary"></div>
    <div id="results"></div>

    <script>
      // Simple test framework
      const results = [];
      let currentGroup = null;

      function describe(name, fn) {
        currentGroup = { name, tests: [] };
        fn();
        results.push(currentGroup);
      }

      function it(name, fn) {
        try {
          fn();
          currentGroup.tests.push({ name, pass: true });
        } catch (e) {
          currentGroup.tests.push({ name, pass: false, error: e.message });
        }
      }

      function assert(condition, message) {
        if (!condition) throw new Error(message || 'Assertion failed');
      }

      function assertEqual(actual, expected, message) {
        if (actual !== expected) {
          throw new Error(message || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
        }
      }

      function assertDeepEqual(actual, expected, message) {
        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
          throw new Error(message || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
        }
      }

      // ============================================================
      // TESTS
      // ============================================================

      describe('filterEvents', () => {
        const events = [
          { id: 1, title: 'Jazz Concert', location: 'Downtown', source: 'Venue A', description: 'Live music' },
          { id: 2, title: 'Art Show', location: 'Gallery', source: 'Museum', description: 'Modern art exhibit' },
          { id: 3, title: 'Food Festival', location: 'Park', source: 'City', description: 'Local cuisine' }
        ];

        it('returns all events when no search term', () => {
          const result = filterEvents(events, '');
          assertEqual(result.length, 3);
        });

        it('returns all events when term is null', () => {
          const result = filterEvents(events, null);
          assertEqual(result.length, 3);
        });

        it('filters by title', () => {
          const result = filterEvents(events, 'jazz');
          assertEqual(result.length, 1);
          assertEqual(result[0].id, 1);
        });

        it('filters by location', () => {
          const result = filterEvents(events, 'gallery');
          assertEqual(result.length, 1);
          assertEqual(result[0].id, 2);
        });

        it('filters by source', () => {
          const result = filterEvents(events, 'museum');
          assertEqual(result.length, 1);
          assertEqual(result[0].id, 2);
        });

        it('filters by description', () => {
          const result = filterEvents(events, 'cuisine');
          assertEqual(result.length, 1);
          assertEqual(result[0].id, 3);
        });

        it('is case insensitive', () => {
          const result = filterEvents(events, 'JAZZ');
          assertEqual(result.length, 1);
        });

        it('returns empty array for no matches', () => {
          const result = filterEvents(events, 'xyz');
          assertEqual(result.length, 0);
        });

        it('handles null events', () => {
          const result = filterEvents(null, 'test');
          assertDeepEqual(result, []);
        });
      });

      describe('getDescriptionSnippet', () => {
        it('returns null when description is null', () => {
          const result = getDescriptionSnippet(null, 'test');
          assertEqual(result, null);
        });

        it('returns null when term is null', () => {
          const result = getDescriptionSnippet('some text', null);
          assertEqual(result, null);
        });

        it('returns null when term not found', () => {
          const result = getDescriptionSnippet('some text here', 'xyz');
          assertEqual(result, null);
        });

        it('highlights the matched term with **', () => {
          const result = getDescriptionSnippet('This is a test of the system', 'test');
          assert(result.includes('**test**'), 'Should contain **test**');
        });

        it('adds ellipsis when context is truncated', () => {
          const longText = 'A'.repeat(50) + 'TARGET' + 'B'.repeat(50);
          const result = getDescriptionSnippet(longText, 'TARGET');
          assert(result.startsWith('...'), 'Should start with ...');
          assert(result.endsWith('...'), 'Should end with ...');
        });

        it('no leading ellipsis when match is near start', () => {
          const result = getDescriptionSnippet('test at the start', 'test');
          assert(!result.startsWith('...'), 'Should not start with ...');
        });

        it('is case insensitive', () => {
          const result = getDescriptionSnippet('This is a TEST here', 'test');
          assert(result.includes('**TEST**'), 'Should preserve original case');
        });
      });

      describe('formatTime', () => {
        it('returns empty string for null', () => {
          assertEqual(formatTime(null), '');
        });

        it('returns empty string for midnight (unknown time)', () => {
          assertEqual(formatTime('2026-02-01T00:00:00Z'), '');
        });

        it('formats AM time correctly', () => {
          const result = formatTime('2026-02-01T09:30:00Z');
          assertEqual(result, '9:30 AM');
        });

        it('formats PM time correctly', () => {
          const result = formatTime('2026-02-01T14:30:00Z');
          assertEqual(result, '2:30 PM');
        });

        it('formats noon correctly', () => {
          const result = formatTime('2026-02-01T12:00:00Z');
          assertEqual(result, '12:00 PM');
        });

        it('pads minutes with zero', () => {
          const result = formatTime('2026-02-01T09:05:00Z');
          assertEqual(result, '9:05 AM');
        });
      });

      describe('formatDayOfWeek', () => {
        it('returns empty string for null', () => {
          assertEqual(formatDayOfWeek(null), '');
        });

        it('returns short day name', () => {
          const result = formatDayOfWeek('2026-02-01T12:00:00Z'); // Sunday
          assertEqual(result, 'Sun');
        });
      });

      describe('formatMonthDay', () => {
        it('returns empty string for null', () => {
          assertEqual(formatMonthDay(null), '');
        });

        it('returns month and day', () => {
          const result = formatMonthDay('2026-02-15T12:00:00Z');
          assertEqual(result, 'Feb 15');
        });
      });

      describe('truncate', () => {
        it('returns empty string for null', () => {
          assertEqual(truncate(null, 10), '');
        });

        it('returns full text if under limit', () => {
          assertEqual(truncate('short', 10), 'short');
        });

        it('truncates and adds ellipsis', () => {
          assertEqual(truncate('this is a long text', 10), 'this is a...');
        });
      });

      describe('getSourceCounts', () => {
        it('returns empty array for null', () => {
          assertDeepEqual(getSourceCounts(null), []);
        });

        it('returns empty array for empty array', () => {
          assertDeepEqual(getSourceCounts([]), []);
        });

        it('counts events by source', () => {
          const events = [
            { source: 'A' }, { source: 'A' }, { source: 'B' }
          ];
          const result = getSourceCounts(events);
          assertEqual(result.length, 2);
          assertEqual(result[0].source, 'A');
          assertEqual(result[0].count, 2);
          assertEqual(result[1].source, 'B');
          assertEqual(result[1].count, 1);
        });

        it('sorts by count descending', () => {
          const events = [
            { source: 'A' }, { source: 'B' }, { source: 'B' }, { source: 'B' }
          ];
          const result = getSourceCounts(events);
          assertEqual(result[0].source, 'B');
          assertEqual(result[0].count, 3);
        });

        it('handles missing source as Unknown', () => {
          const events = [{ title: 'test' }];
          const result = getSourceCounts(events);
          assertEqual(result[0].source, 'Unknown');
        });
      });

      describe('dedupeEvents', () => {
        beforeEach: clearDedupeCache();

        it('returns empty array for null', () => {
          clearDedupeCache();
          assertDeepEqual(dedupeEvents(null), []);
        });

        it('returns empty array for empty array', () => {
          clearDedupeCache();
          assertDeepEqual(dedupeEvents([]), []);
        });

        it('merges events with same title and start_time', () => {
          clearDedupeCache();
          const events = [
            { id: 1, title: 'Concert', start_time: '2026-02-01T19:00:00Z', source: 'Venue A' },
            { id: 2, title: 'Concert', start_time: '2026-02-01T19:00:00Z', source: 'Venue B' }
          ];
          const result = dedupeEvents(events);
          assertEqual(result.length, 1);
          assertEqual(result[0].source, 'Venue A, Venue B');
        });

        it('tracks merged IDs', () => {
          clearDedupeCache();
          const events = [
            { id: 1, title: 'Show', start_time: '2026-02-01T20:00:00Z', source: 'A' },
            { id: 2, title: 'Show', start_time: '2026-02-01T20:00:00Z', source: 'B' }
          ];
          const result = dedupeEvents(events);
          assertDeepEqual(result[0].mergedIds, [1, 2]);
        });

        it('keeps events with different start times separate', () => {
          clearDedupeCache();
          const events = [
            { id: 1, title: 'Concert', start_time: '2026-02-01T19:00:00Z', source: 'A' },
            { id: 2, title: 'Concert', start_time: '2026-02-02T19:00:00Z', source: 'A' }
          ];
          const result = dedupeEvents(events);
          assertEqual(result.length, 2);
        });

        it('prefers non-empty values for optional fields', () => {
          clearDedupeCache();
          const events = [
            { id: 1, title: 'Show', start_time: '2026-02-01T20:00:00Z', source: 'A', url: null, location: 'Place' },
            { id: 2, title: 'Show', start_time: '2026-02-01T20:00:00Z', source: 'B', url: 'http://example.com', location: null }
          ];
          const result = dedupeEvents(events);
          assertEqual(result[0].url, 'http://example.com');
          assertEqual(result[0].location, 'Place');
        });

        it('sorts result by start_time', () => {
          clearDedupeCache();
          const events = [
            { id: 2, title: 'Later', start_time: '2026-02-02T10:00:00Z', source: 'A' },
            { id: 1, title: 'Earlier', start_time: '2026-02-01T10:00:00Z', source: 'A' }
          ];
          const result = dedupeEvents(events);
          assertEqual(result[0].title, 'Earlier');
          assertEqual(result[1].title, 'Later');
        });
      });

      describe('isEventPicked', () => {
        const picks = [
          { event_id: 1 },
          { event_id: 3 }
        ];

        it('returns false for null picks', () => {
          assertEqual(isEventPicked([1], null), false);
        });

        it('returns false for null mergedIds', () => {
          assertEqual(isEventPicked(null, picks), false);
        });

        it('returns true when event is picked', () => {
          assertEqual(isEventPicked([1], picks), true);
        });

        it('returns false when event is not picked', () => {
          assertEqual(isEventPicked([2], picks), false);
        });

        it('works with merged IDs (any match)', () => {
          assertEqual(isEventPicked([2, 3], picks), true);
        });

        it('works with single ID (not array)', () => {
          assertEqual(isEventPicked(1, picks), true);
          assertEqual(isEventPicked(2, picks), false);
        });
      });

      describe('formatDate', () => {
        it('returns empty string for null', () => {
          assertEqual(formatDate(null), '');
        });

        it('returns formatted date', () => {
          const result = formatDate('2026-02-15T12:00:00Z');
          assert(result.includes('Feb'), 'Should contain month');
          assert(result.includes('15'), 'Should contain day');
        });
      });

      describe('buildGoogleCalendarUrl', () => {
        it('returns empty string for null event', () => {
          assertEqual(buildGoogleCalendarUrl(null), '');
        });

        it('builds valid Google Calendar URL', () => {
          const event = {
            title: 'Test Event',
            start_time: '2026-02-15T19:00:00Z',
            end_time: '2026-02-15T21:00:00Z',
            location: 'Downtown',
            description: 'A fun event'
          };
          const url = buildGoogleCalendarUrl(event);
          assert(url.startsWith('https://calendar.google.com/calendar/render?'), 'Should be Google Calendar URL');
          assert(url.includes('Test+Event') || url.includes('Test%20Event'), 'Should contain title');
          assert(url.includes('Downtown'), 'Should contain location');
        });

        it('uses start_time as end_time when end_time is null', () => {
          const event = {
            title: 'No End',
            start_time: '2026-02-15T19:00:00Z',
            end_time: null
          };
          const url = buildGoogleCalendarUrl(event);
          // dates param should have same start and end
          const datesMatch = url.match(/dates=([^&]+)/);
          assert(datesMatch, 'Should have dates param');
          const parts = decodeURIComponent(datesMatch[1]).split('/');
          assertEqual(parts[0], parts[1], 'Start and end should be the same');
        });

        it('handles special characters in title', () => {
          const event = {
            title: 'Music & Art <Show>',
            start_time: '2026-02-15T19:00:00Z'
          };
          const url = buildGoogleCalendarUrl(event);
          assert(url.length > 0, 'Should produce a URL');
        });
      });

      describe('formatICSDate', () => {
        it('returns empty string for null', () => {
          assertEqual(formatICSDate(null), '');
        });

        it('formats to ICS date format (YYYYMMDDTHHMMSSZ)', () => {
          const result = formatICSDate('2026-02-15T19:30:00Z');
          assertEqual(result, '20260215T193000Z');
        });

        it('handles midnight', () => {
          const result = formatICSDate('2026-02-15T00:00:00Z');
          assertEqual(result, '20260215T000000Z');
        });
      });

      describe('escapeICS', () => {
        it('returns empty string for null', () => {
          assertEqual(escapeICS(null), '');
        });

        it('escapes backslashes', () => {
          assertEqual(escapeICS('path\\to'), 'path\\\\to');
        });

        it('escapes semicolons', () => {
          assertEqual(escapeICS('a;b'), 'a\\;b');
        });

        it('escapes commas', () => {
          assertEqual(escapeICS('a,b'), 'a\\,b');
        });

        it('escapes newlines', () => {
          assertEqual(escapeICS('line1\nline2'), 'line1\\nline2');
        });

        it('handles multiple special chars', () => {
          assertEqual(escapeICS('a;b,c\nd'), 'a\\;b\\,c\\nd');
        });
      });

      describe('toggleDay', () => {
        it('adds a day not in array', () => {
          const result = toggleDay(['MO', 'WE'], 'FR');
          assertDeepEqual(result, ['MO', 'WE', 'FR']);
        });

        it('removes a day already in array', () => {
          const result = toggleDay(['MO', 'WE', 'FR'], 'WE');
          assertDeepEqual(result, ['MO', 'FR']);
        });

        it('adds to empty array', () => {
          const result = toggleDay([], 'TU');
          assertDeepEqual(result, ['TU']);
        });

        it('does not mutate original array', () => {
          const original = ['MO', 'WE'];
          toggleDay(original, 'FR');
          assertDeepEqual(original, ['MO', 'WE']);
        });
      });

      describe('buildRRule', () => {
        it('returns null for frequency "none"', () => {
          assertEqual(buildRRule('none', []), null);
        });

        it('returns null for null frequency', () => {
          assertEqual(buildRRule(null, []), null);
        });

        it('builds WEEKLY rule', () => {
          const result = buildRRule('WEEKLY', ['MO', 'WE']);
          assert(result.includes('FREQ=WEEKLY'), 'Should contain FREQ=WEEKLY');
          assert(result.includes('MO'), 'Should contain MO');
          assert(result.includes('WE'), 'Should contain WE');
        });

        it('builds MONTHLY rule without ordinal', () => {
          const result = buildRRule('MONTHLY', []);
          assert(result.includes('FREQ=MONTHLY'), 'Should contain FREQ=MONTHLY');
        });

        it('builds MONTHLY rule with ordinal + day (1st Tuesday)', () => {
          const result = buildRRule('MONTHLY', [], 1, 'TU');
          assert(result.includes('FREQ=MONTHLY'), 'Should contain FREQ=MONTHLY');
          assert(result.includes('TU'), 'Should contain TU');
          assert(result.includes('+1'), 'Should contain +1 for 1st');
        });

        it('builds MONTHLY rule with ordinal + day (3rd Friday)', () => {
          const result = buildRRule('MONTHLY', [], 3, 'FR');
          assert(result.includes('FREQ=MONTHLY'), 'Should contain FREQ=MONTHLY');
          assert(result.includes('FR'), 'Should contain FR');
          assert(result.includes('+3'), 'Should contain +3 for 3rd');
        });

        it('result does not include RRULE: prefix', () => {
          const result = buildRRule('WEEKLY', ['FR']);
          assert(!result.startsWith('RRULE:'), 'Should not start with RRULE:');
        });
      });

      describe('getOrdinalWeekday', () => {
        it('returns null for null', () => {
          assertEqual(getOrdinalWeekday(null), null);
        });

        it('computes 1st Tuesday from 2026-03-03', () => {
          const result = getOrdinalWeekday('2026-03-03');
          assertEqual(result.ordinal, 1);
          assertEqual(result.day, 'TU');
        });

        it('computes 2nd Wednesday from 2026-02-11', () => {
          const result = getOrdinalWeekday('2026-02-11');
          assertEqual(result.ordinal, 2);
          assertEqual(result.day, 'WE');
        });

        it('computes 4th Friday from 2026-02-27', () => {
          const result = getOrdinalWeekday('2026-02-27');
          assertEqual(result.ordinal, 4);
          assertEqual(result.day, 'FR');
        });

        it('computes 1st Sunday from 2026-02-01', () => {
          const result = getOrdinalWeekday('2026-02-01');
          assertEqual(result.ordinal, 1);
          assertEqual(result.day, 'SU');
        });
      });

      describe('parseRRule', () => {
        it('returns none/empty for null', () => {
          const result = parseRRule(null);
          assertEqual(result.frequency, 'none');
          assertDeepEqual(result.days, []);
        });

        it('parses WEEKLY with days', () => {
          const result = parseRRule('FREQ=WEEKLY;BYDAY=MO,WE,FR');
          assertEqual(result.frequency, 'WEEKLY');
          assert(result.days.includes('MO'), 'Should include MO');
          assert(result.days.includes('WE'), 'Should include WE');
          assert(result.days.includes('FR'), 'Should include FR');
        });

        it('parses MONTHLY', () => {
          const result = parseRRule('FREQ=MONTHLY');
          assertEqual(result.frequency, 'MONTHLY');
        });

        it('handles RRULE: prefix', () => {
          const result = parseRRule('RRULE:FREQ=WEEKLY;BYDAY=TU');
          assertEqual(result.frequency, 'WEEKLY');
          assert(result.days.includes('TU'), 'Should include TU');
        });

        it('roundtrips with buildRRule', () => {
          const original = buildRRule('WEEKLY', ['MO', 'TH']);
          const parsed = parseRRule(original);
          assertEqual(parsed.frequency, 'WEEKLY');
          assert(parsed.days.includes('MO'), 'Should include MO');
          assert(parsed.days.includes('TH'), 'Should include TH');
        });
      });

      describe('detectRecurrence', () => {
        it('returns null for null', () => {
          assertEqual(detectRecurrence(null), null);
        });

        it('returns null for non-recurring text', () => {
          assertEqual(detectRecurrence('Join us for a concert this Saturday'), null);
        });

        it('detects "every Wednesday"', () => {
          const result = detectRecurrence('Circus jam every Wednesday at 7pm');
          assertEqual(result.frequency, 'WEEKLY');
          assertDeepEqual(result.days, ['WE']);
        });

        it('detects "every Monday" (case insensitive)', () => {
          const result = detectRecurrence('Trivia Every Monday');
          assertEqual(result.frequency, 'WEEKLY');
          assertDeepEqual(result.days, ['MO']);
        });

        it('detects "weekly"', () => {
          const result = detectRecurrence('Weekly open mic night');
          assertEqual(result.frequency, 'WEEKLY');
          assertDeepEqual(result.days, []);
        });

        it('detects "every week"', () => {
          const result = detectRecurrence('Happens every week');
          assertEqual(result.frequency, 'WEEKLY');
        });

        it('detects "monthly"', () => {
          const result = detectRecurrence('Monthly meetup');
          assertEqual(result.frequency, 'MONTHLY');
        });

        it('detects ordinal day patterns like "1st Tuesday"', () => {
          const result = detectRecurrence('Bluegrass Jam Night - 1st Tuesday of Every Month');
          assertEqual(result.frequency, 'MONTHLY');
          assertEqual(result.ordinal, 1);
          assertEqual(result.monthDay, 'TU');
        });

        it('detects "1st and 3rd Monday" (extracts first ordinal)', () => {
          const result = detectRecurrence('Meets 1st and 3rd Monday of each month');
          assertEqual(result.frequency, 'MONTHLY');
          assertEqual(result.ordinal, 1);
          assertEqual(result.monthDay, 'MO');
        });

        it('detects "2nd Friday"', () => {
          const result = detectRecurrence('2nd Friday open mic');
          assertEqual(result.frequency, 'MONTHLY');
          assertEqual(result.ordinal, 2);
          assertEqual(result.monthDay, 'FR');
        });

        it('detects "first Wednesday" (word-form ordinal)', () => {
          const result = detectRecurrence('meets the first Wednesday of each month');
          assertEqual(result.frequency, 'MONTHLY');
          assertEqual(result.ordinal, 1);
          assertEqual(result.monthDay, 'WE');
        });

        it('detects "second Tuesday" (word-form ordinal)', () => {
          const result = detectRecurrence('second Tuesday of every month');
          assertEqual(result.frequency, 'MONTHLY');
          assertEqual(result.ordinal, 2);
          assertEqual(result.monthDay, 'TU');
        });

        it('detects "fourth Friday" (word-form ordinal)', () => {
          const result = detectRecurrence('fourth Friday happy hour');
          assertEqual(result.frequency, 'MONTHLY');
          assertEqual(result.ordinal, 4);
          assertEqual(result.monthDay, 'FR');
        });

        it('checks multiple arguments — finds recurrence in title when description has none', () => {
          const result = detectRecurrence('A fun event this Saturday', 'Circus jam every Wednesday');
          assertEqual(result.frequency, 'WEEKLY');
          assertDeepEqual(result.days, ['WE']);
        });

        it('checks multiple arguments — finds recurrence in description first', () => {
          const result = detectRecurrence('Happens every week', 'Weekly jam session');
          assertEqual(result.frequency, 'WEEKLY');
          assertDeepEqual(result.days, []);
        });

        it('checks multiple arguments — returns null when neither matches', () => {
          assertEqual(detectRecurrence('A concert', 'Fun times'), null);
        });

        it('checks multiple arguments — skips null/undefined args', () => {
          const result = detectRecurrence(null, undefined, 'Monthly meetup');
          assertEqual(result.frequency, 'MONTHLY');
        });
      });

      describe('getNextOccurrence', () => {
        const enrichments = [{
          event_id: 42,
          rrule: 'FREQ=WEEKLY;BYDAY=WE',
          start_time: '2026-02-04T19:00:00Z'
        }];

        it('returns originalStartTime when enrichments is null', () => {
          assertEqual(getNextOccurrence(null, 42, '2026-02-04T19:00:00Z'), '2026-02-04T19:00:00Z');
        });

        it('returns originalStartTime when enrichments is empty array', () => {
          assertEqual(getNextOccurrence([], 42, '2026-02-04T19:00:00Z'), '2026-02-04T19:00:00Z');
        });

        it('returns originalStartTime when eventId has no matching enrichment', () => {
          assertEqual(getNextOccurrence(enrichments, 999, '2026-02-04T19:00:00Z'), '2026-02-04T19:00:00Z');
        });

        it('returns originalStartTime when enrichment has no rrule', () => {
          const noRrule = [{ event_id: 42, rrule: null, start_time: '2026-02-04T19:00:00Z' }];
          assertEqual(getNextOccurrence(noRrule, 42, '2026-02-04T19:00:00Z'), '2026-02-04T19:00:00Z');
        });

        it('returns empty string when originalStartTime is null', () => {
          assertEqual(getNextOccurrence(enrichments, 42, null), '');
        });

        it('returns a future date for a weekly enrichment', () => {
          const result = getNextOccurrence(enrichments, 42, '2026-02-04T19:00:00Z');
          assert(result, 'Should return a date string');
          const d = new Date(result);
          assert(!isNaN(d.getTime()), 'Should be a valid date');
          assert(d >= new Date('2026-02-09'), 'Should be today or later');
        });

        it('matches eventId with loose equality (string vs number)', () => {
          const result = getNextOccurrence(enrichments, '42', '2026-02-04T19:00:00Z');
          assert(result, 'Should return a date string');
          const d = new Date(result);
          assert(d >= new Date('2026-02-09'), 'Should find enrichment via loose equality');
        });
      });

      describe('formatPickDate', () => {
        const enrichments = [{
          event_id: 42,
          rrule: 'FREQ=WEEKLY;BYDAY=WE',
          start_time: '2026-02-04T19:00:00Z'
        }];

        it('returns formatted date for non-recurring pick', () => {
          const result = window.formatPickDate([], 42, '2026-02-15T19:00:00Z');
          assert(result.includes('Feb 15'), 'Should contain Feb 15, got: ' + result);
          assert(result.includes('Sun'), 'Should contain Sun, got: ' + result);
        });

        it('returns formatted date with time', () => {
          const result = window.formatPickDate([], 42, '2026-02-15T19:00:00Z');
          assert(result.includes('7:00 PM'), 'Should contain time, got: ' + result);
        });

        it('returns formatted date for recurring pick (next occurrence)', () => {
          const result = window.formatPickDate(enrichments, 42, '2026-02-04T19:00:00Z');
          assert(result.includes('Wed'), 'Should be a Wednesday, got: ' + result);
          assert(result.includes('7:00 PM'), 'Should contain time, got: ' + result);
        });

        it('handles null startTime gracefully', () => {
          const result = window.formatPickDate([], 42, null);
          assertEqual(typeof result, 'string');
        });
      });

      describe('dedupeEvents - rrule carry-through', () => {
        it('carries rrule from enrichment event to merged result', () => {
          clearDedupeCache();
          const events = [
            { id: 1, title: 'Circus jam', start_time: '2026-02-11T18:00:00Z', source: 'Bohemian' },
            { id: 'enrichment-5-2026-02-11T18:00:00.000Z', title: 'Circus jam', start_time: '2026-02-11T18:00:00.000Z', source: 'Picks: jon', rrule: 'FREQ=WEEKLY;BYDAY=WE' }
          ];
          const result = dedupeEvents(events);
          assertEqual(result.length, 1, 'Should merge into one event');
          assertEqual(result[0].rrule, 'FREQ=WEEKLY;BYDAY=WE', 'Should carry rrule');
          assert(result[0].source.includes('Bohemian'), 'Should include Bohemian source');
          assert(result[0].source.includes('Picks: jon'), 'Should include Picks source');
        });

        it('does not overwrite existing rrule', () => {
          clearDedupeCache();
          const events = [
            { id: 1, title: 'Test', start_time: '2026-02-11T18:00:00Z', source: 'A', rrule: 'FREQ=DAILY' },
            { id: 2, title: 'Test', start_time: '2026-02-11T18:00:00Z', source: 'B', rrule: 'FREQ=WEEKLY;BYDAY=MO' }
          ];
          const result = dedupeEvents(events);
          assertEqual(result[0].rrule, 'FREQ=DAILY', 'Should keep first rrule');
        });

        it('merged event without rrule has no rrule', () => {
          clearDedupeCache();
          const events = [
            { id: 1, title: 'Show', start_time: '2026-02-11T18:00:00Z', source: 'A' },
            { id: 2, title: 'Show', start_time: '2026-02-11T18:00:00Z', source: 'B' }
          ];
          const result = dedupeEvents(events);
          assert(!result[0].rrule, 'Should have no rrule');
        });
      });

      describe('expandEnrichments', () => {
        it('returns empty array for null', () => {
          assertDeepEqual(expandEnrichments(null, '2026-01-01', '2026-03-01'), []);
        });

        it('returns empty array for empty array', () => {
          assertDeepEqual(expandEnrichments([], '2026-01-01', '2026-03-01'), []);
        });

        it('skips enrichments without rrule', () => {
          const enrichments = [{ id: 1, title: 'Test', start_time: '2026-02-01T19:00:00Z', rrule: null }];
          const result = expandEnrichments(enrichments, '2026-01-01', '2026-03-01');
          assertEqual(result.length, 0);
        });

        it('skips enrichments without title', () => {
          const enrichments = [{ id: 1, title: null, start_time: '2026-02-01T19:00:00Z', rrule: 'FREQ=WEEKLY;BYDAY=WE' }];
          const result = expandEnrichments(enrichments, '2026-01-01', '2026-03-01');
          assertEqual(result.length, 0);
        });

        it('expands WEEKLY rrule into occurrences', () => {
          const enrichments = [{
            id: 1,
            title: 'Weekly Jam',
            start_time: '2026-02-04T19:00:00Z', // a Wednesday
            rrule: 'FREQ=WEEKLY;BYDAY=WE',
            curator_name: 'jon',
            location: 'Cafe',
            city: 'davis'
          }];
          // 4 weeks range: should produce ~4 Wednesdays
          const result = expandEnrichments(enrichments, '2026-02-01T00:00:00Z', '2026-02-28T23:59:59Z');
          assert(result.length >= 3, 'Should produce at least 3 occurrences, got ' + result.length);
          assert(result.length <= 5, 'Should produce at most 5 occurrences, got ' + result.length);
        });

        it('sets source to "Picks: curator_name"', () => {
          const enrichments = [{
            id: 1,
            title: 'Weekly Jam',
            start_time: '2026-02-04T19:00:00Z',
            rrule: 'FREQ=WEEKLY;BYDAY=WE',
            curator_name: 'jon'
          }];
          const result = expandEnrichments(enrichments, '2026-02-01T00:00:00Z', '2026-02-28T23:59:59Z');
          assert(result.length > 0, 'Should have results');
          assertEqual(result[0].source, 'Picks: jon');
        });

        it('generates unique IDs per occurrence', () => {
          const enrichments = [{
            id: 1,
            title: 'Weekly Jam',
            start_time: '2026-02-04T19:00:00Z',
            rrule: 'FREQ=WEEKLY;BYDAY=WE',
            curator_name: 'jon'
          }];
          const result = expandEnrichments(enrichments, '2026-02-01T00:00:00Z', '2026-02-28T23:59:59Z');
          const ids = result.map(e => e.id);
          const uniqueIds = new Set(ids);
          assertEqual(uniqueIds.size, ids.length, 'All IDs should be unique');
        });

        it('copies fields from enrichment', () => {
          const enrichments = [{
            id: 1,
            title: 'Weekly Jam',
            start_time: '2026-02-04T19:00:00Z',
            rrule: 'FREQ=WEEKLY;BYDAY=WE',
            curator_name: 'jon',
            location: 'Cafe',
            description: 'Fun times',
            url: 'http://example.com'
          }];
          const result = expandEnrichments(enrichments, '2026-02-01T00:00:00Z', '2026-02-28T23:59:59Z');
          assertEqual(result[0].location, 'Cafe');
          assertEqual(result[0].description, 'Fun times');
          assertEqual(result[0].url, 'http://example.com');
        });

        it('only produces occurrences within date range', () => {
          const enrichments = [{
            id: 1,
            title: 'Weekly Jam',
            start_time: '2026-02-04T19:00:00Z',
            rrule: 'FREQ=WEEKLY;BYDAY=WE',
            curator_name: 'jon'
          }];
          // Narrow range: one week
          const result = expandEnrichments(enrichments, '2026-02-09T00:00:00Z', '2026-02-15T23:59:59Z');
          assertEqual(result.length, 1, 'Should produce exactly 1 occurrence');
        });
      });

      // ============================================================
      // REAL DATA TESTS (async, run after initial render)
      // ============================================================

      const SUPABASE_URL = 'https://dzpdualvwspgqghrysyz.supabase.co';
      const SUPABASE_KEY = 'sb_publishable_NnzobdoFNU39fjs84UNq8Q_X45oiMG5';

      async function runRealDataTests() {
        // Fetch real events
        const url = `${SUPABASE_URL}/rest/v1/events?select=*&order=start_time.asc&limit=500`;
        const response = await fetch(url, {
          headers: { apikey: SUPABASE_KEY }
        });
        const events = await response.json();

        const realDataGroup = { name: `Real Data (${events.length} events fetched)`, tests: [] };

        // Helper to add test results
        const test = (name, fn) => {
          try {
            fn();
            realDataGroup.tests.push({ name, pass: true });
          } catch (e) {
            realDataGroup.tests.push({ name, pass: false, error: e.message });
          }
        };

        // Basic sanity checks
        test('Events array is not empty', () => {
          assert(events.length > 0, 'No events fetched');
        });

        test('All events have required fields (id, title, start_time)', () => {
          const missing = events.filter(e => !e.id || !e.title || !e.start_time);
          assert(missing.length === 0, `${missing.length} events missing required fields`);
        });

        // filterEvents tests
        test('filterEvents handles real data without crashing', () => {
          const result = filterEvents(events, 'music');
          assert(Array.isArray(result), 'Should return array');
        });

        test('filterEvents with empty string returns all events', () => {
          const result = filterEvents(events, '');
          assertEqual(result.length, events.length);
        });

        // dedupeEvents tests
        test('dedupeEvents handles real data without crashing', () => {
          clearDedupeCache();
          const result = dedupeEvents(events);
          assert(Array.isArray(result), 'Should return array');
        });

        test('dedupeEvents reduces event count (finds duplicates)', () => {
          clearDedupeCache();
          const result = dedupeEvents(events);
          // Real data should have some duplicates from multiple sources
          console.log(`Dedupe: ${events.length} → ${result.length} events`);
          assert(result.length <= events.length, 'Deduped count should be <= original');
        });

        test('dedupeEvents preserves mergedIds for all events', () => {
          clearDedupeCache();
          const result = dedupeEvents(events);
          const missingMergedIds = result.filter(e => !e.mergedIds || !Array.isArray(e.mergedIds));
          assert(missingMergedIds.length === 0, `${missingMergedIds.length} events missing mergedIds`);
        });

        test('dedupeEvents result is sorted by start_time', () => {
          clearDedupeCache();
          const result = dedupeEvents(events);
          for (let i = 1; i < result.length; i++) {
            assert(
              result[i].start_time >= result[i-1].start_time,
              `Events not sorted at index ${i}`
            );
          }
        });

        // formatTime tests with real data
        test('formatTime handles all real start_times', () => {
          let errors = [];
          events.forEach((e, i) => {
            try {
              const result = formatTime(e.start_time);
              assert(typeof result === 'string', `Event ${i} returned non-string`);
            } catch (err) {
              errors.push(`Event ${i}: ${err.message}`);
            }
          });
          assert(errors.length === 0, errors.slice(0, 3).join('; '));
        });

        test('formatDayOfWeek handles all real start_times', () => {
          let errors = [];
          events.forEach((e, i) => {
            try {
              const result = formatDayOfWeek(e.start_time);
              assert(typeof result === 'string', `Event ${i} returned non-string`);
            } catch (err) {
              errors.push(`Event ${i}: ${err.message}`);
            }
          });
          assert(errors.length === 0, errors.slice(0, 3).join('; '));
        });

        // getDescriptionSnippet with real descriptions
        test('getDescriptionSnippet handles all real descriptions', () => {
          let errors = [];
          events.forEach((e, i) => {
            try {
              // Some events have descriptions, some don't
              const result = getDescriptionSnippet(e.description, 'the');
              assert(result === null || typeof result === 'string', `Event ${i} bad result type`);
            } catch (err) {
              errors.push(`Event ${i}: ${err.message}`);
            }
          });
          assert(errors.length === 0, errors.slice(0, 3).join('; '));
        });

        // getSourceCounts with real data
        test('getSourceCounts returns valid counts', () => {
          const counts = getSourceCounts(events);
          assert(Array.isArray(counts), 'Should return array');
          assert(counts.length > 0, 'Should have at least one source');
          const totalCount = counts.reduce((sum, c) => sum + c.count, 0);
          assertEqual(totalCount, events.length);
        });

        test('getSourceCounts sources are sorted by count descending', () => {
          const counts = getSourceCounts(events);
          for (let i = 1; i < counts.length; i++) {
            assert(counts[i].count <= counts[i-1].count, `Sources not sorted at index ${i}`);
          }
        });

        // Edge case: events with null/undefined optional fields
        test('Handles events with null optional fields', () => {
          const nullCount = events.filter(e => !e.location || !e.description || !e.url).length;
          console.log(`Events with null optional fields: ${nullCount}`);
          // Just verify we can process them
          clearDedupeCache();
          const result = dedupeEvents(events);
          assert(result.length > 0, 'Should still produce results');
        });

        // Edge case: very long titles or descriptions
        test('Handles long text fields', () => {
          const longTitle = events.filter(e => e.title && e.title.length > 100);
          const longDesc = events.filter(e => e.description && e.description.length > 1000);
          console.log(`Long titles (>100 chars): ${longTitle.length}, Long descriptions (>1000 chars): ${longDesc.length}`);

          longDesc.forEach(e => {
            const snippet = getDescriptionSnippet(e.description, 'the');
            if (snippet) {
              assert(snippet.length < 200, 'Snippet should be reasonably short');
            }
          });
        });

        // Edge case: special characters
        test('Handles special characters in text', () => {
          const specialChars = events.filter(e =>
            (e.title && /[<>&"']/.test(e.title)) ||
            (e.description && /[<>&"']/.test(e.description))
          );
          console.log(`Events with special chars (<>&"'): ${specialChars.length}`);
          // Verify filtering works with special chars
          specialChars.slice(0, 5).forEach(e => {
            filterEvents([e], e.title?.substring(0, 5) || 'test');
          });
        });

        // Add to results and re-render
        results.push(realDataGroup);
        render();
      }

      // ============================================================
      // RENDER RESULTS
      // ============================================================

      function render() {
        let totalPass = 0;
        let totalFail = 0;

        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';

        results.forEach(group => {
          const groupDiv = document.createElement('div');
          groupDiv.className = 'test-group';

          const groupPassed = group.tests.filter(t => t.pass).length;
          const groupTotal = group.tests.length;
          totalPass += groupPassed;
          totalFail += (groupTotal - groupPassed);

          groupDiv.innerHTML = `<h2>${group.name} (${groupPassed}/${groupTotal})</h2>`;

          group.tests.forEach(test => {
            const testDiv = document.createElement('div');
            testDiv.className = `test ${test.pass ? 'pass' : 'fail'}`;
            testDiv.innerHTML = `
              <span class="status">${test.pass ? 'PASS' : 'FAIL'}</span>
              <span class="name">${test.name}</span>
              ${test.error ? `<span class="error">${test.error}</span>` : ''}
            `;
            groupDiv.appendChild(testDiv);
          });

          resultsDiv.appendChild(groupDiv);
        });

        const summaryDiv = document.getElementById('summary');
        const allPass = totalFail === 0;
        summaryDiv.className = `summary ${allPass ? 'pass' : 'fail'}`;
        summaryDiv.textContent = allPass
          ? `All ${totalPass} tests passed`
          : `${totalFail} of ${totalPass + totalFail} tests failed`;
      }

      render();

      // Show loading indicator for real data
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'test-group';
      loadingDiv.innerHTML = '<h2>Real Data (loading...)</h2>';
      document.getElementById('results').appendChild(loadingDiv);

      // Run real data tests (async)
      runRealDataTests().then(() => {
        loadingDiv.remove();
      }).catch(err => {
        loadingDiv.remove();
        results.push({
          name: 'Real Data',
          tests: [{ name: 'Fetch events', pass: false, error: err.message }]
        });
        render();
      });
    </script>
  </body>
</html>
