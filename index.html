<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Community Calendar</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="xmlui/0.11.33-inspector.js"></script>
    <script>
      // Supabase auth setup (credentials loaded from config.json by XMLUI)
      // We need to hardcode these here since this runs before XMLUI loads config
      const SUPABASE_URL = 'https://dzpdualvwspgqghrysyz.supabase.co';
      const SUPABASE_KEY = 'sb_publishable_NnzobdoFNU39fjs84UNq8Q_X45oiMG5';
      const sb = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

      window.authUser = null;
      window.authSession = null;

      window.signIn = () => {
        window.location.href = SUPABASE_URL +
          '/auth/v1/authorize?provider=github&redirect_to=' + window.location.origin + window.location.pathname;
      };

      window.signOut = function() {
        console.log('signOut called');
        localStorage.removeItem('sb-dzpdualvwspgqghrysyz-auth-token');
        console.log('localStorage cleared, reloading...');
        window.location.reload();
      };

      sb.auth.onAuthStateChange(async (event, session) => {
        window.authSession = session;
        window.authUser = session?.user || null;
        console.log('Auth state changed:', event, window.authUser?.email);

        // Create feed token on first sign-in if it doesn't exist
        // Uses fetch directly since Supabase JS client has issues
        if (session?.user) {
          const headers = {
            'apikey': SUPABASE_KEY,
            'Authorization': 'Bearer ' + session.access_token,
            'Content-Type': 'application/json',
            'Prefer': 'return=minimal'
          };

          const checkUrl = `${SUPABASE_URL}/rest/v1/feed_tokens?select=token&user_id=eq.${session.user.id}`;
          const checkRes = await fetch(checkUrl, { headers });
          const existing = await checkRes.json();
          console.log('Feed token check:', existing);

          if (!existing || existing.length === 0) {
            const insertUrl = `${SUPABASE_URL}/rest/v1/feed_tokens`;
            const insertRes = await fetch(insertUrl, {
              method: 'POST',
              headers,
              body: JSON.stringify({ user_id: session.user.id })
            });
            if (insertRes.ok) {
              console.log('Created feed token for new user');
            } else {
              console.error('Error creating feed token:', insertRes.status);
            }
          }
        }
      });

      // Handle OAuth callback
      if (window.location.hash.includes('access_token')) {
        sb.auth.getSession().then(() => {
          window.location.replace(window.location.pathname);
        });
      }

      // Toggle pick for an event (add or remove from user's picks)
      // Uses fetch directly since Supabase JS client has issues with UMD bundle
      window.togglePick = async function(eventId) {
        console.log('togglePick called with eventId:', eventId);
        if (!window.authSession) {
          alert('Please sign in to pick events');
          return;
        }
        const headers = {
          'apikey': SUPABASE_KEY,
          'Authorization': 'Bearer ' + window.authSession.access_token,
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        };
        const userId = window.authUser.id;

        // Check if already picked
        const checkUrl = `${SUPABASE_URL}/rest/v1/picks?select=id&user_id=eq.${userId}&event_id=eq.${eventId}`;
        const checkRes = await fetch(checkUrl, { headers });
        const existing = await checkRes.json();
        console.log('Existing picks:', existing);

        if (existing && existing.length > 0) {
          // Remove pick
          console.log('Removing pick:', existing[0].id);
          const deleteUrl = `${SUPABASE_URL}/rest/v1/picks?id=eq.${existing[0].id}`;
          const deleteRes = await fetch(deleteUrl, { method: 'DELETE', headers });
          console.log('Delete response:', deleteRes.status);
        } else {
          // Add pick
          console.log('Adding pick for event:', eventId);
          const insertUrl = `${SUPABASE_URL}/rest/v1/picks`;
          const insertRes = await fetch(insertUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify({ user_id: userId, event_id: eventId })
          });
          console.log('Insert response:', insertRes.status);
        }
      };

      // Check if an event is picked (use == for type coercion since IDs may be string or number)
      window.isEventPicked = function(eventId, picks) {
        if (!picks || !Array.isArray(picks)) return false;
        return picks.some(p => p.event_id == eventId);
      };
    </script>
    <script>
      // Date range helpers for upcoming events (one hour ago to one week out)
      // Pre-compute at load time to avoid timing issues with XMLUI expressions
      // NOTE: Event times are stored as local times with +00:00 marker, so we format
      // local times directly (not true UTC) to match the database format
      (function() {
        const pad = n => n.toString().padStart(2, '0');
        const formatLocal = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;

        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
        const oneWeekLater = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
        window.fromDate = formatLocal(oneHourAgo);
        window.toDate = formatLocal(oneWeekLater);
        console.log('Date range initialized:', window.fromDate, 'to', window.toDate);
      })();

      // Keep functions for debugging
      window.getFromDate = function() { return window.fromDate; };
      window.getToDate = function() { return window.toDate; };

      // Filter events by search term (searches title, location, source, and description)
      window.filterEvents = function(events, term) {
        if (!events) return events || [];
        if (!term) return events;
        const lower = term.toLowerCase();
        return events.filter(e =>
          (e.title && e.title.toLowerCase().includes(lower)) ||
          (e.location && e.location.toLowerCase().includes(lower)) ||
          (e.source && e.source.toLowerCase().includes(lower)) ||
          (e.description && e.description.toLowerCase().includes(lower))
        );
      };

      // Get description snippet with context around search term (returns null if no match in description)
      window.getDescriptionSnippet = function(description, term) {
        if (!description || !term) return null;
        const lower = description.toLowerCase();
        const termLower = term.toLowerCase();
        const idx = lower.indexOf(termLower);
        if (idx === -1) return null;

        // Extract context window (40 chars before and after)
        const contextSize = 40;
        const start = Math.max(0, idx - contextSize);
        const end = Math.min(description.length, idx + term.length + contextSize);

        let snippet = '';
        if (start > 0) snippet += '...';
        snippet += description.substring(start, idx);
        snippet += '**' + description.substring(idx, idx + term.length) + '**';
        snippet += description.substring(idx + term.length, end);
        if (end < description.length) snippet += '...';

        return snippet;
      };

      // Format day of week (using UTC since times were stored as local but marked UTC)
      window.formatDayOfWeek = function(isoString) {
        if (!isoString) return '';
        return new Date(isoString).toLocaleDateString('en-US', { weekday: 'short', timeZone: 'UTC' });
      };

      // Format month and day (using UTC since times were stored as local but marked UTC)
      window.formatMonthDay = function(isoString) {
        if (!isoString) return '';
        return new Date(isoString).toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' });
      };

      // Format date for display
      window.formatDate = function(isoString) {
        if (!isoString) return '';
        const d = new Date(isoString);
        return d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
      };

      // Format time for display
      // Times were stored as local times but Supabase added +00:00, so use UTC values directly
      window.formatTime = function(isoString) {
        if (!isoString) return '';
        const d = new Date(isoString);
        const hours = d.getUTCHours();
        const mins = d.getUTCMinutes();
        // Skip midnight times (likely means time unknown)
        if (hours === 0 && mins === 0) return '';
        // Format as 12-hour time
        const h = hours % 12 || 12;
        const ampm = hours < 12 ? 'AM' : 'PM';
        const m = mins.toString().padStart(2, '0');
        return `${h}:${m} ${ampm}`;
      };

      // Truncate text with ellipsis
      window.truncate = function(text, maxLen) {
        if (!text) return '';
        if (text.length <= maxLen) return text;
        return text.substring(0, maxLen).trim() + '...';
      };

      // Aggregate events by source, return sorted array of {source, count}
      window.getSourceCounts = function(events) {
        if (!events || !events.length) return [];
        const counts = {};
        events.forEach(e => {
          const src = e.source || 'Unknown';
          counts[src] = (counts[src] || 0) + 1;
        });
        return Object.entries(counts)
          .map(([source, count]) => ({ source, count }))
          .sort((a, b) => b.count - a.count);
      };

      // Deduplicate events: merge events with same title + start_time, combine sources
      // Cached to avoid recomputing on every render
      window._dedupedEventsCache = null;
      window._dedupedEventsCacheKey = null;
      window.dedupeEvents = function(events) {
        if (!events || !events.length) return [];

        // Use cache if events array hasn't changed
        const cacheKey = events.length + '-' + (events[0]?.id || '');
        if (window._dedupedEventsCacheKey === cacheKey && window._dedupedEventsCache) {
          return window._dedupedEventsCache;
        }

        const groups = {};
        events.forEach(e => {
          const key = (e.title || '').trim().toLowerCase() + '|' + (e.start_time || '');
          if (!groups[key]) {
            groups[key] = { ...e, sources: [e.source] };
          } else {
            // Add source if not already present
            if (!groups[key].sources.includes(e.source)) {
              groups[key].sources.push(e.source);
            }
            // Prefer non-empty values for other fields
            if (!groups[key].url && e.url) groups[key].url = e.url;
            if (!groups[key].location && e.location) groups[key].location = e.location;
            if (!groups[key].description && e.description) groups[key].description = e.description;
          }
        });
        // Convert sources array to comma-separated string
        const result = Object.values(groups).map(e => ({
          ...e,
          source: e.sources.sort().join(', ')
        })).sort((a, b) => (a.start_time || '').localeCompare(b.start_time || ''));

        // Cache the result
        window._dedupedEventsCache = result;
        window._dedupedEventsCacheKey = cacheKey;
        return result;
      };
    </script>
  </head>
  <body>
  </body>
</html>
